<h1>はじめに</h1>
<h2>Tiptap ってなに？</h2>
<p>Tiptap は、<a href="https://ProseMirror.net">ProseMirror</a> のヘッドレスラッパーです。リッチテキスト WYSIWYG エディターを構築するためのツールキットであり、 <em>New York Times</em> 、<em>The Guardian</em> または <em>Atlassian</em> などの多くの有名企業ですでに使用されています。</p>
<p>カスタマイズ可能なビルディングブロックから、必要なリッチテキストエディタを正確に作成します。 Tiptap には、賢明なデフォルト、多くの拡張機能、あらゆる側面をカスタマイズするための使いやすい API が付属しています。ウェルカムなコミュニティ、オープンソースに支えられています。</p>
<h2>「ヘッドレス」ってどういう意味？</h2>
<p>Tiptap が提供しているユーザーインターフェイスはありません。必要なインターフェイスを自由に作成できます。クラスを上書きする必要はありません。<code>!important</code> やその他のハックを使用するために、慣れているセットアップで好きなものを書くだけです。</p>
<h2>Tiptap を使用する理由は？</h2>
<p><a href="https://ProseMirror.net">ProseMirror</a> は、よく書かれた、信頼性が高く、非常に強力なエディターツールキットです。ほとんどの人が探しているすぐに使えるエディタではありませんが、Tiptap を使用すると、数分で開始し、多数のすばらしい拡張機能から選択して、本当に必要なときに強力な ProseMirrorAPI にアクセスできます。</p>
<h1>インストール</h1>
<h2>はじめに</h2>

<p>Tiptap はフレームワークに依存せず、Vanilla JavaScript でも機能します（それがあなたのものである場合）。次の統合ガイドは、JavaScript プロジェクトに Tiptap を統合するのに役立ちます。</p>
<h2>統合ガイド</h2>
<ul>
<li>
<a href="/installation/cdn">CDN</a>
</li>
<li>
<a href="/installation/react">React</a>
</li>
<li>
<a href="/installation/nextjs">Next.js</a>
</li>
<li>
<a href="/installation/vue3">Vue 3</a>
</li>
<li>
<a href="/installation/vue2">Vue 2</a>
</li>
<li>
<a href="/installation/nuxt">Nuxt.js</a>
</li>
<li>
<a href="/installation/svelte">Svelte</a>
</li>
<li>
<a href="/installation/alpine">Alpine.js</a>
</li>
<li>
<a href="/installation/php">PHP</a>
</li>
</ul>
<h3>コミュニティの取り組み</h3>
<ul>
<li>
<a href="https://github.com/sibiraj-s/ngx-tiptap">Angular</a>
</li>
<li>
<a href="https://github.com/LXSMNSYC/solid-tiptap">SolidJS</a>
</li>
</ul>
<h2>バニラJavaScript</h2>

<p>プレーン JavaScript またはここにリストされていないフレームワークを使用していますか？心配いりません、私たちはあなたが必要とするすべてを提供します。</p>
<h3>1. 依存関係をインストール</h3>


<p>次の例では、<code>@tiptap/core</code>（実際のエディター）と <code>@tiptap/starter-kit</code> が必要になります。</p>
<p>StarterKit にはすべてが含まれているわけではありませんが、最も一般的な拡張機能が含まれています。</p>
<pre><code class="language-bash">npm install @tiptap/core @tiptap/starter-kit
</code></pre>
<h3>2. マークアップを追加</h3>

<p>エディターをマウントする場所に次の HTML を追加します。</p>
<pre><code class="language-html">&lt;div class=&quot;element&quot;&gt;&lt;/div&gt;
</code></pre>
<h3>3. エディターを初期化します</h3>

<p>これですべてが整ったので、実際のエディターをセットアップしましょう。次のコードを JavaScript に追加します。</p>
<pre><code class="language-js">
new Editor({
  element: document.querySelector('.element'),
  extensions: [
    StarterKit,
  ],
  content: '&lt;p&gt;Hello World!&lt;/p&gt;',
})
</code></pre>

<p>ブラウザでプロジェクトを開き、Tiptapの動作を確認します。よくできました！</p>
<h1>React</h1>
<h2>はじめに</h2>

<p>次のガイドでは、Tiptap を <a href="https://reactjs.org/">React</a> プロジェクトと統合する方法について説明します。ここでは<a href="https://reactjs.org/docs/getting-started.html">CreateReactApp</a> を使用していますが、ワークフローは他の設定と同様である必要があります。</p>
<h2>Reactアプリを作成</h2>
<h3>クイックスタート</h3>

<p>Tiptap を起動して実行したいだけの場合は、<a href="https://github.com/alb/cra-template-tiptap">Tiptap Create React App template by @alb</a> を使用して、すべての以下の手順はすでに完了しています。</p>
<pre><code class="language-bash">npx create-react-app my-tiptap-project --template tiptap
</code></pre>
<h3>ステップバイステップ</h3>
<p>すべての手順を以下に示しますが、動画をご覧になりたい場合は、次の手順もご用意しています。</p>

<p><a href="https://tiptap.dev/screencasts/installation/install-tiptap-with-create-react-app">https://tiptap.dev/screencasts/installation/install-tiptap-with-create-react-app</a></p>
<h4>1.プロジェクトを作成（オプション）</h4>
<p><code>my-tiptap-project</code> と呼ばれる新しい React プロジェクトから始めましょう。 <a href="https://reactjs.org/docs/getting-started.html">Reactアプリの作成</a> は、必要なものすべてをセットアップします。</p>

<pre><code class="language-bash"># create a project with npm
npx create-react-app my-tiptap-project

# change directory
cd my-tiptap-project
</code></pre>
<h4>2.依存関係をインストール</h4>
<p><code>@tiptap/react</code> パッケージと<a href="/api/extends/starter-kit"><code>StarterKit</code></a> をインストールします。これには、すぐに開始できる最も人気のある拡張機能があります。</p>

<pre><code class="language-bash">npm install @tiptap/react @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、<code>npm run start</code>を使用してプロジェクトを開始し、ブラウザで<a href="http://localhost:3000">http://localhost:3000</a> を開くことができます。</p>
<h4>3.新しいコンポーネントを作成</h4>
<p>Tiptap の使用を実際に開始するには、新しいコンポーネントを作成する必要があります。これを <code>Tiptap</code> と呼び、次のサンプルコードを <code>src/Tiptap.jsx</code> に配置します。</p>

<pre><code class="language-jsx">// src/Tiptap.jsx

const Tiptap = () =&gt; {
  const editor = useEditor({
    extensions: [
      StarterKit,
    ],
    content: '&lt;p&gt;Hello World!&lt;/p&gt;',
  })

  return (
    &lt;EditorContent editor={editor} /&gt;
  )
}

export default Tiptap
</code></pre>
<h4>4.アプリに追加</h4>
<p>最後に、<code>src/App.js</code> のコンテンツを新しい<code>Tiptap</code> コンポーネントに置き換えます。</p>

<pre><code class="language-jsx">
const App = () =&gt; {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Tiptap /&gt;
    &lt;/div&gt;
  )
}

export default App
</code></pre>

<p>これで、ブラウザにTiptapの非常に基本的な例が表示されるはずです。</p>
<h4>5.完全なセットアップ（オプション）</h4>
<p>さらに追加する準備はできましたか？以下は、基本的なツールバーを設定する方法を示すデモです。お気軽にご利用いただき、ニーズに合わせてカスタマイズを開始してください。</p>

<p><a href="https://embed.tiptap.dev/preview/Examples/Default">https://embed.tiptap.dev/preview/Examples/Default</a></p>
<h1>Next.js</h1>
<h2>はじめに</h2>

<p>次のガイドでは、Tiptap を<a href="https://nextjs.org/">Next.js</a> プロジェクトと統合する方法について説明します。</p>
<h2>要件</h2>
<ul>
<li>
<a href="https://nodejs.org/en/download/">ノード</a> がマシンにインストールされている</li>
<li>
<a href="https://reactjs.org/">React</a> の経験</li>
</ul>


<h2>1. プロジェクトを作成（オプション）</h2>
<p>既存の Next.js プロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>


<p>このガイドのために、<code>my-tiptap-project</code>という新しい Next.js プロジェクトから始めましょう。次のコマンドは、開始するために必要なすべてを設定します。</p>
<pre><code class="language-bash"># create a project
npx create-next-app my-tiptap-project

# change directory
cd my-tiptap-project
</code></pre>
<h2>2.依存関係をインストール</h2>
<p>標準のボイラープレートが設定されたので、Tiptap の起動と実行を開始できます。このためには、<code>@tiptap/react</code> と <code>@tiptap/starter-kit</code> の2つのパッケージをインストールする必要があります。これらのパッケージにはすぐに開始するために必要なすべての拡張機能が含まれています。</p>

<pre><code class="language-bash">npm install @tiptap/react @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、<code>npm run dev</code> を使用してプロジェクトを開始し、お気に入りのブラウザで <a href="http://localhost:3000/">http://localhost:3000 /</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3.新しいコンポーネントを作成</h2>
<p>Tiptap の使用を実際に開始するには、アプリに新しいコンポーネントを追加する必要があります。これを行うには、最初に <code>components/</code> というディレクトリを作成します。次に、<code>Tiptap</code> と呼ぶコンポーネントを作成します。これを行うには、次のサンプルコードを  <code>components/Tiptap.js</code> に配置します。</p>

<pre><code class="language-jsx">
const Tiptap = () =&gt; {
  const editor = useEditor({
    extensions: [
      StarterKit,
    ],
    content: '&lt;p&gt;Hello World! 🌎️&lt;/p&gt;',
  })

  return (
    &lt;EditorContent editor={editor} /&gt;
  )
}

export default Tiptap;
</code></pre>
<h2>4.アプリに追加</h2>
<p>次に、<code>pages/index.js</code> のコンテンツを次のサンプルコードに置き換えて、アプリで新しい <code>Tiptap</code> コンポーネントを使用します。</p>

<pre><code class="language-jsx">
export default function Home() {
    return (
         &lt;Tiptap /&gt;
    )
}
</code></pre>

<p>これで、ブラウザに Tiptap が表示されます。背中を軽くたたく時間です！ :)</p>
<h1>Vue.js 3</h1>
<h2>はじめに</h2>

<p>次のガイドでは、Tiptap を <a href="https://vuejs.org/">Vue</a> CLI プロジェクトと統合する方法について説明します。</p>
<h2>要件</h2>
<ul>
<li>
<a href="https://nodejs.org/en/download/">Node</a> がマシンにインストールされている</li>
<li>
<a href="https://cli.vuejs.org/">Vue CLI</a> がマシンにインストールされている</li>
<li>
<a href="https://v3.vuejs.org/guide/introduction.html">Vue</a>
</li>
</ul>

<h2>1. プロジェクトを作成（オプション）</h2>
<p>既存のVueプロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>
<p>このガイドのために、<code>my-tiptap-project</code> と呼ばれる新しい Vue プロジェクトから始めましょう。 Vue CLI は、必要なものをすべてセットアップします。Vue3 テンプレートを選択するだけです。</p>


<pre><code class="language-bash"># create a project
vue create my-tiptap-project

# change directory
cd my-tiptap-project
</code></pre>
<h2>2. 依存関係をインストール</h2>
<p>さて、退屈な定型的な作業は十分です。いよいよTiptapをインストールしましょう！次の例では、いくつかのコンポーネントを含む <code>@tiptap/vue-3</code> パッケージと、すぐに開始するための最も一般的な拡張機能を備えた <code>@tiptap/starter-kit</code> が必要です。</p>

<pre><code class="language-bash">npm install @tiptap/vue-3 @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、「npm runserve」を使用してプロジェクトを開始し、お気に入りのブラウザで <a href="http://localhost:8080">http://localhost:8080</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3. 新しいコンポーネントを作成</h2>
<p>Tiptap の使用を実際に開始するには、アプリに新しいコンポーネントを追加する必要があります。それを <code>Tiptap</code> と呼び、次のサンプルコードを <code>components/Tiptap.vue</code> に入れましょう。</p>
<p>これは、Tiptap を Vue で起動して実行するための最速の方法です。ボタンのない、非常に基本的なバージョンの Tiptap が提供されます。心配はいりません。まもなく機能を追加できるようになります。</p>


<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  data() {
    return {
      editor: null,
    }
  },

  mounted() {
    this.editor = new Editor({
      content: '&lt;p&gt;I’m running Tiptap with Vue.js. 🎉&lt;/p&gt;',
      extensions: [
        StarterKit,
      ],
    })
  },

  beforeUnmount() {
    this.editor.destroy()
  },
}
&lt;/script&gt;
</code></pre>

<p>または、CompositionAPI を <code>useEditor</code> メソッドで使用することもできます。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  setup() {
    const editor = useEditor({
      content: '&lt;p&gt;I’m running Tiptap with Vue.js. 🎉&lt;/p&gt;',
      extensions: [
        StarterKit,
      ],
    })

    return { editor }
  },
}
&lt;/script&gt;
</code></pre>

<p>または、新しい <a href="https://v3.vuejs.org/api/sfc-script-setup.html"><code>&lt;script setup&gt;</code> syntax</a> を自由に使用してください。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script setup&gt;

const editor = useEditor({
  content: '&lt;p&gt;I’m running Tiptap with Vue.js. 🎉&lt;/p&gt;',
  extensions: [
    StarterKit,
  ],
})
&lt;/script&gt;
</code></pre>
<h2>4. アプリに追加</h2>
<p>次に、 <code>src/App.vue</code> のコンテンツを次のサンプルコードに置き換えて、アプリで新しい <code>Tiptap</code> コンポーネントを使用します。</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;tiptap /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
  components: {
    Tiptap
  }
}
&lt;/script&gt;
</code></pre>

<p>これで、ブラウザに Tiptap が表示されます。背中を軽くたたく時間です！</p>
<h2>5. v-model の使用 (optional)</h2>
<p>おそらく、フォーム内の <code>v-model</code> を使用してデータをバインドすることに慣れているでしょう。これは、Tiptap でも可能です。これが Tiptap でどのように機能するかを示します。</p>

<p><a href="https://embed.tiptap.dev/preview/GuideGettingStarted/VModel">https://embed.tiptap.dev/preview/GuideGettingStarted/VModel</a></p>
<h1>Vue.js 2</h1>
<h2>はじめに</h2>

<p>次のガイドでは、Tiptapを<a href="https://vuejs.org/">Vue</a> CLIプロジェクトと統合する方法について説明します。</p>
<h2>要件</h2>
<ul>
<li>
<a href="https://nodejs.org/en/download/">Node</a> がマシンにインストールされている</li>
<li>
<a href="https://cli.vuejs.org/">Vue CLI</a> がマシンにインストールされている</li>
<li>[Vue]の経験(<a href="https://vuejs.org/v2/guide/#Getting-Started">https://vuejs.org/v2/guide/#Getting-Started</a>)</li>
</ul>

<h2>1. プロジェクトを作成（オプション）</h2>
<p>既存のVueプロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>


<p>このガイドのために、<code>my-tiptap-project</code> と呼ばれる新しい Vue プロジェクトから始めましょう。 Vue CLI は、必要なものをすべてセットアップします。デフォルトの Vue2 テンプレートを選択するだけです。</p>
<pre><code class="language-bash"># create a project
vue create my-tiptap-project

# change directory
cd my-tiptap-project
</code></pre>
<h2>2. 依存関係をインストール</h2>
<p>さて、退屈な定型的な作業は十分です。いよいよ Tiptap をインストールしましょう！次の例では、いくつかのコンポーネントを含む <code>@tiptap/vue-2</code> パッケージと、すぐに開始するための最も一般的な拡張機能を備えた <code>@tiptap/starter-kit</code> が必要です。</p>

<pre><code class="language-bash">npm install @tiptap/vue-2 @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、<code>npm run dev</code> を使用してプロジェクトを開始し、お気に入りのブラウザで <a href="http://localhost:8080">http://localhost:8080</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3. 新しいコンポーネントを作成</h2>
<p>Tiptap の使用を実際に開始するには、アプリに新しいコンポーネントを追加する必要があります。それを <code>Tiptap</code> と呼び、次のサンプルコードを <code>components/Tiptap.vue</code> に入れましょう。</p>
<p>これは、Tiptap を Vue で起動して実行するための最速の方法です。ボタンのない、非常に基本的なバージョンの Tiptap が提供されます。心配はいりません。まもなく機能を追加できるようになります。</p>


<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  data() {
    return {
      editor: null,
    }
  },

  mounted() {
    this.editor = new Editor({
      content: '&lt;p&gt;I’m running Tiptap with Vue.js. 🎉&lt;/p&gt;',
      extensions: [
        StarterKit,
      ],
    })
  },

  beforeDestroy() {
    this.editor.destroy()
  },
}
&lt;/script&gt;
</code></pre>
<h2>4. アプリに追加</h2>
<p>次に、<code>src/App.vue</code> のコンテンツを次のサンプルコードに置き換えて、アプリで新しい <code>Tiptap</code> コンポーネントを使用します。</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;tiptap /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
  components: {
    Tiptap
  }
}
&lt;/script&gt;
</code></pre>

<p>これで、ブラウザに Tiptap が表示されます。背中を軽くたたく時間です！</p>
<h2>5. v-model を使用 (オプション)</h2>
<p>おそらく、フォーム内の <code>v-model</code> を使用してデータをバインドするために使用されていますが、これは Tiptap でも可能です。これは、プロジェクトに統合できる実用的なサンプルコンポーネントです。</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  props: {
    value: {
      type: String,
      default: '',
    },
  },

  data() {
    return {
      editor: null,
    }
  },

  watch: {
    value(value) {
      // HTML
      const isSame = this.editor.getHTML() === value

      // JSON
      // const isSame = JSON.stringify(this.editor.getJSON()) === JSON.stringify(value)

      if (isSame) {
        return
      }

      this.editor.commands.setContent(value, false)
    },
  },

  mounted() {
    this.editor = new Editor({
      content: this.value,
      extensions: [
        StarterKit,
      ],
      onUpdate: () =&gt; {
        // HTML
        this.$emit('input', this.editor.getHTML())

        // JSON
        // this.$emit('input', this.editor.getJSON())
      },
    })
  },

  beforeDestroy() {
    this.editor.destroy()
  },
}
&lt;/script&gt;
</code></pre>
<h1>Nuxt.js</h1>
<h2>はじめに</h2>
<p>次のガイドでは、Tiptap を <a href="https://nuxtjs.org/">Nuxt.js</a> プロジェクトと統合する方法について説明します。</p>

<h2>要件</h2>
<ul>
<li>
<a href="https://nodejs.org/en/download/">Node</a> がマシンにインストールされている</li>
<li>
<a href="https://vuejs.org/v2/guide/#Getting-Started">Vue</a> の経験</li>
</ul>


<h2>1.プロジェクトを作成（オプション）</h2>
<p>既存の Vue プロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>


<p>このガイドのために、<code>my-tiptap-project</code> と呼ばれる新しいNuxt.js プロジェクトから始めましょう。次のコマンドは、必要なものすべてを設定します。それは多くの質問をしますが、あなたのボートを浮かぶものを使うか、デフォルトを使うだけです。</p>
<pre><code class="language-bash"># create a project
npm init nuxt-app my-tiptap-project

# change directory
cd my-tiptap-project
</code></pre>
<h2>2.依存関係をインストール</h2>
<p>さて、退屈な定型文の仕事は十分です。いよいよTiptapをインストールしましょう！次の例では、いくつかのコンポーネントを含む <code>@tiptap/vue-2</code> パッケージと、すぐに開始するための最も一般的な拡張機能を備えた<code>@tiptap/starter-kit</code> が必要です。</p>

<pre><code class="language-bash">npm install @tiptap/vue-2 @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、<code>npm run serve</code> を使用してプロジェクトを開始し、お気に入りのブラウザで <a href="http://localhost:8080/">http://localhost:8080/</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3.新しいコンポーネントを作成</h2>
<p>Tiptap の使用を実際に開始するには、アプリに新しいコンポーネントを追加する必要があります。これを <code>TiptapEditor</code> と呼び、次のサンプルコードを <code>components/TiptapEditor.vue</code> に配置します。</p>


<p>これは、Tiptap を Vue で起動して実行するための最速の方法です。ボタンのない、非常に基本的なバージョンのTiptapが提供されます。心配はいりません。まもなく機能を追加できるようになります。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  data() {
    return {
      editor: null,
    }
  },

  mounted() {
    this.editor = new Editor({
      content: '&lt;p&gt;I’m running Tiptap with Vue.js. 🎉&lt;/p&gt;',
      extensions: [
        StarterKit,
      ],
    })
  },

  beforeDestroy() {
    this.editor.destroy()
  },
}
&lt;/script&gt;
</code></pre>
<h2>4.アプリに追加</h2>
<p>次に、<code>pages/index.vue</code> のコンテンツを次のサンプルコードに置き換えて、アプリで新しい <code>TiptapEditor</code> コンポーネントを使用します。</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;client-only&gt;
      &lt;tiptap-editor /&gt;
    &lt;/client-only&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  components: {
    TiptapEditor
  }
}
&lt;/script&gt;
</code></pre>


<p>Tiptap は、サーバーではなくクライアントで実行する必要があることに注意してください。エディターを <code>&lt;client-only&gt;</code> タグでラップする必要があります。 <a href="https://nuxtjs.org/api/components-client-only">クライアント専用コンポーネントの詳細をご覧ください。</a></p>
<p>これで、ブラウザにTiptapが表示されます。背中を軽くたたく時間です！ :)</p>
<h2>5. v-model を使用（オプション）</h2>
<p>おそらく、フォーム内の <code>v-model</code> を使用してデータをバインドするために使用されていますが、これはTiptapでも可能です。これは、プロジェクトに統合できる実用的なサンプルコンポーネントです。</p>

<p><a href="https://embed.tiptap.dev/preview/GuideGettingStarted/VModel">https://embed.tiptap.dev/preview/GuideGettingStarted/VModel</a></p>
<pre><code class="language-html">&lt;template&gt;
  &lt;editor-content :editor=&quot;editor&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    EditorContent,
  },

  props: {
    value: {
      type: String,
      default: '',
    },
  },

  data() {
    return {
      editor: null,
    }
  },

  watch: {
    value(value) {
      // HTML
      const isSame = this.editor.getHTML() === value

      // JSON
      // const isSame = JSON.stringify(this.editor.getJSON()) === JSON.stringify(value)

      if (isSame) {
        return
      }

      this.editor.commands.setContent(value, false)
    },
  },

  mounted() {
    this.editor = new Editor({
      content: this.value,
      extensions: [
        StarterKit,
      ],
      onUpdate: () =&gt; {
        // HTML
        this.$emit('input', this.editor.getHTML())

        // JSON
        // this.$emit('input', this.editor.getJSON())
      },
    })
  },

  beforeDestroy() {
    this.editor.destroy()
  },
}
&lt;/script&gt;
</code></pre>
<h1>Svelte</h1>
<h2>はじめに</h2>

<p>次のガイドでは、Tiptapを <a href="https://kit.svelte.dev/">SvelteKit</a> プロジェクトと統合する方法について説明します。</p>
<h2>ショートカットを取る：Tiptapを使用したSvelte REPL</h2>
<p>すぐに飛び込みたい場合は、<a href="https://svelte.dev/repl/798f1b81b9184780aca18d9a005487d2?version=3.31.2">Svelte REPL with Tiptap</a> がインストールされています。</p>

<h2>要件</h2>
<ul>
<li>
<a href="https://nodejs.org/en/download/">Node</a> がマシンにインストールされている</li>
<li>
<a href="https://vuejs.org/v2/guide/#Getting-Started">Svelte</a> の経験</li>
</ul>
<h2>1.プロジェクトの作成（オプション）</h2>
<p>既存の SvelteKit プロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>
<p>このガイドのために、<code>my-tiptap-project</code> と呼ばれる新しいSvelteKitプロジェクトから始めましょう。次のコマンドは、必要なものすべてを設定します。それは多くの質問をしますが、あなたのボートを浮かぶものを使うか、デフォルトを使うだけです。</p>


<pre><code class="language-bash">mkdir my-tiptap-project
cd my-tiptap-project
npm init svelte@next
npm install
npm run dev
</code></pre>
<h2>2.依存関係をインストール</h2>
<p>さて、退屈な定型文の仕事は十分です。いよいよTiptapをインストールしましょう！次の例では、いくつかのコンポーネントを含む <code>@tiptap/core</code> パッケージと、すばやく開始するための最も一般的な拡張機能を備えた <code>@tiptap/starter-kit</code> が必要です。</p>

<pre><code class="language-bash">npm install @tiptap/core @tiptap/starter-kit
</code></pre>

<p>手順1 と 2 を実行した場合は、<code>npm run dev</code> を使用してプロジェクトを開始し、お気に入りのブラウザで<a href="http://localhost:3000">http://localhost:3000 /</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3.新しいコンポーネントを作成</h2>
<p>Tiptapの使用を実際に開始するには、アプリに新しいコンポーネントを追加する必要があります。それを <code>Tiptap</code> と呼び、次のサンプルコードを <code>src/lib/Tiptap.svelte</code> に入れましょう。</p>
<p>これは、SvelteKit で Tiptap を起動して実行するための最速の方法です。ボタンのない、非常に基本的なバージョンの Tiptap が提供されます。心配はいりません。まもなく機能を追加できるようになります。</p>


<pre><code class="language-html">&lt;script&gt;
      
  let element
  let editor

  onMount(() =&gt; {
    editor = new Editor({
      element: element,
      extensions: [
        StarterKit,
      ],
      content: '&lt;p&gt;Hello World! 🌍️ &lt;/p&gt;',
      onTransaction: () =&gt; {
        // force re-render so `editor.isActive` works as expected
        editor = editor
      },
    })
  })

  onDestroy(() =&gt; {
    if (editor) {
      editor.destroy()
    }
  })
&lt;/script&gt;

{#if editor}
  &lt;button
    on:click={() =&gt; editor.chain().focus().toggleHeading({ level: 1}).run()}
    class:active={editor.isActive('heading', { level: 1 })}
  &gt;
    H1
  &lt;/button&gt;
  &lt;button
    on:click={() =&gt; editor.chain().focus().toggleHeading({ level: 2 }).run()}
    class:active={editor.isActive('heading', { level: 2 })}
  &gt;
    H2
  &lt;/button&gt;
  &lt;button on:click={() =&gt; editor.chain().focus().setParagraph().run()} class:active={editor.isActive('paragraph')}&gt;
    P
  &lt;/button&gt;
{/if}

&lt;div bind:this={element} /&gt;

&lt;style&gt;
  button.active {
    background: black;
    color: white;
  }
&lt;/style&gt;
</code></pre>
<h2>4.アプリに追加</h2>
<p>次に、<code>src/routers/index.svelte</code>のコンテンツを次のサンプルコードに置き換えて、アプリで新しい <code>Tiptap</code> コンポーネントを使用します。</p>
<pre><code class="language-html">&lt;script&gt;
  &lt;/script&gt;

&lt;main&gt;
  &lt;Tiptap /&gt;
&lt;/main&gt;
</code></pre>

<p>これで、ブラウザにTiptapが表示されます。背中を軽くたたく時間です！ :)</p>
<h1>Alpine.js</h1>
<h2>はじめに</h2>


<p>次のガイドでは、Tiptap を <a href="https://github.com/alpinejs/alpine">Alpine.js</a> プロジェクトと統合する方法について説明します。</p>
<p>このガイドでは、<a href="https://vitejs.dev/">Vite</a> を使用してプロジェクトをすばやく設定しますが、慣れているものなら何でも使用できます。 Vite は本当に高速で、私たちはそれが大好きです。</p>
<h2>要件</h2>


<ul>
<li>
<a href="https://nodejs.org/en/download/">Node</a> がマシンにインストールされている</li>
<li>
<a href="https://github.com/alpinejs/alpine">Alpine.js</a> の経験</li>
</ul>
<h2>1. プロジェクトの作成（オプション）</h2>
<p>既存の Alpine.js プロジェクトがある場合は、それでも問題ありません。このステップをスキップして、次のステップに進んでください。</p>

<p>このガイドのために、 <code>my-tiptap-project</code> という新しい <a href="https://vitejs.dev/">Vite</a> プロジェクトから始めましょう。 Vite は必要なものをすべてセットアップします。Vanilla JavaScript テンプレートを選択するだけです。</p>

<pre><code class="language-bash">npm init vite@latest my-tiptap-project -- --template vanilla
cd my-tiptap-project
npm install
npm run dev
</code></pre>
<h2>2. 依存関係のインストール</h2>
<p>さて、退屈な定型文の仕事は十分です。いよいよTiptapをインストールしましょう！次の例では、 <code>alpinejs</code>、<code>@tiptap/core</code> パッケージ、および最も一般的な拡張機能を備えた  <code>@tiptap/starter-kit</code> が必要です。</p>

<pre><code class="language-bash">npm install alpinejs @tiptap/core @tiptap/starter-kit
</code></pre>

<p>手順1 を実行した場合は、<code>npm run dev</code> を使用してプロジェクトを開始し、お気に入りのブラウザで <a href="http://localhost:3000">http://localhost:3000</a> を開くことができます。既存のプロジェクトで作業している場合、これは異なる場合があります。</p>
<h2>3.エディターの初期化</h2>
<p>Tiptap の使用を実際に開始するには、JavaScript を少し作成する必要があります。次のサンプルコードを <code>main.js</code> というファイルに入れましょう。</p>
<p>これは、Tiptap を Alpine.js で起動して実行するための最速の方法です。それはあなたにTiptap の非常に基本的なバージョンを与えるでしょう。心配はいりません。まもなく機能を追加できるようになります。</p>


<pre><code class="language-js">
window.setupEditor = function(content) {
  return {
    editor: null,
    content: content,
    updatedAt: Date.now(), // force Alpine to rerender on selection change
    init(element) {
      this.editor = new Editor({
        element: element,
        extensions: [
          StarterKit,
        ],
        content: this.content,
        onUpdate: ({ editor }) =&gt; {
          this.content = editor.getHTML()
        },
        onSelectionUpdate: () =&gt; {
          this.updatedAt = Date.now()
        },
      })
    },
  }
}

window.Alpine = Alpine
Alpine.start()
</code></pre>
<h2>4.アプリに追加</h2>
<p>それでは、<code>index.html</code>　のコンテンツを次のサンプルコードに置き換えて、アプリでエディターを使用してみましょう。</p>

<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div x-data=&quot;setupEditor('&lt;p&gt;Hello World! :-)&lt;/p&gt;')&quot; x-init=&quot;() =&gt; init($refs.element)&quot;&gt;

    &lt;template x-if=&quot;editor&quot;&gt;
      &lt;div class=&quot;menu&quot;&gt;
        &lt;button
          @click=&quot;editor.chain().toggleHeading({ level: 1 }).focus().run()&quot;
          :class=&quot;{ 'is-active': editor.isActive('heading', { level: 1 }) }&quot;
        &gt;
          H1
        &lt;/button&gt;
        &lt;button
          @click=&quot;editor.chain().toggleBold().focus().run()&quot;
          :class=&quot;{ 'is-active': editor.isActive('bold') }&quot;
        &gt;
          Bold
        &lt;/button&gt;
        &lt;button
          @click=&quot;editor.chain().toggleItalic().focus().run()&quot;
          :class=&quot;{ 'is-active': editor.isActive('italic') }&quot;
        &gt;
          Italic
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;

    &lt;div x-ref=&quot;element&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;

  &lt;style&gt;
    body { margin: 2rem; font-family: sans-serif; }
    button.is-active { background: black; color: white; }
    .ProseMirror { padding: 0.5rem 1rem; margin: 1rem 0; border: 1px solid #ccc; }
  &lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>これで、ブラウザに Tiptap が表示されます。背中を軽くたたく時間です！ :)</p>
<h1>PHP</h1>
<h2>はじめに</h2>

<p>Tiptap は、Laravel、Livewire、Inertia.js、<a href="/installation/alpine">Alpine.js</a>、<a href="/guide/styling#with-tailwind-css">Tailwind CSS</a> で使用できます。もちろん、ライセンスもお読みください。</p>
<h2>PHPのヒント</h2>
<p><a href="/api/utilities/tiptap-php">Tiptap コンテンツを処理するための公式PHPパッケージ</a> を提供しています。Tiptap コンテンツを処理するためのPHPパッケージ。 Tiptap 互換の JSON を HTML に変換したり、その逆を行ったり、コンテンツをサニタイズしたり、単に変更したりすることができます。</p>

<h2>Laravel Livewire</h2>
<h3>my-livewire-component.blade.php</h3>
<pre><code class="language-html">&lt;!--
  In your livewire component you could add an
  autosave method to handle saving the content
  from the editor every 10 seconds if you wanted
--&gt;
&lt;x-editor
  wire:model=&quot;foo&quot;
  wire:poll.10000ms=&quot;autosave&quot;
&gt;&lt;/x-editor&gt;
</code></pre>
<h3>editor.blade.php</h3>
<pre><code class="language-html">&lt;div
  x-data=&quot;setupEditor(
    $wire.entangle('{{ $attributes-&gt;wire('model') }}').defer
  )&quot;
  x-init=&quot;() =&gt; init($refs.editor)&quot;
  wire:ignore
  {{ $attributes-&gt;whereDoesntStartWith('wire:model') }}
&gt;
  &lt;div x-ref=&quot;editor&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3>index.js</h3>
<pre><code class="language-js">
window.setupEditor = function (content) {
  return {
    editor: null,
    content: content,

    init(element) {
      this.editor = new Editor({
        element: element,
        extensions: [
          StarterKit,
        ],
        content: this.content,
        onUpdate: ({ editor }) =&gt; {
          this.content = editor.getHTML()
        }
      })

      this.$watch('content', (content) =&gt; {
        // If the new content matches TipTap's then we just skip.
        if (content === this.editor.getHTML()) return

        /*
          Otherwise, it means that a force external to TipTap
          is modifying the data on this Alpine component,
          which could be Livewire itself.
          In this case, we just need to update TipTap's
          content and we're good to do.
          For more information on the `setContent()` method, see:
            https://www.tiptap.dev/api/commands/set-content
        */
        this.editor.commands.setContent(content, false)
      })
    }
  }
}
</code></pre>
<h1>アップグレードガイド</h1>
<h2>はじめに</h2>


<p>まず、Tiptap v1 はサポートされなくなり、それ以上のアップデートは受信されなくなります。</p>
<p>お気に入りのテキストエディタを新しいAPIにアップグレードするのは面倒な作業ですが、最新バージョンにアップグレードする十分な理由があることを確認しました。</p>

<ul>
<li>IDEでのオートコンプリート（TypeScriptのおかげで）</li>
<li>100以上のページと100以上のインタラクティブな例を含むすばらしいドキュメント</li>
<li>活発な開発、作成中の新機能、毎週の新リリース</li>
<li>たくさんの新しい拡張機能</li>
<li>十分にテストされたコードベース</li>
</ul>

<p>新しい API は見覚えがありますが、多くの変更があります。アップグレードを少し簡単にするために、知っておく必要のあるすべてがここにあります。</p>
<h2>Tiptap v1をアンインストールします</h2>


<p>パッケージ構造全体が変更され、別の npm 名前空間に移動したため、Tiptap 2 にアップグレードする前に古いバージョンを完全に削除する必要があります。</p>
<p>そうしないと「 &quot;looks like multiple versions of prosemirror-model were loaded&quot; (複数のバージョンのprosemirror-model がロードされたように見えます) 」などの例外が発生します。</p>
<pre><code class="language-bash">npm uninstall tiptap tiptap-commands tiptap-extensions tiptap-utils
</code></pre>
<h2>Tiptap v2 をインストールします</h2>

<p>古いバージョンの Tiptap をアンインストールしたら、新しい Vue2 パッケージとスターターキットをインストールします。</p>
<pre><code class="language-bash">npm install @tiptap/vue-2 @tiptap/starter-kit
</code></pre>
<h2>Tiptap v2 を最新の状態に保つ</h2>
<p>Tiptapのアップデートを常にリリースしています。</p>

<p>残念ながら、npm には依存関係を簡単に更新する統合ツールはありませんが、<code>npm-check</code> パッケージを使用できます。</p>

<pre><code class="language-bash">npm install -g npm-check
npm-check -u
</code></pre>
<h2>ドキュメント、テキスト、段落の拡張子を明示的に登録する</h2>
<p>tiptap v1 は、デフォルト設定の <code>useBuiltInExtensions: true</code> を使用して、いくつかの必要な拡張機能を非表示にしようとしました。その設定は削除されており、すべての拡張機能をインポートする必要があります。少なくとも <a href="/api/nodes/document"><code>Document</code></a> 、<a href="/api/nodes/paragraph"><code>Paragraph</code></a> と <a href="/api/nodes/text"><code>Text</code></a> 拡張子を明示的にインポートしてください。</p>

<p>そして、<code>dropCursor</code>、<code> enableDropCursor</code>、および<code>enableGapCursor</code>等、いくつかの設定を削除しました。 これらは現在、別々の拡張機能となっています（ <a href="/api/extends/dropcursor"><code>Dropcursor</code></a> と <a href="/api/extends/gapcursor"><code>Gapcursor</code></a>）。 通常は、それらをロードして使用できますが、この機能がいらない場合は、無視していただいて結構です。</p>
<h2>拡張機能の新しい名前</h2>
<p>lowerCamelCase に切り替えたため、多くのタイプ名が変更されました。 コンテンツを JSON として保存した場合は、コンテンツをループして名前を変更する必要があります。 すみません。</p>

<table>
<thead>
<tr>
<th>古い名前</th>
<th>新しい名前</th>
</tr>
</thead>
<tbody>
<tr>
<td><del><code>bullet_list</code></del></td>
<td><code>bulletList</code></td>
</tr>
<tr>
<td><del><code>code_block</code></del></td>
<td><code>codeBlock</code></td>
</tr>
<tr>
<td><del><code>hard_break</code></del></td>
<td><code>hardBreak</code></td>
</tr>
<tr>
<td><del><code>horizontal_rule</code></del></td>
<td><code>horizontalRule</code></td>
</tr>
<tr>
<td><del><code>list_item</code></del></td>
<td><code>listItem</code></td>
</tr>
<tr>
<td><del><code>ordered_list</code></del></td>
<td><code>orderedList</code></td>
</tr>
<tr>
<td><del><code>table_cell</code></del></td>
<td><code>tableCell</code></td>
</tr>
<tr>
<td><del><code>table_header</code></del></td>
<td><code>tableHeader</code></td>
</tr>
<tr>
<td><del><code>table_row</code></del></td>
<td><code>tableRow</code></td>
</tr>
<tr>
<td><del><code>todo_list</code></del></td>
<td><code>taskList</code> (new name!)</td>
</tr>
<tr>
<td><del><code>todo_item</code></del></td>
<td><code>taskItem</code> (new name!)</td>
</tr>
</tbody>
</table>
<h2>削除されたメソッド</h2>
<p><code>state()</code> メソッドを削除しました。 心配はいりませんが、<code>editor.state</code> から引き続き利用できます。</p>

<h2>新しい拡張 API</h2>
<p>プロジェクト用にいくつかのカスタム拡張機能を構築した場合は、新しいAPIに合うようにそれらを書き直す必要があります。 心配はいりませんが、多くの作業を続けることができます。 <code>schema</code>、<code>commands</code>、<code>keys</code>、<code> inputRules</code>、および  <code>pasteRules</code> はすべて、以前と同じように機能します。 登録方法が違うだけです。</p>

<pre><code class="language-js">
const CustomExtension = Node.create({
  name: 'custom_extension',
  addOptions() {
    …
  },
  addAttributes() {
    …
  },
  parseHTML() {
    …
  },
  renderHTML({ node, HTMLAttributes }) {
    …
  },
  addCommands() {
    …
  },
  addKeyboardShortcuts() {
    …
  },
  addInputRules() {
    …
  },
  // and more …
})
</code></pre>

<p>ガイドで <a href="/guide/custom-extensions">カスタム拡張機能を構築するためのすべての気の利いた詳細</a> の詳細をお読みください。</p>
<h2>名前を変更した設定とメソッド</h2>
<p><a href="/api/editor">多くの設定とメソッドの名前を変更しました</a>。 うまくいけば、検索と置換を使用して新しい API に移行できます。 変更点のリストは次のとおりです。</p>

<table>
<thead>
<tr>
<th>古い名前</th>
<th>新しい名前</th>
</tr>
</thead>
<tbody>
<tr>
<td><del><code>autoFocus</code></del></td>
<td><code>autofocus</code></td>
</tr>
</tbody>
</table>
<h2>コマンドの名前を変更</h2>
<p>すべての新しい拡張機能には、スタイルを設定、設定解除、および切り替えるための特定のコマンドが付属しています。 したがって、<code>.bold()</code> の代わりに、<code>.toggleBold()</code> になりました。 また、lowerCamelCase に切り替えました。以下にいくつかの例を示します。 あぁ、<code>todo_list</code> の名前を <code>taskList</code> に変更しました。申し訳ありません。</p>

<table>
<thead>
<tr>
<th>古いコマンド</th>
<th>新しいコマンド</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.redo()</code></td>
<td><code>.redo()</code> (nothing changed)</td>
</tr>
<tr>
<td><code>.undo()</code></td>
<td><code>.undo()</code> (nothing changed)</td>
</tr>
<tr>
<td><del><code>.todo_list()</code></del></td>
<td><code>.toggleTaskList()</code> (new name!)</td>
</tr>
<tr>
<td><del><code>.blockquote()</code></del></td>
<td><code>.toggleBlockquote()</code></td>
</tr>
<tr>
<td><del><code>.bold()</code></del></td>
<td><code>.toggleBold()</code></td>
</tr>
<tr>
<td><del><code>.bullet_list()</code></del></td>
<td><code>.toggleBulletList()</code></td>
</tr>
<tr>
<td><del><code>.code()</code></del></td>
<td><code>.toggleCode()</code></td>
</tr>
<tr>
<td><del><code>.code_block()</code></del></td>
<td><code>.toggleCodeBlock()</code></td>
</tr>
<tr>
<td><del><code>.hard_break()</code></del></td>
<td><code>.setHardBreak()</code></td>
</tr>
<tr>
<td><del><code>.heading()</code></del></td>
<td><code>.toggleHeading()</code></td>
</tr>
<tr>
<td><del><code>.horizontal_rule()</code></del></td>
<td><code>.setHorizontalRule()</code></td>
</tr>
<tr>
<td><del><code>.italic()</code></del></td>
<td><code>.toggleItalic()</code></td>
</tr>
<tr>
<td><del><code>.link()</code></del></td>
<td><code>.toggleLink()</code></td>
</tr>
<tr>
<td><del><code>.ordered_list()</code></del></td>
<td><code>.toggleOrderedList()</code></td>
</tr>
<tr>
<td><del><code>.paragraph()</code></del></td>
<td><code>.setParagraph()</code></td>
</tr>
<tr>
<td><del><code>.strike()</code></del></td>
<td><code>.toggleStrike()</code></td>
</tr>
<tr>
<td><del><code>.underline()</code></del></td>
<td><code>.toggleUnderline()</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<h2>メニューバー、バブルメニューバー、フローティングメニュー</h2>

<p>専用の <a href="/guide/menus">メニュー作成ガイド</a> を読んで、メニューを移行してください。</p>
<h2>コマンドをチェーンできるようになりました</h2>
<p>現在、ほとんどのコマンドを1つの呼び出しに組み合わせることができます。 ほとんどの場合、これは個別の関数呼び出しよりも短くなります。 選択したテキストを太字にする例を次に示します。</p>

<pre><code class="language-js">editor.chain().toggleBold().focus().run()
</code></pre>

<p>新しいチェーンを開始するには <code>.chain()</code> が必要であり、その間のすべてのコマンドを実際に実行するには <code>.run()</code> が必要です。 <a href="/api/commands">新しいTiptapコマンド</a> の詳細については、API ドキュメントをご覧ください。</p>
<h2>.focus() はすべてのコマンドで呼び出されません</h2>
<p>Tiptap v1 で <code>.focus()</code> コマンドを非表示にしようとし、すべてのコマンドでそれを実行しました。 これにより、特定のユースケースで問題が発生しました。コマンドを実行したいが、エディターに焦点を合わせたくない場合です。</p>
<p>Tiptap v2 では、明示的に <code>focus()</code> を呼び出す必要があり、おそらく多くの場所でそれを実行したいと思うでしょう。 次に例を示します。</p>


<pre><code class="language-js">editor.chain().focus().toggleBold().run()
</code></pre>
<h2>イベントコールバックのパラメータは少なくなります</h2>
<p>新しいイベントコールバックには、より少ないパラメーターがあります。 同じことが <code>this.</code> から利用できるようになりました。 <a href="/api/events">イベントの詳細については、こちらをご覧ください。</a></p>

<h2>協調編集</h2>
<p>協調編集のリファレンス実装では、現在 Y.js を使用しています。 それはまったく別のことです。 Tiptap 1 拡張機能は引き続き使用できますが、新しい拡張機能 API に適合させるかどうかはユーザー次第です。 これを行った場合は、ここからリンクできるように、忘れずに共有してください。</p>


<p>ガイドで <a href="/guide/collaborative-editing">新しい協調編集体験</a> の詳細をご覧ください。</p>
<h2>マークはノードビューをサポートしなくなりました</h2>

<p>マークの場合、ノードビューは <a href="https://discuss.prosemirror.net/t/there-is-a-bug-in-marks-nodeview/2722/2">ProseMirrorでは十分にサポートされていません</a>  Tiptap 1には <a href="https://github.com/ueberdosis/tiptap/issues/613">関連する問題</a>もあります。そのため、Tiptap 2 で削除しました。</p>
<h2>スポンサーになる</h2>


<p>Tiptapは、コミュニティの資金がなければ存在しませんでした。 Tiptap に恋をした場合は、 <a href="/sponsor">become a sponsor</a> を忘れずに、メンテナンス、開発、サポートを持続可能なものにしてください。</p>
<p>引き換えに、私たちはあなたを私たちの心に連れて行き、あなたをプライベートリポジトリに招待し、あなたの問題に「スポンサー♥」ラベルを追加し、リクエストをプルします。</p>
<h1>変更ログ</h1>

<p>Tiptapは50を超える個別のパッケージで構成されているため、その1つの大きな変更ログを保持するのはそれほど簡単ではありません。 しかし、私たちはあなたをカバーしてもらいました。 ベータ段階で開発をフォローするために必要なものはすべて次のとおりです。</p>
<ol>
<li>
<a href="https://github.com/ueberdosis/tiptap/blob/main/packages/core/CHANGELOG.md">コアパッケージの変更ログ</a> はGitHub のここにあります。</li>
<li>すべてのパッケージには <a href="https://github.com/ueberdosis/tiptap/blob/main/packages">個別の<code>CHANGELOG.md</code></a> もあります。</li>
<li>ベータ期間中は、<a href="https://github.com/ueberdosis/tiptap/pulls?q=is%3Apr+is%3Aclosed">GitHubでマージされたプルリクエスト</a> を監視することも役立ちます。</li>
<li>そして、公開された issue で<a href="https://github.com/ueberdosis/tiptap/issues/2087">安定したリリースの前に何をしたいのか</a>  を追跡します。.</li>
</ol>

<p>安定版に移行したら、大きな変更について<a href="/blog">ブログ投稿を作成</a>、ここで変更ログに保存します。</p>
<h1>プロジェクトについて</h1>
<h2>はじめに</h2>

<p>一流の開発者エクスペリエンスとユーザーエクスペリエンスを提供するために、私たちは <del>数百</del> 数千時間の無給の仕事を Tiptap に投入しました。あなたの資金は、私たちがこの仕事をますます財政的に持続可能なものにするのに役立ちます。これにより、役立つサポートを提供し、すべてのパッケージを維持し、すべてを最新の状態に保ち、Tiptap の新しい機能と拡張機能を開発することができます。</p>
<p>オープンソースコミュニティに戻って、 <a href="https://github.com/sponsors/ueberdosis">GitHubでスポンサーになってください</a>! ♥</p>
<h2>スポンサーとしてのあなたのメリット💖</h2>

<ul>
<li>プライベートリポジトリへの早期アクセスを取得する</li>
<li>あなたの問題とプルリクエストは <code>スポンサー♥</code> ラベルを取得します</li>
<li>GitHub へのすべてのコメントでスポンサーバッジを取得する</li>
<li>Tiptap の未来に投資する</li>
<li>オープンソースコミュニティに還元する</li>
<li>GitHub プロファイルでサポートを表示する</li>
</ul>
<p>良くない? <a href="https://github.com/sponsors/ueberdosis">GitHubでスポンサーになろうよ!</a></p>
<h2>The maintainers of Tiptap</h2>


<p>Tiptap を使用して「素晴らしい！」と思ってくれたら、この Tiptap を作っている会社 <a href="https://ueberdosis.io">überdosis</a> の素敵な人々に感謝を述べてくれると嬉しいです。</p>
<p>そして、あなたが私たちにあなたのために素晴らしいデジタル製品を設計して構築したいのなら、あなたは間違いなく私たちを雇うべきです。どういうわけかテキスト編集に関連している場合はボーナスポイント。</p>
<p>!!チームグリッド</p>
<h2>より安心</h2>

<p>Tiptap 使用して利益をあげている企業は、おそらくある程度の安定を望んでおり、Tiptap を維持し続けることを保証しますが、私たちの仕事は、間違いなく後援する必要がある他の素敵な人々の仕事に基づいていることを忘れないでください。</p>
<ul>
<li>
<a href="https://marijnhaverbeke.nl/fund/">Sponsor Marijn Haverbeke</a> (ProseMirror)</li>
<li>
<a href="https://github.com/sponsors/dmonad">Sponsor Kevin Jahns</a> (Y.js)</li>
<li>
<a href="https://opencollective.com/y-collective">Sponsor Y-Collective</a> (Y.js + Tiptap)</li>
</ul>
<h2>よくある質問</h2>
<h3>GitHubを使用できません。どうすればあなたをサポートできますか？</h3>
<p>会社の場合、GitHubを使用したくない、クレジットカードを持っていない、または適切な請求書が必要な場合は、<a href="mailto:humans@tiptap">humans@tiptap.dev</a> までご連絡ください。</p>


<p>私たちは、Y.js（すべての協調編集の魔法に使用しているテクノロジー）に関連するプロジェクトの基金である<a href="https://opencollective.com/y-collective">Y-Collective</a> の一部です。これは OpenCollective であり、送金、PayPal、またはクレジットカードで送金できます。米国企業の寄付は税控除の対象となります。</p>
<h3>相談したいです。価格はいくらくらいですか？</h3>
<p>問題や質問がある場合、何かを話したい場合、または何か他のことをしたい場合は、<a href="https://github.com/ueberdosis/tiptap/issues/new/choose">GitHubの問題を使用してください</a> すべてにアクセスできるようにしてくださいコミュニティ。それ以外の場合は、<a href="mailto:humans@tiptap.dev">humans@tiptap.dev</a> に連絡してください。限られた数のカスタム開発およびコンサルティング契約を引き受けることができます。</p>

<h3>電話してもらえますか？</h3>
<p>いいえ、私たちは非同期通信の大ファンです。本当に非公開で連絡する必要がある場合は、<a href="mailto:humans@tiptap.dev">humans@tiptap.dev</a> にメールを送信してください。ただし、技術的なメールサポートは期待しないでください。それはすべて<a href="https://github.com/ueberdosis/tiptap/issues">GitHub</a> で発生します</p>

<h1>貢献</h1>
<h2>はじめに</h2>

<p>活気のあるコミュニティがなければ、tiptapは何もありません。貢献はこれまでも、そしてこれからも歓迎されます。投稿を送信する前に、知っておくべきことが少しあります。</p>
<h2>歓迎すべき例</h2>




<ul>
<li>バグレポートとしての回帰テストの失敗</li>
<li>ドキュメントの改善。例えば、タイプミスを修正し、セクションを追加する</li>
<li>既存の拡張機能の新機能。 例えば、新しい構成可能なオプション</li>
<li>よく説明された、コアへの非破壊的な変更</li>
</ul>
<h2>マージされません</h2>

<ul>
<li>新しい拡張機能。サポートと保守が必要です。</li>
</ul>
<h2>アイデアを送信する</h2>
<p>必ず問題を開いて、最初にアイデアの概要を説明してください。すぐにご連絡いたします。寄付を統合できる可能性がある場合はお知らせします。</p>

<h2>開発環境をセットアップする</h2>
<p>公式リポジトリをいじくり回すのはそれほど難しくありません。 <a href="https://github.com/git-guides/install-git">Git</a>、<a href="https://nodejs.org/en/download/">Node and NPM</a> をインストールする必要があります。次に行う必要があることは次のとおりです。</p>

<ol>
<li>コードをローカルマシンにコピーします <code>$ git clone git@github.com:ueberdosis/tiptap.git</code>
</li>
<li>依存関係をインストールします <code>$ npm install</code>
</li>
<li>開発環境を開始します <code>$ npm run start</code>
</li>
<li>お気に入りのブラウザで <a href="http://localhost:3000">http://localhost:3000</a> を開きます</li>
<li>遊び始めましょう！</li>
</ol>
<h2>コードスタイル</h2>
<p>一貫したコードスタイルを保証する eslint 構成があります。エラーをチェックするには、 <code>$ npm run lint</code> を実行します。プルリクエストを送信するときにもチェックされます。プルリクエストを送信する前に、パスしていることを確認してください。</p>

<h2>エラーのテスト</h2>
<p>プルリクエストは、既存のすべてのテストを自動的に実行します。プルリクエストを送信する前に、すべてパスしていることを確認してください。<code>$ npm run test</code>を使用してすべてのテストをローカルで実行するか、<code>$ npm run test:open</code>を使用して単一のテストを実行します（新しいテストを作成する場合など）。</p>

<h2>その他の質問</h2>
<p>さらに質問がありますか？リポジトリに新しい問題またはディスカッションを作成します。折り返しご連絡いたします。</p>

<h1>仕事</h1>

<p>Tiptap での作業を楽しんでいますか？ あなた一人じゃありません。 一部の素晴らしい企業は、Tiptap や <a href="https://hocuspocus.dev">Hocuspocus</a> の経験を持つ開発者を探しています。</p>
<ul>
<li>
<p><strong><a href="https://gamma.app/docs/Software-Engineer-6s0e0grm9zk9w5s">Software Engineer</a> @ Gamma</strong>
React · Tiptap · San Francisco, USA</p>
</li>
<li>
<p><strong><a href="https://dociq.notion.site/Senior-Fullstack-Engineer-e6336ba6e9864c89858c70eea81e5691">Senior Fullstack Engineer</a> @ Contract Vault</strong>
Vue.js · Tiptap · Node.js · PostgreSQL · Remote, Switzerland</p>
</li>
<li>
<p><strong><a href="https://dociq.notion.site/Senior-Frontend-Engineer-0926648fac544a6b870a0024f2861c12">Senior Frontend Engineer</a> @ Contract Vault</strong>
Vue.js · Tiptap · Remote, Switzerland</p>
</li>
<li>
<p><strong><a href="https://outstanding-ulna-0e8.notion.site/Sigle-Experienced-Front-end-engineer-f8b1bab84afd4c89a2053c6685c317e0">Experienced Front-end Engineer</a> @ Sigle</strong>
React · Tiptap · web 3.0 · Remote</p>
</li>
<li>
<p><strong><a href="https://typecell.notion.site/Prosemirror-TipTap-developer-47c9c12213964b148bc74ea540ba830c">Editor Front-end Engineer</a> @ TypeCell</strong>
Open Source · Tiptap · ProseMirror · React · Remote</p>
</li>
<li>
<p><strong><a href="https://birdeatsbug.com/jobs/?source=tiptapdev">Javascript Engineer, Software Engineer, …</a> @ Bird Eats Bug</strong>
Vue.js · Tiptap · Remote · Berlin, Germany</p>
</li>
<li>
<p><strong><a href="https://bitcrowd.net/jobs">Frontend Developer</a> @ bitcrowd</strong>
Tiptap · Remote · Berlin, Germany</p>
</li>
<li>
<p><strong><a href="https://nextapphq.notion.site/nextapphq/Frontend-Developer-Prosemirror-244ccf55ca7248489aaea052be32cd36">Frontend Developer</a> @ NEXT</strong>
React · Remirror · Remote · Amsterdam, Netherlands</p>
</li>
</ul>

<p>あなたの会社も採用していますか？ Tiptap を使用するのが大好きな人から、<a href="https://plausible.io/tiptap.dev?period=30d">200,000ページビュー/月</a> があります。 たぶん私たちはあなたが適切な人を見つけるのを手伝うことができます。 職務内容へのリンクを添えて<a href="mailto:humans@tiptap.dev">humans@tiptap.dev</a> に連絡してください。</p>
<h1>デフォルトのテキストエディタ</h1>
<p>エディターのレンダリングを完全に制御できることをお伝えしましたか？ これは、スタイリングがないが、一般的な拡張機能のセット全体が詰め込まれた最低限の例です。</p>

<p><a href="https://embed.tiptap.dev/preview/Examples/Default">https://embed.tiptap.dev/preview/Examples/Default</a></p>
<h1>コラボ編集</h1>
<h2>はじめに</h2>


<p>この例は、Tiptap を使用して、複数のユーザーが同じドキュメントでリアルタイムに共同作業できるようにする方法を示しています。</p>
<p>すべてのクライアントを WebSocket サーバーに接続し、<a href="https://github.com/yjs/yjs">Y.js</a> の機能を使用してドキュメントへの変更をマージします。協調編集について詳しく知りたい場合は、<a href="/guide/collaborative-editing">協調編集に関するガイド</a> をご覧ください。</p>
<h2>例</h2>
<blockquote>
<p><strong>警告共有ドキュメント</strong>
いいね！このエディタのコンテンツは、インターネットの他のユーザーと共有されます。</p>
</blockquote>

<p><a href="https://embed.tiptap.dev/preview/Examples/CollaborativeEditing">https://embed.tiptap.dev/preview/Examples/CollaborativeEditing</a></p>
<h2>バックエンド</h2>

<p>:::warning Request early access
Our plug &amp; play collaboration backend hocuspocus is still work in progress. If you want to give it a try, <a href="https://www.hocuspocus.dev">get early access</a>.
:::</p>
<p>これを実現するためにサーバーにどのような種類のソーサリーが必要か疑問に思われる場合は、デモのバックエンドコード全体を次に示します。</p>
<blockquote>
<p>警告早期アクセスをリクエストする
プラグアンドプレイコラボレーションバックエンド hocuspocus はまだ進行中です。 試してみたい場合は、<a href="https://www.hocuspocus.dev">早期アクセスを取得</a> してください。</p>
</blockquote>
<pre><code class="language-js">
const server = Server.configure({
  port: 80,
  extensions: [
    new RocksDB({ path: './database' }),
  ],
})

server.listen()
</code></pre>
<h1>マークダウンショートカット</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/MarkdownShortcuts">https://embed.tiptap.dev/preview/Examples/MarkdownShortcuts</a></p>
<h1>メニュー</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Menus">https://embed.tiptap.dev/preview/Examples/Menus</a></p>
<h1>テーブル</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Tables">https://embed.tiptap.dev/preview/Examples/Tables</a></p>
<h1>画像</h1>
<h2>pro … はどうですか</h2>
<p>サイズ変更可能な画像、キャプション付きの画像、フローティング画像など、画像に関連する機能をさらに構築したいと考えています。ただし、それには時間がかかります。</p>
<p>何千人もの開発者が毎日 Tiptap を使用していますが、それでも私たちのフルタイムの仕事ではありません。 それを変えたいのです。 あなたは私たちが私たちの目標を達成するのを手伝うことができますか？</p>


<p><a href="https://github.com/sponsors/ueberdosis">GitHub でスポンサーになる →</a></p>
<p><a href="https://embed.tiptap.dev/preview/Examples/Images">https://embed.tiptap.dev/preview/Examples/Images</a></p>
<h1>フォーマット</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Formatting">https://embed.tiptap.dev/preview/Examples/Formatting</a></p>
<h1>タスク</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Tasks">https://embed.tiptap.dev/preview/Examples/Tasks</a></p>
<h1>長文テキスト</h1>

<p>このデモには 200,000 語以上あります。パフォーマンスを自分で確認してください。</p>
<p><a href="https://embed.tiptap.dev/preview/Examples/Book">https://embed.tiptap.dev/preview/Examples/Book</a></p>
<h1>ドローイング</h1>

<p>テキストエディタで描きたいと思ったことはありますか？ Tiptap では以下のようにテキストエディタを使用してドロー機能を利用できます。 そのようなものを構築したい場合は、<a href="/guide/node-views">ノードビューの詳細</a> をご覧ください。</p>
<p><a href="https://embed.tiptap.dev/preview/Examples/Drawing">https://embed.tiptap.dev/preview/Examples/Drawing</a></p>
<h1>メンション</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Community">https://embed.tiptap.dev/preview/Examples/Community</a></p>
<h1>最小限のセットアップ</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Minimal">https://embed.tiptap.dev/preview/Examples/Minimal</a></p>
<h1>カスタム ドキュメント</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/CustomDocument">https://embed.tiptap.dev/preview/Examples/CustomDocument</a></p>
<h1>賢いエディター</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/Savvy">https://embed.tiptap.dev/preview/Examples/Savvy</a></p>
<h1>双方向性</h1>

<p><a href="/guide/node-views">ノードビュー</a> のおかげで、ノードに双方向性を追加できます。 JavaScript で記述できる場合は、エディターに追加できます。</p>
<p><a href="https://embed.tiptap.dev/preview/Examples/InteractivityComponent">https://embed.tiptap.dev/preview/Examples/InteractivityComponent</a></p>
<p><a href="https://embed.tiptap.dev/preview/Examples/InteractivityComponentContent">https://embed.tiptap.dev/preview/Examples/InteractivityComponentContent</a></p>
<h1>シンタックス ハイライト</h1>
<p><a href="https://embed.tiptap.dev/preview/Examples/CodeBlockLanguage">https://embed.tiptap.dev/preview/Examples/CodeBlockLanguage</a></p>
<h1>構成</h1>
<h2>はじめに</h2>


<p>ほとんどの場合、Tiptap をレンダリングする場所（<code>element</code>）、有効にする機能（<code>extensions</code>）、最初のドキュメントを指定するだけで十分です（<code>content</code>）。</p>
<p>ただし、さらにいくつか設定することができます。完全に構成されたエディターの例を見てみましょう。</p>
<h2>エディターを構成する</h2>
<p>構成を追加するには、次に示すように、<a href="/api/editor">設定のあるオブジェクト</a> を <code>Editor</code>クラスに渡します。</p>

<pre><code class="language-js">
new Editor({
  element: document.querySelector('.element'),
  extensions: [
    Document,
    Paragraph,
    Text,
  ],
  content: '&lt;p&gt;Example Text&lt;/p&gt;',
  autofocus: true,
  editable: true,
  injectCSS: false,
})
</code></pre>

<ol>
<li>bind Tiptap to <code>.element</code>,</li>
<li>load the <code>Document</code>, <code>Paragraph</code> and <code>Text</code> extensions,</li>
<li>set the initial content,</li>
<li>place the cursor in the editor after initialization,</li>
<li>make the text editable (but that’s the default anyway), and</li>
<li>disable the loading of <a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core/src/style.ts">the default CSS</a> (which is not much anyway).</li>
</ol>
<p>これにより、次のことが行われます。</p>
<ol>
<li>Tiptap を <code>.element</code> にバインドします。</li>
<li>
<code>Document</code>、<code>Paragraph</code>、および <code>Text</code> 拡張機能をロードします。</li>
<li>初期コンテンツを設定します。</li>
<li>初期化後、カーソルをエディタに置きます。</li>
<li>テキストを編集可能にし（ただし、とにかくそれがデフォルトです）。</li>
<li>
<a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core/src/style.ts">デフォルトのCSS</a> の読み込みを無効にします（とにかくそれほど多くはありません）。</li>
</ol>
<h2>ノード、マーク、拡張機能</h2>
<p>ほとんどの編集機能は、<a href="/api/nodes">node</a>、<a href="/api/marks">mark</a>、または <a href="/api/extensions">extension</a> としてバンドルされています。必要なものをインポートし、それらを配列としてエディターに渡します。</p>
<p>これは、3つの拡張機能のみを使用した最小限のセットアップです。</p>


<pre><code class="language-js">
new Editor({
  element: document.querySelector('.element'),
  extensions: [
    Document,
    Paragraph,
    Text,
  ],
})
</code></pre>
<h3>拡張機能を構成する</h3>
<p>ほとんどの拡張機能を構成できます。<code>.configure()</code> を追加し、それにオブジェクトを渡します。</p>
<p>次の例では、デフォルトの見出しレベル4、5、および6を無効にし、1、2、および 3のみを許可します。</p>


<pre><code class="language-js">
new Editor({
  element: document.querySelector('.element'),
  extensions: [
    Document,
    Paragraph,
    Text,
    Heading.configure({
      levels: [1, 2, 3],
    }),
  ],
})
</code></pre>

<p>それらの設定の詳細については、使用している拡張機能のドキュメントを参照してください。</p>
<h3>デフォルトの拡張機能</h3>
<p>最も一般的な拡張機能のいくつかを<code>StarterKit</code> 拡張機能にバンドルしました。これを使用する方法は次のとおりです。</p>

<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit,
  ],
})
</code></pre>

<p>含まれているすべての拡張機能の構成をオブジェクトとして渡すこともできます。構成の前に拡張子名を付けるだけです。</p>
<pre><code class="language-js">
new Editor({
  extensions: StarterKit.configure({
    heading: {
      levels: [1, 2, 3],
    },
  }),
})
</code></pre>

<p><code>StarterKit</code> 拡張機能は最も一般的な拡張機能をロードしますが、利用可能なすべての拡張機能をロードするわけではありません。追加の拡張機能をロードしたり、カスタム拡張機能を追加したりする場合は、それらを <code>extensions</code> 配列に追加します。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit,
    Strike,
  ],
})
</code></pre>

<p><code>StarterKit</code> から特定の拡張機能をロードしたくないですか？設定に <code>false</code> を渡すだけです。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit.configure({
      history: false,
    }),
  ],
})
</code></pre>

<p>協調編集の例では、おそらくそのようなものが見られるでしょう。 <a href="/api/extensions/collaboration"><code>Collaboration</code></a> には、独自の履歴拡張機能が付属しています。競合を避けるために、デフォルトの<a href="/api/extensions/history"><code>History</code></a> 拡張機能を削除または無効にする必要があります。</p>
<h1>メニューの作成する</h1>
<h2>はじめに</h2>
<p>Tiptap は非常に生々しいものですが、それは良いことです。あなたはそれの外観について完全に制御できます。</p>
<p>フルコントロールとは、それを意味します。自分でメニューを作成することができます（そして作成する必要があります）。私たちはあなたがすべてを配線するのを手伝います。</p>


<h2>メニュー</h2>
<p>エディターは、コマンドをトリガーしてアクティブ状態を追加するための流暢な API を提供します。好きなマークアップを使用できます。メニューの配置を簡単にするために、いくつかのユーティリティとコンポーネントを提供しています。最も一般的なユースケースを1つずつ見ていきましょう。</p>

<h3>固定メニュー</h3>
<p>たとえばエディタの上にある固定メニューは、何でもかまいません。そのようなメニューは提供していません。いくつかの <code>&lt;button&gt;</code> を含む <code>&lt;div&gt;</code> を追加するだけです。これらのボタンが<a href="/api/commands">コマンド</a> をトリガーする方法は、<a href="#actions">以下で説明(explained below)</a> です。</p>

<h3>バブルメニュー</h3>
<p>テキストを選択すると、<a href="/api/extensions/bubble-menu">バブルメニュー</a>  が表示されます。マークアップとスタイリングは完全にあなた次第です。</p>

<p><a href="https://embed.tiptap.dev/preview/Extensions/BubbleMenu?hideSource">https://embed.tiptap.dev/preview/Extensions/BubbleMenu?hideSource</a></p>
<h3>フローティングメニュー</h3>
<p><a href="/api/extensions/floating-menu">フローティングメニュー</a>  が空の行に表示されます。マークアップとスタイリングは完全にあなた次第です。</p>

<p><a href="https://embed.tiptap.dev/preview/Extensions/FloatingMenu?hideSource">https://embed.tiptap.dev/preview/Extensions/FloatingMenu?hideSource</a></p>
<h3>スラッシュコマンド（進行中の作業）</h3>
<p>これはまだ公式の拡張機能ではありませんが、<a href="/experiments/commands">スラッシュコマンドと呼ばれるものを追加するために使用できる実験があります</a> 。これにより、 <code>/</code> で新しい行を開始でき、追加するノードを選択するためのポップアップが表示されます。</p>

<h2>ボタン</h2>

<p>さて、あなたはあなたのメニューを持っています。しかし、どのように物事を配線しますか？</p>
<h3>コマンド</h3>

<p>エディターが既に実行されていて、最初のボタンを追加したいとします。クリックハンドラー付きの <code>&lt;button&gt;</code> HTML タグが必要です。設定によっては、次の例のようになります。</p>
<pre><code class="language-html">&lt;button onclick=&quot;editor.chain().focus().toggleBold().run()&quot;&gt;
  Bold
&lt;/button&gt;
</code></pre>

<p>少し長い命令でしたか？実際には、<a href="/api/commands#chain-commands">コマンドのチェーン</a> です。これを1つずつ見ていきましょう。</p>
<pre><code class="language-js">editor.chain().focus().toggleBold().run()
</code></pre>

<ol>
<li>
<code>editor</code> は Tiptap インスタンスである必要があります。</li>
<li>
<code>chain()</code> は 複数のコマンドを実行することをエディターに通知するために使用されます。</li>
<li>
<code>focus()</code> は フォーカスをエディターに戻します。</li>
<li>
<code>toggleBold()</code>は 選択したテキストを太字でマークします。すでに適用されている場合は、テキスト選択から太字のマークを削除します。</li>
<li>
<code>run()</code> は チェーンを実行します。</li>
</ol>
<p>言い換えると、これはテキストエディタの典型的な <strong>太字</strong> ボタンになります。</p>
<p>使用できるコマンドは、エディターに登録した拡張機能によって異なります。ほとんどの拡張機能には、 <code>set…()</code>、 <code>unset…()</code>、および <code>toggle…()</code>コマンドが付属しています。拡張機能のドキュメントを読んで、実際に利用できるものを確認するか、コードエディタのオートコンプリートを確認してください。</p>


<h3>フォーカスを維持</h3>
<p>上記の例では、すでに <code>focus()</code> コマンドを見てきました。ボタンをクリックすると、ブラウザはそのDOM要素にフォーカスを合わせ、エディタはフォーカスを失います。すべてのメニューボタンに <code>focus()</code> を追加して、ユーザーの書き込みフローが中断されないようにすることができます。</p>

<h3>アクティブ状態</h3>
<p>エディタには、選択したテキストに何かがすでに適用されているかどうかを確認するための <code>isActive()</code> メソッドが用意されています。 Vue.js では、次のような関数を使用して CSS クラスを切り替えることができます。</p>

<pre><code class="language-html">&lt;button :class=&quot;{ 'is-active': editor.isActive('bold') }&quot; @click=&quot;editor.chain().focus().toggleBold().run()&quot;&gt;
  Bold
&lt;/button&gt;
</code></pre>

<p>これにより、それに応じて <code>.is-active</code> クラスが切り替わり、ノードとマークに対して機能します。特定の属性を確認することもできます。さまざまな属性を無視する <a href="/api/marks/highlight"><code>Highlight</code></a> マークの例を次に示します。</p>
<pre><code class="language-js">editor.isActive('highlight')
</code></pre>

<p>そして、与えられた属性を比較する例：</p>
<pre><code class="language-js">editor.isActive('highlight', { color: '#ffa8a8' })
</code></pre>

<p>正規表現もサポートされています。</p>
<pre><code class="language-js">editor.isActive('textStyle', { color: /.*/ })
</code></pre>

<p>ノードやマークを付けることもできますが、属性のみを確認してください。 <a href="/api/extensions/text-align"><code>TextAlign</code></a> 拡張機能の例を次に示します。</p>
<pre><code class="language-js">editor.isActive({ textAlign: 'right' })
</code></pre>

<p>選択範囲が複数のノードまたはマークにまたがっている場合、または選択範囲の一部にのみマークが付いている場合、 <code>isActive()</code> は  <code>false</code> を返し、アクティブなものがないことを示します。これは、人々が新しいノードまたはマークをその選択にすぐに適用できるようにするため、想定されている方法です。</p>
<h2>ユーザー体験</h2>
<p>優れたユーザーエクスペリエンスを設計するときは、いくつかのことを考慮する必要があります。</p>

<h3>アクセシビリティ</h3>
<ul>
<li>ユーザーがキーボードでメニューをナビゲートできることを確認してください</li>
<li>適切な <a href="https://developer.mozilla.org/de/docs/Web/HTML/Global_attributes/title">タイトル属性</a> を使用する</li>
<li>適切な <a href="https://developer.mozilla.org/en-US/docs/Learn/Accessibility/WAI-ARIA_basics">aria属性</a>を使用する</li>
<li>利用可能なキーボードショートカットを一覧表示します</li>
</ul>
<blockquote>
<p><strong>警告が不完全です</strong>
このセクションにはいくつかの作業が必要です。エディターメニューを作成するときに他に何を考慮する必要があるか知っていますか？ <a href="https://github.com/ueberdosis/tiptap">GitHub</a> でお知らせいただくか、<a href="mailto:humans@tiptap.dev">humans@tiptap.dev</a> にメールを送信してください</p>
</blockquote>


<h3>アイコン</h3>

<p>ほとんどのエディタメニューは、ボタンにアイコンを使用しています。 一部のデモでは、無料で使用できるオープンソースのアイコンセット<a href="https://remixicon.com/">Remix Icon</a> を使用しています。 しかし、何を使用するかは完全にあなた次第です。 検討できるアイコンセットは次のとおりです。</p>
<ul>
<li>
<a href="https://remixicon.com/#editor">Remix Icon</a>
</li>
<li>
<a href="https://fontawesome.com/icons?c=editors">Font Awesome</a>
</li>
<li>
<a href="https://www.ibm.com/design/language/iconography/ui-icons/library/">UI icons</a>
</li>
</ul>
<h1>スタイリング</h1>
<h2>はじめに</h2>
<p>tiptap is headless, that means there is no styling provided. That also means, you are in full control of how your editor looks. The following methods allow you to apply custom styles to the editor.</p>
<p>Tiptap はヘッドレスです。つまり、スタイリングは提供されません。これは、エディターの外観を完全に制御できることも意味します。次のメソッドを使用すると、カスタムスタイルをエディターに適用できます。</p>
<h2>オプション1：プレーンHTMLのスタイルを設定する</h2>

<p>エディター全体は、クラス <code>.ProseMirror</code> を持つコンテナー内にレンダリングされます。これを使用して、スタイリングをエディターコンテンツにスコープすることができます。</p>
<pre><code class="language-css">/* Scoped to the editor */
.ProseMirror p {
  margin: 1em 0;
}
</code></pre>

<p>保存されたコンテンツをどこかにレンダリングする場合、<code>.ProseMirror</code> コンテナはないため、使用する HTML タグにスタイルをグローバルに追加できます。</p>
<pre><code class="language-css">/* Global styling */
p {
  margin: 1em 0;
}
</code></pre>
<h2>オプション2：カスタムクラスを追加する</h2>
<p>すべてにクラスを追加することを含め、レンダリング全体を制御できます。</p>

<h3>拡張機能</h3>

<p>ほとんどの拡張機能では、<code>HTMLAttributes</code> オプションを使用してレンダリングされたHTMLに属性を追加できます。これを使用して、カスタムクラス（またはその他の属性）を追加できます。 <a href="https://tailwindcss.com/">Tailwind CSS</a> を使用する場合にも、これは非常に役立ちます。</p>
<pre><code class="language-js">new Editor({
  extensions: [
    Document,
    Paragraph.configure({
      HTMLAttributes: {
        class: 'my-custom-paragraph',
      },
    }),
    Heading.configure({
      HTMLAttributes: {
        class: 'my-custom-heading',
      },
    }),
    Text,
  ],
})
</code></pre>
<p>レンダリングされたHTMLは次のようになります。</p>
<pre><code class="language-html">&lt;h1 class=&quot;my-custom-heading&quot;&gt;Example Text&lt;/p&gt;
&lt;p class=&quot;my-custom-paragraph&quot;&gt;Wow, that’s really custom.&lt;/p&gt;
</code></pre>

<p>拡張機能によって定義されたクラスがすでに存在する場合は、クラスが追加されます。</p>
<h3>エディター</h3>

<p>次のようなエディターを含む要素にクラスを渡すこともできます。</p>
<pre><code class="language-js">new Editor({
  editorProps: {
    attributes: {
      class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl mx-auto focus:outline-none',
    },
  },
})
</code></pre>
<h3>TailwindCSSを使用</h3>
<p>エディターはTailwindCSSでも正常に動作します。以下の <code>@tailwindcss/typography</code> プラグインでスタイル設定された例を見つけてください。</p>

<p><a href="https://embed.tiptap.dev/preview/Experiments/Tailwind">https://embed.tiptap.dev/preview/Experiments/Tailwind</a></p>
<h2>オプション3：HTMLをカスタマイズする</h2>
<p>または、拡張機能のマークアップをカスタマイズできます。次の例では、<code>&lt;strong&gt;</code> タグではなく、<code>&lt;b&gt;</code> タグをレンダリングするカスタムの太字の拡張機能を作成します。</p>

<pre><code class="language-js">
const CustomBold = Bold.extend({
  renderHTML({ HTMLAttributes }) {
    // Original:
    // return ['strong', HTMLAttributes, 0]
    return ['b', HTMLAttributes, 0]
  },
})

new Editor({
  extensions: [
    // …
    CustomBold,
  ],
})
</code></pre>
<p>カスタム拡張機能は別のファイルに入れる必要がありますが、私はあなたがその考えを理解したと思います。</p>

<h1>出力</h1>
<h2>はじめに</h2>

<p>コンテンツは JSON オブジェクトまたは古き良き HTML 文字列として保存できます。どちらも正常に動作します。もちろん、両方の形式をエディターに渡してコンテンツを復元することもできます。これは、ドキュメントが変更されたときにコンテンツを HTML および JSON としてエクスポートするインタラクティブな例です。</p>
<h2>書き出し</h2>
<h3>オプション1：JSON</h3>
<p>JSON はおそらく、たとえばメンションを探すためにループするのが簡単で、Tiptap が内部で使用するものに似ています。とにかく、JSON を使用してコンテンツを保存する場合は、コンテンツを JSON として取得するメソッドを提供します。</p>

<pre><code class="language-js">const json = editor.getJSON()
</code></pre>

<p>これをデータベースに保存して（またはAPIに送信して）、最初は次のようにドキュメントを復元できます。</p>
<pre><code class="language-js">new Editor({
  content: {
    &quot;type&quot;: &quot;doc&quot;,
    &quot;content&quot;: [
      // …
    ]
  },
})
</code></pre>

<p>または、何かを待つ必要がある場合は、後でエディターインスタンスを使用してそれを行うことができます。</p>
<pre><code class="language-js">editor.commands.setContent({
  &quot;type&quot;: &quot;doc&quot;,
  &quot;content&quot;: [
    // …
  ]
})
</code></pre>

<p><a href="https://embed.tiptap.dev/preview/GuideContent/ExportJSON?hideSource">https://embed.tiptap.dev/preview/GuideContent/ExportJSON?hideSource</a></p>
<h3>オプション2：HTML</h3>
<p>HTML は、電子メールなどの他の場所で簡単にレンダリングでき、頻繁に使用されるため、ある時点でエディターを切り替える方がおそらく簡単です。とにかく、すべてのエディターインスタンスは、現在のドキュメントからHTMLを取得するためのメソッドを提供します。</p>

<pre><code class="language-js">const html = editor.getHTML()
</code></pre>

<p>これを使用して、最初にドキュメントを復元できます。</p>
<pre><code class="language-js">new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
})
</code></pre>

<p>または、後でコンテンツを復元する場合（たとえば、API呼び出しが終了した後）、それも実行できます。</p>
<pre><code class="language-js">editor.commands.setContent(`&lt;p&gt;Example Text&lt;/p&gt;`)
</code></pre>

<p>このインタラクティブな例を使用して、いじくりまわします。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideContent/ExportHTML?hideSource">https://embed.tiptap.dev/preview/GuideContent/ExportHTML?hideSource</a></p>
<h3>オプション3：Y.js</h3>
<p>私たちのエディターは Y.js を一流にサポートしており、<a href="/guide/collaborative-editing">リアルタイムコラボレーション、オフライン編集、デバイス間の同期</a> などの機能を追加できます。</p>
<p>内部的には、Y.js はすべての変更の履歴を保存します。これは、ブラウザ、サーバー、接続されている他のクライアントとの同期、または USB スティックで行うことができます。ただし、Y.js にはこれらの保存された変更が必要であることを知っておくことが重要です。単純な JSON ドキュメントでは、変更をマージするのに十分ではありません。</p>
<p>もちろん、既存の JSON ドキュメントをインポートして開始し、Y.js から JSON を取得することはできますが、それはインポート/エクスポート形式に似ています。それはあなたの単一の情報源ではありません。上記のユースケースの1つに Y.js を追加する場合は、これを考慮することが重要です。</p>
<p>とは言うものの、それは素晴らしいことであり、私たちは素晴らしいバックエンドを提供しようとしています。</p>



<h3>マークダウンはオプションではありません</h3>
<p>残念ながら、<strong>Tiptap は入力または出力形式として Markdown をサポートしていません。</strong> サポートを追加することを検討しましたが、それを行わないことにした理由は次のとおりです。</p>
<ul>
<li>HTML と JSON はどちらも、深くネストされた構造を持つことができ、Markdown はフラットなため。</li>
<li>Markdown の基準が異なるため。</li>
<li>Tiptap の強みはカスタマイズですが、Markdown ではうまく機能しないため。</li>
<li>HTML を Markdown に、またはその逆に変換するのに十分なパッケージがあるため。</li>
</ul>
<p>HTML または JSON を使用してコンテンツを保存することを検討する必要があります。これらは、ほとんどのユースケースで完全に問題ありません。</p>
<p>それでもMarkdownが必要だと思われる場合は、ProseMirrorに<a href="https://prosemirror.net/examples/markdown/">Markdownの処理方法の例</a>、<a href="https://github.com/nextcloud/text">Nextcloud Text</a> はTiptap v1 を使用して Markdown を操作します。多分あなたはそれらから学ぶことができます。または、本当に優れた Markdown エディターをお探しの場合は、<a href="https://codemirror.net/">CodeMirror</a> をお試しください。</p>
<p>そうは言っても、Tiptap はコンテンツをフォーマットするための<a href="/examples/markdown-shortcuts">Markdownショートカット</a> をサポートしています。また、コンテンツを Markdown のように見せることもできます。たとえば、CSS で <code>&lt;h1&gt;</code> の前に <code>＃</code> を追加します。</p>





<h2>変更箇所のリッスン</h2>
<p>人々が書いている間、更新されたコンテンツを継続的に保存したい場合は、<a href="/api/events">イベントにフック</a> することができます。 これがどのように見えるかの例です：</p>

<pre><code class="language-js">const editor = new Editor({
  // intial content
  content: `&lt;p&gt;Example Content&lt;/p&gt;`,

  // triggered on every change
  onUpdate: ({ editor }) =&gt; {
    const json = editor.getJSON()
    // send the content to an API here
  },
})
</code></pre>
<h2>レンダリング</h2>
<h3>オプション1：Tiptap の読み取り専用インスタンス</h3>
<p>保存したコンテンツをレンダリングするには、エディターを読み取り専用に設定します。 これにより、CSS やその他のコードを複製することなく、エディターとまったく同じレンダリングを実現できます。</p>

<p><a href="https://embed.tiptap.dev/preview/GuideContent/ReadOnly">https://embed.tiptap.dev/preview/GuideContent/ReadOnly</a></p>
<h3>オプション2：ProseMirror の JSON から HTML を生成する</h3>
<p>サーバー側でコンテンツをレンダリングする必要がある場合、たとえば、Tiptap で記述されたブログ投稿の HTML を生成する場合は、実際のエディターインスタンスなしでそれを実行することをお勧めします。</p>
<p>それが <code>generateHTML()</code> の目的です。 これは、実際のエディターインスタンスなしで HTML をレンダリングするヘルパー関数です。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideContent/GenerateHTML">https://embed.tiptap.dev/preview/GuideContent/GenerateHTML</a></p>
<p>ちなみに、他の方法も可能です。 以下の例は、HTML から JSON を生成する方法を示しています。</p>




<p><a href="https://embed.tiptap.dev/preview/GuideContent/GenerateJSON">https://embed.tiptap.dev/preview/GuideContent/GenerateJSON</a></p>
<h2>マイグレーション</h2>
<p>既存のコンテンツを Tiptap に移行する場合は、既存の出力を HTML に変換することをお勧めします。 ProseMirror は問題がないことを保証するため、これはおそらく最初のコンテンツを Tiptap に取り込むのに最適な形式です。（構成に基づいて）許可されていないタグや属性がある場合でも、Tiptap はそれらを静かに破棄します。</p>
<p>これを支援するために、いくつかのケースを検討します。たとえば、HTML を互換性のある JSON 構造に変換する PHP パッケージを提供します <a href="https://github.com/ueberdosis/html-to-prosemirror">ueberdosis/prosemirror-to-html</a> 。</p>
<p><a href="mailto:humans@tiptap.dev">あなたの経験を私たちと共有してください！</a> ここにさらに情報を追加したいと思います。</p>



<h2>セキュリティ</h2>
<p>セキュリティ上の懸念から、どちらか一方を使用する理由はありません。誰かが悪意のあるコンテンツをサーバーに送信したい場合、それが JSON であるか HTML であるかは関係ありません。 Tiptap を使用しているかどうかは関係ありません。常にユーザー入力を検証する必要があります。</p>

<h1>アクセシビリティ</h1>

<blockquote>
<p>pro 開発資金♥
Tiptap を維持、更新、サポート、開発するには、あなたのサポートが必要です。ここで進捗を待っている場合は、<a href="/sponsor">スポンサーになり、私たちの仕事に資金を提供してください</a> 。</p>
</blockquote>
<h2>はじめに</h2>

<p>Tiptap を誰もが利用できるように努めていますが、正直なところ、現在はあまり作業が行われていません。私たちの現在の理解から、それが行われる必要があることです。</p>
<h2>インターフェース</h2>
<p>インターフェイスには、明確に定義されたコントラスト、十分な大きさのクリック領域、セマンティックマークアップが必要であり、キーボードでアクセス可能であり、十分に文書化されている必要があります。現在、インターフェースも提供していませんので、今のところそれは完全にあなた次第です。</p>
<p>ただし、心配はいりません。すぐにインターフェースを提供し、早い段階でアクセシビリティを考慮に入れます。</p>


<h2>出力</h2>
<p>エディターはセマンティックマークアップを生成する必要があり、キーボードでアクセス可能であり、十分に文書化されている必要があります。 Tiptapのコンテンツは適切に構成されているため、すでに優れた基盤となっています。そうは言っても、サポートを追加して、画像のAlt属性などの追加の属性の使用を奨励することができます。</p>

<h3>ライティング支援（オプション）</h3>
<p>オプションのライティング支援は、たとえば見出しレベルの誤った使用法を指摘するなど、意味的に正しいコンテンツを書く人々を助けることができます。コア開発者が提供するこの種の支援により、多くのアプリケーションのコンテンツを改善するのに役立つ可能性があります。</p>

<h2>資力</h2>
<p>|ドキュメント|セクション|見出し|
| -------- | ------- | -------------------------------------------------- ------------------------------------ |
| WCAG 3.0 | 7.1 | <a href="https://www.w3.org/TR/wcag-3.0/#text-alternatives">代替テキスト</a>|
| WCAG 2.1 | 1.1.1 | <a href="https://www.w3.org/WAI/WCAG21/Understanding/non-text-content">非テキストコンテンツ</a>|
| WCAG 2.1 | 2.1 | <a href="https://www.w3.org/WAI/WCAG21/Understanding/keyboard-accessible">キーボードアクセス可能</a>|
| WCAG 2.1 | 2.1.1 | <a href="https://www.w3.org/WAI/WCAG21/Understanding/keyboard">キーボード</a>|
| WCAG 2.1 | 4.1.1 | <a href="https://www.w3.org/WAI/WCAG21/Understanding/parsing">解析</a>|
| WCAG 2.1 | 4.1.2 | <a href="https://www.w3.org/WAI/WCAG21/Understanding/name-role-value">名前、役割、価値</a>|
| WCAG 2.1 | 2.1.2 | <a href="https://www.w3.org/TR/WCAG21/#no-keyboard-trap">キーボードトラップなし</a>|</p>
<p>TODO：WCAG3.0を指すようにリソースを更新します <a href="https://www.w3.org/TR/wcag-3.0/">https://www.w3.org/TR/wcag-3.0/</a></p>
<p>ここに追加する必要があるものはありますか？ <a href="mailto:humans@tiptap.dev">お知らせください</a>、それを考慮に入れることができます。</p>
<h1>コラボ編集</h1>
<h2>はじめに</h2>

<p>リアルタイムのコラボレーション、異なるデバイス間の同期、オフラインでの作業は、以前は困難でした。 <a href="https://github.com/yjs/yjs">Y.js</a> のパワーとすべてを同期させるために必要なすべてを提供します。次のガイドは、Tiptapでの共同編集を開始するのに役立ちます。心配しないでください。本番環境グレードのセットアップでは、多くのコードは必要ありません。</p>
<h2>ビデオコース</h2>
<p>私たちは、Tiptap を使用した共同テキスト編集について知っておく必要のあるすべてを教えるビデオコースに取り組んでいます。最初のビデオは、スポンサーがここで利用できます。</p>

<p><a href="https://tiptap.dev/screencasts/collaborative-editing/make-tiptap-collaborative">https://tiptap.dev/screencasts/collaborative-editing/make-tiptap-collaborative</a></p>
<h2>エディターを構成する</h2>
<p>Tiptapが使用する基本的なスキーマは、ドキュメントを同期するための優れた基盤です。 <a href="/api/extensions/collaboration"><code>Collaboration</code></a> 拡張機能を使用すると、<a href="https://github.com/yjs/yjs">Y.js</a> を使用してドキュメントへの変更を追跡するようにTiptapに指示できます。</p>
<p>Y.js は、競合のないレプリケートされたデータ型の実装です。つまり、変更をマージするのに非常に優れています。そしてそれを達成するために、変更を順番に行う必要はありません。オフライン中にドキュメントを変更し、デバイスが再びオンラインになったときに他の変更とマージすることはまったく問題ありません。</p>
<p>どういうわけか、すべてのクライアントは、ある時点でドキュメントの変更を交換する必要があります。そのための最も一般的なテクノロジーは、<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">WebRTC</a>  と<a href="https://developer.mozilla.org/de/docs/Web/API/WebSocket">WebSockets</a> です。なので、それらを詳しく見てみましょう。</p>



<h3>WebRTC</h3>
<p>WebRTC は、クライアントを相互に接続するためにのみサーバーを使用します。実際のデータは、サーバーがそれについて何も知らずにクライアント間を流れます。これは、協調編集の最初のステップを実行するのに最適です。</p>
<p>まず、依存関係をインストールします。</p>


<pre><code class="language-bash">npm install @tiptap/extension-collaboration yjs y-webrtc
</code></pre>

<p>次に、新しい Y ドキュメントを作成し、Tiptap に登録します。</p>
<pre><code class="language-js">
// A new Y document
const ydoc = new Y.Doc()
// Registered with a WebRTC provider
const provider = new WebrtcProvider('example-document', ydoc)

const editor = new Editor({
  extensions: [
    StarterKit.configure({
      // The Collaboration extension comes with its own history handling
      history: false,
    }),
    // Register the document with Tiptap
    Collaboration.configure({
      document: ydoc,
    }),
  ],
})
</code></pre>


<p>これは、Tiptap のコラボレーティブインスタンスを作成するのに十分なはずです。クレイジーですね。試してみて、2つの異なるブラウザでエディタを開きます。変更は、異なるウィンドウ間で同期する必要があります。</p>
<p>では、この魔法はどのように機能しますか？すべてのクライアントは互いに接続する必要があります。それが<em>プロバイダー</em>の仕事です。 <a href="https://github.com/yjs/y-webrtc">WebRTCプロバイダー</a> は、パブリックサーバーを使用してクライアントを相互に直接接続しますが、実際の変更を同期しないため、開始するのに最も簡単な方法です。 。ただし、これには2つの欠点があります。</p>


<ol>
<li>ブラウザはあまりにも多くのクライアントとの接続を拒否します。 Y.js では、すべてのクライアントが間接的に接続されていれば十分ですが、それでもある時点では不可能です。つまり、同じドキュメント内の 100を超える同時クライアントに対しては適切に拡張できません。</li>
<li>とにかく変更を永続化するために、サーバーを関与させたいと思う可能性があります。ただし、WebRTC シグナリングサーバー（すべてのクライアントを相互に接続する）は変更を受信しないため、ドキュメントの内容を認識しません。</li>
</ol>

<p>とにかく、さらに深く掘り下げたい場合は、GitHubの <a href="https://github.com/yjs/y-webrtc">Y WebRTCリポジトリ</a> にアクセスしてください。</p>
<h3>WebSocket（推奨）</h3>
<p>ほとんどのユースケースでは、WebSocket プロバイダーが推奨される選択です。非常に柔軟性があり、拡張性に優れています。さらに簡単にするために、Tiptap の公式バックエンドに取り組んでいます。バックエンドはまだ早期アクセス（スポンサーのみ）ですが、プロバイダーはすでに使用できます。</p>
<p>クライアントの場合、例はほぼ同じですが、プロバイダーのみが異なります。まず、依存関係をインストールしましょう。</p>


<pre><code class="language-bash">npm install @tiptap/extension-collaboration @hocuspocus/provider
</code></pre>

<p>次に、WebSocket プロバイダーを Tiptap に登録します。</p>
<pre><code class="language-js">
// Set up the Hocuspocus WebSocket provider
const provider = new HocuspocusProvider({
  url: 'ws://127.0.0.1:1234',
  name: 'example-document',
})

const editor = new Editor({
  extensions: [
    StarterKit.configure({
      // The Collaboration extension comes with its own history handling
      history: false,
    }),
    // Register the document with Tiptap
    Collaboration.configure({
      document: provider.document,
    }),
  ],
})
</code></pre>
<p>This example doesn’t work out of the box. As you can see, it’s configured to talk to a WebSocket server which is available under <code>ws://127.0.0.1:1234</code> (WebSocket protocol <code>ws://</code>, your local IP <code>127.0.0.1</code> and the port <code>1234</code>). You need to set this up, too.</p>
<p>この例は、そのままでは機能しません。ご覧のとおり、<code>ws://127.0.0.1:1234</code>（WebSocketプロトコル <code>ws://</code>、ローカルIP <code>127.0.0.1</code>、<code>1234</code> ポートで利用可能なWebSocketサーバーと通信するように構成されています）。これも設定する必要があります。</p>
<h4>WebSocket バックエンド</h4>
<p>サーバー部分をできるだけ簡単にするために、<a href="http://hocuspocus.dev/">Hocuspocusと呼ばれる意見のあるサーバーパッケージ</a> を提供しています（現在、スポンサーとサブスクライバーのみが利用できます）。これは柔軟なNode.jsパッケージであり、カスタムバックエンドの構築に使用できます。</p>
<p>このガイドの目的のために、最小限のサーバーを文字通り数秒で起動するコマンドラインインターフェイスを使用してみましょう。</p>


<pre><code class="language-bash">npx @hocuspocus/cli --port 1234 --sqlite
</code></pre>

<p>このコマンドは、Hocuspocus コマンドラインインターフェイスをダウンロードし、ポート1234 でリッスンしているサーバーを起動し、変更をメモリに保存します（したがって、コマンドを停止すると、サーバーは削除されます）。出力は次のようになります。</p>
<pre><code>Hocuspocus v1.0.0 running at:

&gt; HTTP: http://127.0.0.1:1234
&gt; WebSocket: ws://127.0.0.1:1234

Ready.
</code></pre>


<p>ブラウザで <a href="http://127.0.0.1:1234">http://127.0.0.1:1234</a> を開いてみてください。すべてが正常に機能する場合は、プレーンテキスト「OK」が表示されるはずです。</p>
<p>Tiptap エディターに戻り、リロードを押します。これで Hocuspocus WebSocket サーバーに接続され、変更が他のすべてのクライアントと同期されるはずです。すごいですね。</p>
<h3>複数のネットワークプロバイダー</h3>
<p>複数のプロバイダーを組み合わせることもできます。これは必須ではありませんが、1つの接続（WebSocketサーバーなど）がしばらくダウンした場合でも、クライアントの接続を維持できます。次に例を示します。</p>

<pre><code class="language-js">new WebrtcProvider('example-document', ydoc)
new HocuspocusProvider({
  url: 'ws://127.0.0.1:1234',
  name: 'example-document',
  document: ydoc,
})
</code></pre>


<p>はい、それだけです。</p>
<p>WebRTC には、クライアントを接続するためのシグナリングサーバーが必要であることに注意してください。このシグナリングサーバーは同期されたデータを受信しませんが、クライアントがお互いを見つけられるようにするのに役立ちます。必要に応じて、<a href="https://github.com/yjs/y-webrtc#signaling">独自のシグナリングサーバーを実行する</a> ことができます。それ以外の場合は、パッケージに組み込まれているデフォルトの URL を使用しています。</p>
<h3>他のカーソルを表示する</h3>
<p>ユーザーがカーソルとテキストの選択を相互に表示できるようにするには、<a href="/api/extensions/collaboration-cursor"><code>CollaborationCursor</code></a> 拡張機能を追加します。</p>

<pre><code class="language-js">
// Set up the Hocuspocus WebSocket provider
const provider = new HocuspocusProvider({
  url: 'ws://127.0.0.1:1234',
  name: 'example-document',
})

const editor = new Editor({
  extensions: [
    StarterKit.configure({
      // The Collaboration extension comes with its own history handling
      history: false,
    }),
    Collaboration.configure({
      document: provider.document,
    }),
    // Register the collaboration cursor extension
    CollaborationCursor.configure({
      provider: provider,
      user: {
        name: 'Cyndi Lauper',
        color: '#f783ac',
      },
    }),
  ],
})
</code></pre>

<p>ご覧のとおり、すべてのユーザーに名前と色を渡すことができます。 <a href="/examples/collaborative-editing">コラボ編集の例</a> を見て、より高度な例を確認してください。</p>
<h3>オフラインサポート</h3>
<p>素晴らしい<a href="https://github.com/yjs/y-indexeddb">YIndexedDBアダプター</a> のおかげで、コラボレーションエディターにオフラインサポートを追加するのは基本的にワンライナーです。それをインストールします：</p>

<pre><code class="language-bash">npm install y-indexeddb
</code></pre>

<p>そしてそれを Y ドキュメントに接続します：</p>
<pre><code class="language-js">
const ydoc = new Y.Doc()

// Store the Y document in the browser
new IndexeddbPersistence('example-document', ydoc)

const editor = new Editor({
  extensions: [
    // …
    Collaboration.configure({
      document: ydoc,
    }),
  ],
})
</code></pre>


<p>タブを閉じたり、オフラインにしたり、オフラインで作業しているときに変更を加えたりしても、すべての変更はブラウザに保存されます。次回オンラインになると、WebSocket プロバイダーは接続を見つけようとし、最終的に変更を同期します。</p>
<p>はい、それは魔法です。すでに述べたように、それはすべて素晴らしい Y.js フレームワークに基づいています。そして、それを使用している場合、または私たちの統合を使用している場合は、間違いなく <a href="https://github.com/dmonad">GitHub の Kevin Jahns のスポンサー</a> である必要があります。彼はY.jsの背後にある頭脳です。</p>
<h2>プラグアンドプレイコラボレーションバックエンド</h2>
<p>コラボ編集バックエンドは、同期、承認、永続性、スケーリングを処理します。ここでは、いくつかの一般的な使用例を見ていきましょう。</p>
<blockquote>
<p>警告早期アクセスをリクエストする
プラグアンドプレイコラボレーションバックエンド hocuspocus はまだ進行中です。試してみたい場合は、<a href="https://www.hocuspocus.dev">早期アクセスを取得</a> してください。
：：：</p>
</blockquote>



<p>:::</p>
<h3>ドキュメント名</h3>
<p>ドキュメント名は、ここにあるすべての例で <code>'example-document'</code> ですが、任意の文字列にすることができます。実際のアプリでは、エンティティの名前とエンティティの ID を追加する可能性があります。これがどのように見えるかです。</p>

<pre><code class="language-js">const documentName = 'page.140'
</code></pre>
<p>バックエンドでは、文字列を分割して、ユーザーが ID 140 のページに入力していることを確認し、それに応じて認証などを管理できます。新しいドキュメントはその場で作成され、プロバイダーに文字列を渡す以外に、バックエンドにそれらについて通知する必要はありません。</p>
<p>また、複数のフィールドを 1つの Y.js ドキュメントと同期する場合は、コラボレーション拡張機能に異なるフラグメント名を渡すだけです。</p>


<pre><code class="language-js">// a Tiptap instance for the field
Collaboration.configure({
  document: ydoc,
  field: 'title',
})

// and another instance for the summary, both in the same Y.js document
Collaboration.configure({
  document: ydoc,
  field: 'summary',
})
</code></pre>

<p>ネストされたフラグメントなど、セットアップがやや複雑な場合は、生の Y.js フラグメントを渡すこともできます。その場合、<code>document</code> と <code>field</code> は無視されます。</p>
<pre><code class="language-js">// a raw Y.js fragment
Collaboration.configure({
  fragment: ydoc.getXmlFragment('custom'),
})
</code></pre>
<h3>認証と承認</h3>
<p><code>onAuthenticate</code> フックを使用すると、クライアントが現在のドキュメントを表示するために認証および承認されているかどうかを確認できます。実際のアプリケーションでは、これはおそらく API、データベースクエリ、またはその他への要求になります。</p>
<p>エラーをスローする（または返された Promise を拒否する）と、クライアントへの接続は終了します。クライアントが承認および認証されている場合は、他のフックでアクセスできるコンテキストデータを返すこともできます。しかし、そうする必要はありません。</p>


<pre><code class="language-js">
const server = Server.configure({
  async onAuthenticate({ token }) {
    // Example test if a user is authenticated
    if (token !== 'super-secret-token') {
      throw new Error('Not authorized!')
    }

    // You can set contextual data to use it in other hooks
    return {
      user: {
        id: 1234,
        name: 'John',
      },
    }
  },
})

server.listen()
</code></pre>
<h2>落とし穴</h2>
<h3>スキーマの更新</h3>
<p>Tiptap は <a href="/api/schema">schema</a> に対して非常に厳密です。つまり、構成されたスキーマに従って許可されていないものを追加すると、破棄されます。スキーマが異なる複数のクライアントがドキュメントへの変更を共有する場合、これは奇妙な動作につながる可能性があります。</p>
<p>アプリにエディターを追加し、最初のユーザーがすでにそれを使用しているとします。それらには、すべてのデフォルト拡張機能を備えたTiptap のすべてのロードされたインスタンスがあり、そのため、それらのみを許可するスキーマがあります。ただし、次の更新でタスクリストを追加したいので、拡張機能を追加して再度デプロイします。</p>
<p>新しいユーザーがアプリを開き、更新されたスキーマ（タスクリストあり）を持っていますが、他のすべてのユーザーは古いスキーマ（タスクリストなし）を持っています。新しいユーザーは、新しく追加されたタスクリストをチェックアウトし、それをドキュメントに追加して、そのドキュメント内の他のユーザーにその機能を表示します。しかし、その後、彼女がそれを追加した直後にそれは魔法のように消えます。どうしたの？</p>
<p>1人のユーザーが新しいノード（またはマーク）を追加すると、その変更は接続されている他のすべてのクライアントに同期されます。接続されている他のクライアントは、これらの変更をエディターに適用します。Tiptap は、（古い）スキーマでは許可されていないため、そのまま厳密に、新しく追加されたノードを削除します。これらの変更は、接続されている他のクライアントやおっとに同期され、すべての場所で削除されます。これを回避するには、いくつかのオプションがあります。</p>
<ol>
<li>スキーマを変更しないでください（クールではありません）。</li>
<li>新しいスキーマをデプロイするときにクライアントを強制的に更新します（タフ）。</li>
<li>スキーマのバージョンを追跡し、古いスキーマを持つクライアントのエディターを無効にします（セットアップによって異なります）。</li>
</ol>
<p>それを簡単にする機能を提供することは私たちのリストにあります。それを改善する方法がわかったら、それを私たちと共有してください！</p>








<h1>カスタム拡張</h1>
<h2>はじめに</h2>
<p>Tiptap の強みの1つは、その拡張性です。提供されている拡張機能に依存するのではなく、エディターを好みに合わせて拡張することを目的としています。</p>
<p>カスタム拡張機能を使用すると、既存のものに加えて、または最初から、新しいコンテンツタイプと新しい機能を追加できます。既存のノード、マーク、拡張機能を拡張する方法のいくつかの一般的な例から始めましょう。</p>
<p>最後に最初から始める方法を学びますが、既存の拡張機能を拡張したり、新しい拡張機能を作成したりするためにも同じ知識が必要です。</p>



<h2>既存の拡張機能を拡張する</h2>
<p>すべての拡張機能には <code>extend()</code> メソッドがあり、変更または追加したいすべてのものを含むオブジェクトを取得します。</p>
<p>たとえば、箇条書きのキーボードショートカットを変更したいとします。拡張機能のソースコード、その場合は <a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bullet-list/src/bullet-list.ts"><code>BulletList</code>ノード</a> 。キーボードショートカットを上書きする特注の例の場合、コードは次のようになります。</p>


<pre><code class="language-js">// 1. Import the extension

// 2. Overwrite the keyboard shortcuts
const CustomBulletList = BulletList.extend({
  addKeyboardShortcuts() {
    return {
      'Mod-l': () =&gt; this.editor.commands.toggleBulletList(),
    }
  },
})

// 3. Add the custom extension to your editor
new Editor({
  extensions: [
    CustomBulletList(),
    // …
  ],
})
</code></pre>

<p>名前を除いて、同じことが既存の拡張機能のすべての側面に当てはまります。 extend メソッドで変更できるすべてのものを見てみましょう。すべての例で1つの側面に焦点を当てていますが、これらすべての例を組み合わせて、1つの <code>extend()</code> 呼び出しで複数の側面を変更することもできます。</p>
<h3>名前</h3>
<p>拡張子の名前は多くの場所で使用されており、変更するのは簡単ではありません。既存の拡張機能の名前を変更する場合は、拡張機能全体をコピーして、すべての場所で名前を変更できます。</p>
<p>拡張子名も JSON の一部です。 <a href="/guide/output#option-1-json">コンテンツをJSONとして保存</a> する場合は、そこでも名前を変更する必要があります。</p>


<h3>優先順位</h3>
<p>優先度は、内線番号が登録される順序を定義します。デフォルトの優先度は <code>100</code> で、これがほとんどの拡張機能にあります。優先度の高い拡張機能は、より早くロードされます。</p>

<pre><code class="language-js">
const CustomLink = Link.extend({
  priority: 1000,
})
</code></pre>

<p>拡張機能が読み込まれる順序は、次の 2つのことに影響します。</p>
<ol>
<li>
<h4>プラグインの注文</h4>
<p>優先度の高い拡張機能の ProseMirror プラグインが最初に実行されます。</p>
</li>
<li>
<h4>スキーマの順序</h4>
</li>
</ol>
<p>たとえば、<a href="/api/marks/link"><code>Link</code></a> マークの優先度が高くなります。つまり、 <code>&lt;strong&gt;&lt;ahref=&quot;…&quot;&gt;例&lt;/a&gt;&lt;/strong&gt;</code>の代わりに、 <code>&lt;ahref=&quot;…&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;/a&gt;</code> としてレンダリングされます。。</p>




<h3>設定</h3>
<p>いずれにせよ、すべての設定は拡張機能を介して構成できますが、デフォルト設定を変更する場合、たとえば、他の開発者に Tiptap の上にライブラリを提供する場合は、次のように行うことができます。</p>

<pre><code class="language-js">
const CustomHeading = Heading.extend({
  addOptions() {
    return {
      ...this.parent?.(),
      levels: [1, 2, 3],
    }
  },
})
</code></pre>
<h3>ストレージ</h3>
<p>ある時点で、拡張インスタンス内にデータを保存したいと思うかもしれません。このデータは変更可能です。<code>this.storage</code> の下の拡張機能内でアクセスできます。</p>

<pre><code class="language-js">
const CustomExtension = Extension.create({
  name: 'customExtension',

  addStorage() {
    return {
      awesomeness: 100,
    }
  },

  onUpdate() {
    this.storage.awesomeness += 1
  },
})
</code></pre>

<p>拡張機能の外部では、<code>editor.storage</code> を介してアクセスできます。各拡張子に一意の名前が付いていることを確認してください。</p>
<pre><code class="language-js">const editor = new Editor({
  extensions: [
    CustomExtension,
  ],
})

const awesomeness = editor.storage.customExtension.awesomeness
</code></pre>
<h3>スキーマ</h3>
<p>Tiptap は、コンテンツの構造化、ネスト、動作などを構成する厳密なスキーマで機能します。既存の拡張機能については、<a href="/api/schema">スキーマのすべての側面を変更できます</a> 。いくつかの一般的な使用例を見ていきましょう。</p>
<p>デフォルトの <code>Blockquote</code> 拡張機能は、見出しなどの他のノードをラップできます。ブロッククォートに段落のみを許可する場合は、それに応じて <code>content</code> 属性を設定します。</p>


<pre><code class="language-js">// Blockquotes must only include paragraphs

const CustomBlockquote = Blockquote.extend({
  content: 'paragraph*',
})
</code></pre>

<p>スキーマでは、ノードをドラッグ可能にすることもできます。これが、<code>draggable</code> オプションの目的です。デフォルトは <code>false</code> ですが、これをオーバーライドできます。</p>
<pre><code class="language-js">// Draggable paragraphs

const CustomParagraph = Paragraph.extend({
  draggable: true,
})
</code></pre>

<p>これはほんの2つの小さな例ですが、<a href="https://prosemirror.net/docs/ref/#model.SchemaSpec">基盤となる ProseMirror スキーマ</a> は非常に強力です。</p>
<h3>属性</h3>
<p>属性を使用して、コンテンツに追加情報を格納できます。デフォルトの<code>Paragraph</code> ノードを拡張してさまざまな色にしたいとします。</p>

<pre><code class="language-js">const CustomParagraph = Paragraph.extend({
  addAttributes() {
    // Return an object with attribute configuration
    return {
      color: {
        default: 'pink',
      },
    },
  },
})

// Result:
// &lt;p color=&quot;pink&quot;&gt;Example Text&lt;/p&gt;
</code></pre>



<p>これで、Tiptap に新しい属性を通知し、デフォルト値として「ピンク」を設定するのに十分です。すべての属性はデフォルトで HTML 属性としてレンダリングされ、開始時にコンテンツから解析されます。</p>
<p>色の例に固執し、実際にテキストに色を付けるためにインラインスタイルを追加するとします。<code>renderHTML</code> 関数を使用すると、出力でレンダリングされる HTML 属性を返すことができます。</p>
<p>この例では、<code>color</code> の値に基づいてスタイル HTML 属性を追加します。</p>
<pre><code class="language-js">const CustomParagraph = Paragraph.extend({
  addAttributes() {
    return {
      color: {
        default: null,
        // Take the attribute values
        renderHTML: attributes =&gt; {
          // … and return an object with HTML attributes.
          return {
            style: `color: ${attributes.color}`,
          }
        },
      },
    }
  },
})

// Result:
// &lt;p style=&quot;color: pink&quot;&gt;Example Text&lt;/p&gt;
</code></pre>

<p>HTML から属性を解析する方法を制御することもできます。色を <code>data-color</code> (<code>color</code>だけでなく) という属性に保存したい場合は、次のようにします。</p>
<pre><code class="language-js">const CustomParagraph = Paragraph.extend({
  addAttributes() {
    return {
      color: {
        default: null,
        // Customize the HTML parsing (for example, to load the initial content)
        parseHTML: element =&gt; element.getAttribute('data-color'),
        // … and customize the HTML rendering.
        renderHTML: attributes =&gt; {
          return {
            'data-color': attributes.color,
            style: `color: ${attributes.color}`,
          }
        },
      },
    }
  },
})

// Result:
// &lt;p data-color=&quot;pink&quot; style=&quot;color: pink&quot;&gt;Example Text&lt;/p&gt;
</code></pre>

<p><code>rendered: false</code>を使用して、属性のレンダリングを完全に無効にすることができます。</p>
<h4>既存の属性を拡張する</h4>
<p>拡張機能に属性を追加して既存の属性を保持する場合は、<code>this.parent()</code> を介してそれらにアクセスできます。</p>
<p>未定義の場合もあるので、必ず確認するか、オプションのチェーンである <code>this.parent?.()</code> を使用してください。</p>


<pre><code class="language-js">const CustomTableCell = TableCell.extend({
  addAttributes() {
    return {
      ...this.parent?.(),
      myCustomAttribute: {
        // …
      },
    }
  },
})
</code></pre>
<h3>グローバル属性</h3>
<p>属性は、一度に複数の拡張機能に適用できます。これは、テキストの配置、行の高さ、色、フォントファミリ、およびその他のスタイル関連の属性に役立ちます。</p>
<p><a href="/api/extensions/text-align"><code>TextAlign</code></a> の <a href="https://github.com/ueberdosis/tiptap/tree/main/packages/extension-text-align">完全なソースコード</a> を詳しく見てください。 拡張機能を使用して、より複雑な例を確認してください。しかし、これが一言で言えばどのように機能するかです。</p>


<pre><code class="language-js">
const TextAlign = Extension.create({
  addGlobalAttributes() {
    return [
      {
        // Extend the following extensions
        types: [
          'heading',
          'paragraph',
        ],
        // … with those attributes
        attributes: {
          textAlign: {
            default: 'left',
            renderHTML: attributes =&gt; ({
              style: `text-align: ${attributes.textAlign}`,
            }),
            parseHTML: element =&gt; element.style.textAlign || 'left',
          },
        },
      },
    ]
  },
})
</code></pre>
<h3>HTMLをレンダリングする</h3>
<p><code>renderHTML</code> 関数を使用すると、拡張機能を HTML にレンダリングする方法を制御できます。すべてのローカル属性、グローバル属性、および構成された CSS クラスを含む属性オブジェクトをオブジェクトに渡します。<code>Bold</code> 拡張機能の例を次に示します。</p>

<pre><code class="language-js">renderHTML({ HTMLAttributes }) {
  return ['strong', HTMLAttributes, 0]
},
</code></pre>


<p>配列の最初の値は、HTML タグの名前である必要があります。 2番目の要素がオブジェクトの場合、属性のセットとして解釈されます。その後の要素はすべて子としてレンダリングされます。</p>
<p>数字のゼロ（穴を表す）は、コンテンツを挿入する場所を示すために使用されます。 2つのネストされたタグを使用した <code>CodeBlock</code> 拡張機能のレンダリングを見てみましょう。</p>
<pre><code class="language-js">renderHTML({ HTMLAttributes }) {
  return ['pre', ['code', HTMLAttributes, 0]]
},
</code></pre>

<pre><code class="language-js">parseHTML() {
  return [
    {
      tag: 'strong',
    },
  ]
},
</code></pre>

<p>これは、すべての <code>&lt;strong&gt;</code> タグを <code>Bold</code> マークに変換するルールを定義します。ただし、これを使用するとさらに高度になります。拡張機能の完全な例を次に示します。</p>
<pre><code class="language-js">parseHTML() {
  return [
    // &lt;strong&gt;
    {
      tag: 'strong',
    },
    // &lt;b&gt;
    {
      tag: 'b',
      getAttrs: node =&gt; node.style.fontWeight !== 'normal' &amp;&amp; null,
    },
    // &lt;span style=&quot;font-weight: bold&quot;&gt; and &lt;span style=&quot;font-weight: 700&quot;&gt;
    {
      style: 'font-weight',
      getAttrs: value =&gt; /^(bold(er)?|[5-9]\d{2,})$/.test(value as string) &amp;&amp; null,
    },
  ]
},
</code></pre>




<p>これにより、<code>&lt;strong&gt;</code> タグと <code>&lt;b&gt;</code> タグ、および <code>font-weight</code> を太字に設定するインラインスタイルの HTML タグがチェックされます。</p>
<p>ご覧のとおり、オプションで <code>getAttrs</code> コールバックを渡して、特定の HTML 属性などのより複雑なチェックを追加できます。コールバックは、<code>style</code> 属性をチェックする場合を除いて、HTML DOMノードに渡され、それが値になります。</p>
<p>その <code>&amp;&amp;null</code> は何をしているのか疑問に思っていますか？ <a href="https://prosemirror.net/docs/ref/version/0.18.0.html#model.ParseRule.getAttrs">チェックが成功した場合、ProseMirror は null または undefined を予期します</a></p>
<p><a href="https://prosemirror.net/docs/ref/version/0.18.0.html#model.ParseRule.priority">ルールに priority を渡す</a> 他の拡張機能との競合を解決するには、たとえば、カスタムを作成する場合クラス属性を持つ段落を検索する拡張機能ですが、すでにデフォルトの段落拡張機能を使用しています。</p>
<h4>getAttrs の使用</h4>
<p>この例でおそらく気付いた <code>getAttrs</code> 関数には、次の 2つの目的があります。</p>
<ol>
<li>HTML属性をチェックして、ルールが一致するかどうかを判断します（そして、マークまたはノードがそのHTMLから作成されます）。関数が <code>false</code> を返す場合、それは一致していません。</li>
<li>DOM 要素を取得し、HTML 属性を使用して、それに応じてマークまたはノード属性を設定します。</li>
</ol>



<pre><code class="language-js">parseHTML() {
  return [
    {
      tag: 'span',
      getAttrs: element =&gt; {
        // Check if the element has an attribute
        element.hasAttribute('style')
        // Get an inline style
        element.style.color
        // Get a specific attribute
        element.getAttribute('data-color')
      },
    },
  ]
},
</code></pre>

<p>マークまたはノード属性を設定するために、キーとしての属性と解析された値を持つオブジェクトを返すことができます。ただし、 <code>addAttributes()</code> 内で <code>parseHTML</code> を使用することをお勧めします。これにより、コードがよりクリーンに保たれます。</p>
<pre><code class="language-js">addAttributes() {
  return {
    color: {
      // Set the color attribute according to the value of the `data-color` attribute
      parseHTML: element =&gt; element.getAttribute('data-color'),
    }
  }
},
</code></pre>

<p><a href="https://prosemirror.net/docs/ref/#model.ParseRule">ProseMirrorリファレンス</a> で、<code>getAttrs</code> およびその他すべての <code>ParseRule</code> プロパティの詳細をご覧ください。</p>
<h3>コマンド</h3>
<pre><code class="language-js">
const CustomParagraph = Paragraph.extend({
  addCommands() {
    return {
      paragraph: () =&gt; ({ commands }) =&gt; {
        return commands.setNode('paragraph')
      },
    }
  },
})
</code></pre>

<blockquote>
<p>警告 addCommands 内の commands パラメータを使用します
<code>addCommands</code> 内の他のコマンドにアクセスするには、渡された <code>commands</code> パラメータを使用します。</p>
</blockquote>
<h3>キーボードショートカット</h3>
<p>ほとんどのコア拡張機能には、適切なキーボードショートカットのデフォルトが付属しています。構築したいものによっては、変更したい場合もあります。<code>addKeyboardShortcuts()</code> メソッドを使用すると、事前定義されたショートカットマップを上書きできます。</p>

<pre><code class="language-js">// Change the bullet list keyboard shortcut

const CustomBulletList = BulletList.extend({
  addKeyboardShortcuts() {
    return {
      'Mod-l': () =&gt; this.editor.commands.toggleBulletList(),
    }
  },
})
</code></pre>
<h3>入力ルール</h3>
<p>入力ルールを使用すると、ユーザー入力をリッスンする正規表現を定義できます。これらは、マークダウンショートカットに使用されます。たとえば、<code>(c)</code> などのテキストを <a href="/api/extends/typography"><code>Typography</code></a> 拡張子を持つ <code>©</code> (およびその他多数) に変換するために使用されます。マークには <code>markInputRule</code> ヘルパー関数を使用し、ノードには <code>nodeInputRule</code> を使用します。</p>
<p>デフォルトでは、両側の2つのチルダの間のテキストは <del>打たれたテキスト</del> に変換されます。両側に1つのチルダで十分だと考えたい場合は、次のように入力ルールを上書きできます。</p>


<pre><code class="language-js">// Use the ~single tilde~ markdown shortcut

// Default:
// const inputRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/

// New:
const inputRegex = /(?:^|\s)((?:~)((?:[^~]+))(?:~))$/

const CustomStrike = Strike.extend({
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type,
      }),
    ]
  },
})
</code></pre>
<h3>ペースト ルール</h3>
<p>貼り付けルールは、入力ルール（上記を参照）と同じように機能します。ただし、ユーザーが入力した内容を聞く代わりに、貼り付けられたコンテンツに適用されます。</p>
<p>正規表現には小さな違いが1つあります。入力ルールは通常、<code>$</code> ドル記号（「行末の位置をアサートする」を意味します）で終わり、貼り付けルールは通常、目を通します。すべてのコンテンツで、「$」ドル記号は表示されていません。</p>
<p>上記の例を使用して貼り付けルールに適用すると、次の例のようになります。</p>



<pre><code class="language-js">// Check pasted content for the ~single tilde~ markdown syntax

// Default:
// const pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g

// New:
const pasteRegex = /(?:^|\s)((?:~)((?:[^~]+))(?:~))/g

const CustomStrike = Strike.extend({
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type,
      }),
    ]
  },
})
</code></pre>
<h3>イベント</h3>
<p><a href="/api/events">イベントリスナー</a> を別の拡張機能に移動することもできます。すべてのイベントのリスナーの例を次に示します。</p>

<pre><code class="language-js">
const CustomExtension = Extension.create({
  onCreate() {
    // The editor is ready.
  },
  onUpdate() {
    // The content has changed.
  },
  onSelectionUpdate({ editor }) {
    // The selection has changed.
  },
  onTransaction({ transaction }) {
    // The editor state has changed.
  },
  onFocus({ event }) {
    // The editor is focused.
  },
  onBlur({ event }) {
    // The editor isn’t focused anymore.
  },
  onDestroy() {
    // The editor is being destroyed.
  },
})
</code></pre>
<h3>これで何が利用できますか？</h3>
<p>これらの拡張機能はクラスではありませんが、拡張機能のどこでも「this」で利用できる重要なものがいくつかあります。</p>

<pre><code class="language-js">// Name of the extension, for example 'bulletList'
this.name

// Editor instance
this.editor

// ProseMirror type
this.type

// Object with all settings
this.options

// Everything that’s in the extended extension
this.parent
</code></pre>
<h3>ProseMirrorプラグイン（Advanced）</h3>
<p>結局のところ、Tiptap は ProseMirror 上に構築されており、ProseMirror には非常に強力なプラグイン API もあります。これに直接アクセスするには、<code>addProseMirrorPlugins()</code> を使用します。</p>

<h4>既存のプラグイン</h4>
<p>以下の例に示すように、既存の ProseMirror プラグインを Tiptap 拡張機能でラップできます。</p>

<pre><code class="language-js">
const History = Extension.create({
  addProseMirrorPlugins() {
    return [
      history(),
      // …
    ]
  },
})
</code></pre>
<h4>ProseMirrorAPI にアクセス</h4>
<p>クリック、ダブルクリック、コンテンツの貼り付けなどのイベントにフックするには、<a href="/api/editor#editor-props">エディター</a> 上で <code>editorProps</code> に <a href="https://prosemirror.net/docs/ref/#view.EditorProps">イベントハンドラー</a> を渡すことができます。</p>


<p>または、以下の例に示すように、それらを Tiptap 拡張機能に追加することもできます。</p>
<pre><code class="language-js">
export const EventHandler = Extension.create({
  name: 'eventHandler',

  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('eventHandler'),
        props: {
          handleClick(view, pos, event) { /* … */ },
          handleDoubleClick(view, pos, event) { /* … */ },
          handlePaste(view, event, slice) { /* … */ },
          // … and many, many more.
          // Here is the full list: https://prosemirror.net/docs/ref/#view.EditorProps
        },
      }),
    ]
  },
})
</code></pre>
<h3>ノードビュー（Advanced）</h3>
<p>たとえば、画像の周囲に洗練されたインターフェイスをレンダリングするために、ノード内で JavaScript を実行する必要がある高度なユースケースでは、ノードビューについて学習する必要があります。</p>
<p>それらは本当に強力ですが、複雑でもあります。簡単に言うと、親 DOM 要素と、コンテンツがレンダリングされる DOM 要素を返す必要があります。次の簡略化された例を見てください。</p>


<pre><code class="language-js">
const CustomImage = Image.extend({
  addNodeView() {
    return () =&gt; {
      const container = document.createElement('div')

      container.addEventListener('click', event =&gt; {
        alert('clicked on the container')
      })

      const content = document.createElement('div')
      container.append(content)

      return {
        dom: container,
        contentDOM: content,
      }
    }
  },
})
</code></pre>

<p>ノードビューについて学ぶことはたくさんあるので、詳細については、<a href="/guide/node-views">ノードビューに関するガイドの専用セクション</a> にアクセスしてください。実際の例を探している場合は、<a href="/api/nodes/task-item"><code>TaskItem</code></a> ノードのソースコードを確認してください。これは、ノードビューを使用してチェックボックスをレンダリングしています。</p>
<h2>新しい拡張機能を作成</h2>
<p>独自の拡張機能を最初から作成できますが、何を知っていますか？これは、上記の既存の拡張機能を拡張する場合と同じ構文です。</p>

<h3>ノードを作成</h3>
<p>ドキュメントをツリーと考えると、<a href="/api/nodes">ノード(nodes)</a> はそのツリーのコンテンツの一種にすぎません。学ぶのに良い例は、<a href="/api/nodes/paragraph"><code>Paragraph</code></a>、<a href="/api/nodes/heading"><code>Heading</code></a>、または <a href="/api/nodes/code-block"><code>CodeBlock</code></a> です。</p>

<pre><code class="language-js">
const CustomNode = Node.create({
  name: 'customNode',

  // Your code goes here.
})
</code></pre>

<p>ノードはブロックである必要はありません。たとえば、テキストとインラインでレンダリングすることもできます。<a href="/api/nodes/mention">@mentions</a></p>
<h3>マークを作成</h3>
<p>たとえば、インラインフォーマットを追加するために、1つまたは複数のマークを <a href="/api/nodes">nodes</a> に適用できます。学ぶべき良い例は、<a href="/api/marks/bold"><code>Bold</code></a>、<a href="/api/marks/italic"><code>Italic</code></a> 、<a href="/api/marks/highlight"><code>Highlight</code></a></p>

<pre><code class="language-js">
const CustomMark = Mark.create({
  name: 'customMark',

  // Your code goes here.
})
</code></pre>
<h3>拡張機能を作成</h3>
<p>拡張機能は Tiptap に新しい機能を追加し、ノードやマークの場合でも、ここで拡張機能という単語を頻繁に読みます。しかし、文字通りの拡張機能があります。これらはスキーマに追加できませんが（マークやノードのように）、機能を追加したり、エディターの動作を変更したりできます。</p>
<p>学ぶべき良い例はおそらく <a href="/api/extensions/text-align"><code>TextAlign</code></a> です。</p>


<pre><code class="language-js">
const CustomExtension = Extension.create({
  name: 'customExtension',

  // Your code goes here.
})
</code></pre>
<h2>共有</h2>
<p>すべてが正常に機能している場合は、<a href="https://github.com/ueberdosis/tiptap/issues/819">コミュニティと共有する</a> ことを忘れないでください。</p>

<h1>インタラクティブノードビュー</h1>
<h2>はじめに</h2>


<p>少なくともカスタマイズ（およびパン）が好きな場合は、スライスされたパン以来、ノードビューが最適です。ノードビューを使用すると、インタラクティブノードをエディターに追加できます。それは文字通りすべてである可能性があります。 JavaScript で記述できる場合は、エディターで使用できます。</p>
<p>ノードビューは、エディター内のエクスペリエンスを向上させるのに最適ですが、Tiptap の読み取り専用インスタンスでも使用できます。これらは設計上 HTML 出力とは無関係であるため、エディター内のエクスペリエンスと出力を完全に制御できます。</p>
<h2>さまざまなタイプのノードビュー</h2>
<p>構築したいものに応じて、ノードビューの動作は少し異なり、特定の機能を検証することもできますが、落とし穴もあります。主な質問は、カスタムノードはどのように見えるべきかということです。</p>

<h3>編集可能なテキスト</h3>
<p>ノードビューには、通常のノードと同じように編集可能なテキストを含めることができます。それは簡単です。カーソルは、通常のノードから期待するのとまったく同じように動作します。既存のコマンドは、これらのノードで非常にうまく機能します。</p>

<pre><code class="language-html">&lt;div class=&quot;Prosemirror&quot; contenteditable=&quot;true&quot;&gt;
  &lt;p&gt;text&lt;/p&gt;
  &lt;node-view&gt;text&lt;/node-view&gt;
  &lt;p&gt;text&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>これが <a href="/api/nodes/task-item"><code>TaskItem</code></a> ノードの仕組みです。</p>
<h3>編集不可能なテキスト</h3>
<p>ノードには、編集できないテキストを含めることもできます。 カーソルはそれらにジャンプできませんが、とにかくそれは望ましくありません。</p>
<p>Tiptapは、デフォルトでそれらに <code>contenteditable=&quot;false&quot;</code> を追加します。</p>


<pre><code class="language-html">&lt;div class=&quot;Prosemirror&quot; contenteditable=&quot;true&quot;&gt;
  &lt;p&gt;text&lt;/p&gt;
  &lt;node-view contenteditable=&quot;false&quot;&gt;text&lt;/node-view&gt;
  &lt;p&gt;text&lt;/p&gt;
&lt;/div&gt;
</code></pre>


<p>これが、編集可能であってはならないメンションをレンダリングする方法です。 ユーザーはそれらを追加または削除できますが、単一の文字を削除することはできません。</p>
<p>Statamic は、Bard エディターにそれらを使用します。これは、独自のテキスト入力を持つことができる Tiptap 内の複雑なモジュールをレンダリングします。</p>
<h3>混合コンテンツ</h3>


<p>編集不可能なテキストと編集可能なテキストを混在させることもできます。 これは、複雑なものを作成し、編集可能なコンテンツ内で太字や斜体などのマークを使用するのに最適です。</p>
<p><strong>しかし</strong>、ノードビューに編集不可能なテキストを持つ他の要素がある場合、カーソルはそこにジャンプできます。 ノードビューの特定の部分に手動で <code>contenteditable=&quot; false&quot;</code> を追加することで、これを改善できます。</p>
<pre><code class="language-html">&lt;div class=&quot;Prosemirror&quot; contenteditable=&quot;true&quot;&gt;
  &lt;p&gt;text&lt;/p&gt;
  &lt;node-view&gt;
    &lt;div contenteditable=&quot;false&quot;&gt;
      non-editable text
    &lt;/div&gt;
    &lt;div&gt;
      editable text
    &lt;/div&gt;
  &lt;/node-view&gt;
  &lt;p&gt;text&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h2>マークアップ</h2>

<p>しかし、<a href="/guide/output">エディターのコンテンツにアクセス</a> するとどうなりますか？ HTML を使用している場合は、ノードをシリアル化する方法を Tiptap に指示する必要があります。</p>

<p>エディターはレンダリングされた JavaScript ノードを <strong>エクスポートしません</strong> 。多くのユースケースでは、とにかくそれを望まないでしょう。</p>

<p>ユーザーがビデオプレーヤーを追加し、外観（自動再生、コントロールなど）を構成できるノードビューがあるとします。 エディターの出力ではなく、エディターでインターフェースがそれを行うようにします。 エディターの出力には、おそらくビデオプレーヤーのみが含まれているはずです。</p>

<p>しかしながら、それはそれほど簡単ではありません。 エディター内のレンダリングと出力を完全に制御できることを覚えておいてください。</p>

<blockquote>
<p><strong>警告 JSONを保存するとどうなりますか？</strong>
これはJSONには適用されません。 JSONでは、すべてがオブジェクトとして保存されます。 HTMLとの間の「変換」を構成する必要はありません。</p>
</blockquote>
<h3>HTMLをレンダリングする</h3>
<p>さて、インタラクティブなノードビューでノードを設定しました。次に、出力を制御します。 ノードビューが非常に複雑な場合でも、レンダリングされる HTML は単純にすることができます。</p>

<pre><code class="language-js">renderHTML({ HTMLAttributes }) {
  return ['my-custom-node', mergeAttributes(HTMLAttributes)]
},

// Output: &lt;my-custom-node count=&quot;1&quot;&gt;&lt;/my-custom-node&gt;
</code></pre>

<p>HTML からコンテンツを復元するのが簡単になるように、区別できるものであることを確認してください。<code>&lt;div&gt;</code> のような一般的なマークアップが必要な場合は、<code>data-type=&quot;my-custom-node&quot;</code> を追加することを検討してください。</p>
<h3>HTMLを解析する</h3>
<p>同じことがコンテンツの復元にも当てはまります。 期待するマークアップを構成できます。これは、ノードビューのマークアップとはまったく関係がない場合があります。 復元したいすべての情報が含まれている必要があります。</p>
<p><a href="/guide/custom-extensions#attributes"><code>addAttributes</code></a> を使用して登録した場合、属性は自動的に復元されます。</p>


<pre><code class="language-js">// Input: &lt;my-custom-node count=&quot;1&quot;&gt;&lt;/my-custom-node&gt;

parseHTML() {
  return [{
    tag: 'my-custom-node',
  }]
},
</code></pre>
<h3>JavaScript/Vue/Reactをレンダリングする</h3>
<p>しかし、実際の JavaScript / Vue / React コードをレンダリングしたい場合はどうでしょうか。 Tiptap を使用して出力をレンダリングすることを検討してください。 エディターを <code>editable:false</code> に設定するだけで、エディターを使用してコンテンツをレンダリングしていることに誰も気付かないでしょう。 :-)</p>


<h1>JavaScript を使用したノードビュー</h1>
<h2>はじめに</h2>

<p>Vue や React のようなフレームワークを使用することは、これら 2つなしで作業することに慣れている場合、複雑すぎると感じる可能性があります。朗報：ノードビューで Vanilla JavaScript を使用できます。知っておくべきことが少しありますが、これを1つずつ見ていきましょう。</p>
<h2>JavaScript を使用してノードビューのレンダリング</h2>

<p>エディター内でノードビューをレンダリングするために必要なことは次のとおりです。</p>

<ol>
<li>
<a href="/guide/custom-extensions">ノード拡張を作成する</a>
2.新しいノードビューを <code>addNodeView()</code> に登録します
3.レンダリング関数を記述します</li>
<li>
<a href="/guide/configuration">新しいノード拡張を使用するように Tiptap を構成する</a>
</li>
</ol>
<p>ノード拡張は次のようになります。</p>

<pre><code class="language-js">
export default Node.create({
  // configuration …

  addNodeView() {
    return ({ editor, node, getPos, HTMLAttributes, decorations, extension }) =&gt; {
      const dom = document.createElement('div')

      dom.innerHTML = 'Hello, I’m a node view!'

      return {
        dom,
      }
    }
  },
})
</code></pre>

<p>実際の動作を見てみましょう。開始するには、以下の例をコピーしてください。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/JavaScript">https://embed.tiptap.dev/preview/GuideNodeViews/JavaScript</a></p>
<p>That node view even interacts with the editor. Time to see how that is wired up.</p>
<p>そのノードビューは、エディターとさえ相互作用します。それがどのように配線されているかを見てみましょう。</p>
<h2>アクセスノードの属性</h2>
<p>エディターは、いくつかの役立つものをレンダリング関数に渡します。それらの1つは <code>node</code> プロップです。これにより、ノードビューでノード属性にアクセスできます。ノード拡張機能に <code>count</code> という名前の<a href="/guide/custom-extensions#attributes">属性を追加</a> したとします。次のように属性にアクセスできます。</p>

<pre><code class="language-js">addNodeView() {
  return ({ node }) =&gt; {
    console.log(node.attrs.count)

    // …
  }
}
</code></pre>
<h2>ノード属性の更新</h2>
<p>レンダリング関数に渡された <code>getPos</code> プロップを使用して、ノードビューからノード属性を更新することもできます。更新された属性のオブジェクトを使用して、新しいトランザクションをディスパッチします。</p>

<pre><code class="language-js">addNodeView() {
  return ({ editor, node, getPos }) =&gt; {
    const { view } = editor

    // Create a button …
    const button = document.createElement('button')
    button.innerHTML = `This button has been clicked ${node.attrs.count} times.`

    // … and when it’s clicked …
    button.addEventListener('click', () =&gt; {
      if (typeof getPos === 'function') {
        // … dispatch a transaction, for the current position in the document …
        view.dispatch(view.state.tr.setNodeMarkup(getPos(), undefined, {
          count: node.attrs.count + 1,
        }))

        // … and set the focus back to the editor.
        editor.commands.focus()
      }
    })

    // …
  }
}
</code></pre>

<p>少し複雑すぎるように見えますか？とにかくプロジェクトにこれらのいずれかがある場合は、<a href="/guide/node-views/react">React</a> または、<a href="/guide/node-views/vue">Vue</a> の使用を検討してください。この 2つを使用すると、少し簡単になります。</p>
<h2>編集可能なコンテンツの追加</h2>
<p>編集可能なコンテンツをノードビューに追加するには、コンテンツのコンテナ要素である <code>contentDOM</code> を渡す必要があります。編集不可および編集可能なテキストコンテンツを含むノードビューの簡略化されたバージョンを次に示します。</p>

<pre><code class="language-js">// Create a container for the node view
const dom = document.createElement('div')

// Give other elements containing text `contentEditable = false`
const label = document.createElement('span')
label.innerHTML = 'Node view'
label.contentEditable = false

// Create a container for the content
const content = document.createElement('div')

// Append all elements to the node view container
dom.append(label, content)

return {
  // Pass the node view container …
  dom,
  // … and the content container:
  contentDOM: content,
}
</code></pre>



<p>ノードビュー用のコンテナとコンテンツ用のコンテナを返す限り、好きなことを自由に行うことができます。上記の実際の例は次のとおりです。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/JavaScriptContent">https://embed.tiptap.dev/preview/GuideNodeViews/JavaScriptContent</a></p>
<p>このコンテンツは Tiptap によってレンダリングされることに注意してください。つまり、許可されているコンテンツの種類を指定する必要があります。たとえば、ノード拡張に <code>content: 'inline*'</code> を使用します（上記の例ではこれを使用しています）。</p>
<h1>React を使用したノードビュー</h1>
<h2>はじめに</h2>

<p>React での作業に慣れている場合、Vanilla JavaScript の使用は複雑に感じる可能性があります。朗報：ノードビューで通常の React コンポーネントを使用することもできます。知っておくべきことが少しありますが、これを 1つずつ見ていきましょう。</p>
<h2>React コンポーネントのレンダリング</h2>
<p>エディター内で React コンポーネントをレンダリングするために必要なことは次のとおりです。</p>


<ol>
<li>
<a href="/guide/custom-extensions">ノード拡張を作成する</a>
</li>
<li>React コンポーネントを作成します</li>
<li>そのコンポーネントを提供された <code>ReactNodeViewRenderer</code> に渡します</li>
<li>
<code>addNodeView()</code> に登録します</li>
<li>
<a href="/guide/configuration">新しいノード拡張を使用するように Tiptap を構成する</a>
</li>
</ol>
<p>ノード拡張は次のようになります。</p>

<pre><code class="language-js">
export default Node.create({
  // configuration …

  addNodeView() {
    return ReactNodeViewRenderer(Component)
  },
})
</code></pre>

<p>この作業を行うには、少し魔法が必要です。ただし、心配しないでください。簡単に開始するために使用できるラッパーコンポーネントが用意されています。以下に示すように、カスタム React コンポーネントに追加することを忘れないでください。</p>
<pre><code class="language-html">&lt;NodeViewWrapper className=&quot;react-component&quot;&gt;
  React Component
&lt;/NodeViewWrapper&gt;
</code></pre>

<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponent">https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponent</a></p>

<p>実際の動作を見てみましょう。開始するには、以下の例をコピーしてください。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponent">https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponent</a></p>
<p>ただし、そのコンポーネントはエディタと相互作用しません。それを配線する時間。</p>
<h2>アクセスノードの属性</h2>
<p>ノード拡張で使用する<code>ReactNodeViewRenderer</code> は、いくつかの非常に役立つ小道具を​​カスタム React コンポーネントに渡します。それらの1つは <code>node</code> プロップです。ノード拡張機能に <code>count</code> という名前の <a href="/guide/custom-extensions#attributes">属性を追加</a> したとします（上記の例で行ったように）。次のようにアクセスできます。</p>

<pre><code class="language-js">props.node.attrs.count
</code></pre>
<h2>ノード属性を更新する</h2>
<p>コンポーネントに渡された <code>updateAttributes</code> プロップを使用して、ノードからノード属性を更新することもできます。更新された属性を持つオブジェクトを <code>updateAttributes</code> プロパティに渡します。</p>

<pre><code class="language-js">export default props =&gt; {
  const increase = () =&gt; {
    props.updateAttributes({
      count: props.node.attrs.count + 1,
    })
  }

  // …
}
</code></pre>

<p>そして、はい、それもすべて反応的です。かなり見苦しいコミュニケーションですね。</p>
<h2>編集可能なコンテンツの追加</h2>
<p>ノードビューに編集可能なコンテンツを追加するのに役立つ <code>NodeViewContent</code> と呼ばれる別のコンポーネントがあります。次に例を示します。</p>

<pre><code class="language-jsx">
export default () =&gt; {
  return (
    &lt;NodeViewWrapper className=&quot;react-component-with-content&quot;&gt;
      &lt;span className=&quot;label&quot; contentEditable={false}&gt;React Component&lt;/span&gt;

      &lt;NodeViewContent className=&quot;content&quot; /&gt;
    &lt;/NodeViewWrapper&gt;
  )
}
</code></pre>




<p>これらの <code>className</code> 属性を追加する必要はありません。自由に削除するか、他のクラス名を渡してください。次の例で試してみてください。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponentContent">https://embed.tiptap.dev/preview/GuideNodeViews/ReactComponentContent</a></p>
<p>このコンテンツは Tiptap によってレンダリングされることに注意してください。つまり、許可されているコンテンツの種類を指定する必要があります。たとえば、ノード拡張に <code>content: 'inline *'</code> を使用します（上記の例ではこれを使用しています）。</p>
<p><code>NodeViewWrapper</code> および <code>NodeViewContent</code> コンポーネントは <code>&lt;div&gt;</code> HTML タグ（インラインノードの場合は <code>&lt;span&gt;</code>）をレンダリングしますが、これは変更できます。たとえば、 <code>&lt;NodeViewContent as=&quot;p&quot;&gt;</code> は段落をレンダリングする必要があります。ただし、1つの制限：そのタグは実行時に変更してはなりません。</p>
<h2>利用可能なすべてのプロップ</h2>
<p>これがあなたが期待できるプロップの完全なリストです：</p>

<h3>editor</h3>

<p>エディターインスタンス</p>
<h3>node</h3>

<p>現在のノード</p>
<h3>decorations</h3>

<p>装飾の配列</p>
<h3>selected</h3>

<p>現在のノードビューに <code>NodeSelection</code> がある場合は <code>true</code></p>
<h3>extension</h3>

<p>たとえばオプションを取得するためのノード拡張へのアクセス</p>
<h3>getPos()</h3>

<p>現在のノードのドキュメント位置を取得します</p>
<h3>updateAttributes()</h3>

<p>現在のノードの属性を更新します</p>
<h3>deleteNode()</h3>

<p>現在のノードを削除します</p>
<h2>Dragging</h2>

<p>ノードビューをドラッグ可能にするには、拡張機能で「draggable: true」を設定し、ドラッグハンドルとして機能する DOM 要素に「data-drag-handle」を追加します。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle">https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle</a></p>
<h1>Node views with Vue</h1>
<h2>はじめに</h2>

<p>Vue での作業に慣れている場合、Vanilla JavaScript の使用は複雑に感じる可能性があります。 朗報：ノードビューで通常の Vue コンポーネントを使用することもできます。 知っておくべきことが少しありますが、これを1つずつ見ていきましょう。</p>
<h2>Vue コンポーネントをレンダリング</h2>

<p>エディター内で Vue コンポーネントをレンダリングするために必要なことは次のとおりです。</p>

<ol>
<li>
<a href="/guide/custom-extensions">ノード拡張を作成する</a>
</li>
<li>Vue コンポーネントを作成します</li>
<li>そのコンポーネントを提供された <code>VueNodeViewRenderer</code> に渡します</li>
<li>
<code>addNodeView()</code> に登録します</li>
<li>
<a href="/guide/configuration">新しいノード拡張を使用するように Tiptap を構成する</a>
</li>
</ol>
<p>ノード拡張は次のようになります。</p>

<pre><code class="language-js">
export default Node.create({
  // configuration …

  addNodeView() {
    return VueNodeViewRenderer(Component)
  },
})
</code></pre>

<p>この作業を行うには、少し魔法が必要です。 ただし、心配しないでください。簡単に開始するために使用できるラッパーコンポーネントが用意されています。 以下に示すように、カスタムVueコンポーネントに追加することを忘れないでください。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;node-view-wrapper&gt;
    Vue Component
  &lt;/node-view-wrapper&gt;
&lt;/template&gt;
</code></pre>

<p>次に実際の動作を見てみましょう。 開始するには、以下の例をコピーしてください。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/VueComponent">https://embed.tiptap.dev/preview/GuideNodeViews/VueComponent</a></p>

<p>ただし、そのコンポーネントはエディタと相互作用しません。 それを配線する時間。</p>
<h2>アクセスノードの属性</h2>

<p>ノード拡張で使用する<code>VueNodeViewRenderer</code> は、いくつかの非常に役立つ小道具をカスタムVueコンポーネントに渡します。 それらの1つは <code>node</code> プロップです。 このスニペットを Vue コンポーネントに追加して、ノードに直接アクセスします。</p>
<pre><code class="language-js">props: {
  node: {
    type: Object,
    required: true,
  },
},
</code></pre>

<p>これにより、Vue コンポーネントのノード属性にアクセスできます。ノード拡張機能に <code>count</code> という名前の<a href="/guide/custom-extensions#attributes">属性を追加</a> したとします（上記の例で行ったように）。次のようにアクセスできます。</p>
<pre><code class="language-js">this.node.attrs.count
</code></pre>
<h2>ノード属性を更新する</h2>
<p>コンポーネントに渡された <code>updateAttributes</code> プロップを使用して、ノードからノード属性を更新することもできます。このスニペットをコンポーネントに追加するだけです。</p>

<pre><code class="language-js">props: {
  updateAttributes: {
    type: Function,
    required: true,
  },
},
</code></pre>

<p>更新された属性を持つオブジェクトを関数に渡します。</p>
<pre><code class="language-js">this.updateAttributes({
  count: this.node.attrs.count + 1,
})
</code></pre>

<p>そして、はい、それもすべて反応的です。かなり見苦しいコミュニケーションですね。</p>
<h2>編集可能なコンテンツを追加する</h2>
<p>ノードビューに編集可能なコンテンツを追加するのに役立つ <code>NodeViewContent</code> と呼ばれる別のコンポーネントがあります。次に例を示します。</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;node-view-wrapper class=&quot;dom&quot;&gt;
    &lt;node-view-content class=&quot;content-dom&quot; /&gt;
  &lt;/node-view-wrapper&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    NodeViewWrapper,
    NodeViewContent,
  },
}
&lt;/script&gt;
</code></pre>

<p>これらの <code>class</code> 属性を追加したり、削除したり、他のクラス名を渡したりする必要はありません。次の例で試してみてください。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/VueComponentContent">https://embed.tiptap.dev/preview/GuideNodeViews/VueComponentContent</a></p>

<p>このコンテンツはTiptapによってレンダリングされることに注意してください。つまり、許可されているコンテンツの種類を指定する必要があります。たとえば、ノード拡張に <code>content: 'inline *'</code> を使用します（上記の例ではこれを使用しています）。</p>

<p><code>NodeViewWrapper</code> および <code>NodeViewContent</code> コンポーネントは <code>&lt;div&gt;</code> HTML タグ（インラインノードの場合は <code>&lt;span&gt;</code>）をレンダリングしますが、これは変更できます。たとえば、  <code>&lt;node-view-content as=&quot;p&quot;&gt;</code> は段落をレンダリングする必要があります。ただし、1つの制限：そのタグは実行時に変更してはなりません。</p>
<h2>利用可能なすべてのプロップ</h2>
<p>高度なユースケースでは、コンポーネントにさらにいくつかのプロップを渡します。</p>

<h3>editor</h3>

<p>エディターインスタンス。</p>
<h3>node</h3>

<p>現在のノードにアクセスします。</p>
<h3>decorations</h3>

<p>装飾の配列。</p>
<h3>selected</h3>

<p>現在のノードビューに <code>NodeSelection</code> がある場合は <code>true</code>。</p>
<h3>extension</h3>

<p>たとえば、オプションを取得するためのノード拡張へのアクセス。</p>
<h3>getPos()</h3>

<p>現在のノードのドキュメント位置を取得します。</p>
<h3>updateAttributes()</h3>

<p>現在のノードの属性を更新します。</p>
<h3>deleteNode()</h3>


<p>現在のノードを削除します。</p>
<p>これがあなたが期待できる小道具の完全なリストです</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;node-view-wrapper /&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  components: {
    NodeViewWrapper,
  },

  props: {
    // the editor instance
    editor: {
      type: Object,
    },

    // the current node
    node: {
      type: Object,
    },

    // an array of decorations
    decorations: {
      type: Array,
    },

    // `true` when there is a `NodeSelection` at the current node view
    selected: {
      type: Boolean,
    },

    // access to the node extension, for example to get options
    extension: {
      type: Object,
    },

    // get the document position of the current node
    getPos: {
      type: Function,
    },

    // update attributes of the current node
    updateAttributes: {
      type: Function,
    },

    // delete the current node
    deleteNode: {
      type: Function,
    },
  },
}
&lt;/script&gt;
</code></pre>

<p>ノードビューをドラッグ可能にするには、拡張機能で「draggable: true」を設定し、ドラッグハンドルとして機能する DOM 要素に「data-drag-handle」を追加します。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle">https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle</a></p>
<h1>例</h1>
<h2>はじめに</h2>


<p>ノードビューを使用すると、ノードを完全にカスタマイズできます。ここでは、いくつかの異なる例を収集しています。それらを自由にコピーして、それらの上に構築を開始してください。</p>
<p>これらは開始するための単なる例であり、公式にサポートされている拡張機能ではないことに注意してください。それらのテストはありません。また、公式の拡張機能と同じように注意を払って維持する予定もありません。</p>
<h2>ドラッグの取り扱い</h2>

<p>ドラッグの取り扱いを追加するのはそれほど簡単ではありません。それらを追加するための最良の方法は、まだ検討中です。公式サポートはいつか来る予定ですが、まだタイムラインはありません。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle">https://embed.tiptap.dev/preview/GuideNodeViews/DragHandle</a></p>
<h2>目次</h2>

<p>これはエディターのコンテンツをループし、すべての見出しに ID を与え、Vue を使用して目次をレンダリングします。</p>
<p><a href="https://embed.tiptap.dev/preview/GuideNodeViews/TableOfContents">https://embed.tiptap.dev/preview/GuideNodeViews/TableOfContents</a></p>
<h2>エディターでの描画</h2>
<p>描画例は、エディター内での描画を可能にする SVG を示しています。</p>

<p><a href="https://embed.tiptap.dev/preview/Examples/Drawing">https://embed.tiptap.dev/preview/Examples/Drawing</a></p>

<p>コラボレーション拡張機能ではうまく機能していません。すべての変更についてすべてのデータを送信しますが、Y.js ではかなり大きくなる可能性があります。これら 2つを組み合わせて使用​​する場合は、改善する必要があります。そうしないと、WebSocket バックエンドが溶けてしまいます。</p>
<h1>TypeScript の操作</h1>
<h2>はじめに</h2>


<p>Tiptap コードベース全体は TypeScript で書かれています。聞いたことがない、または使用したことがない場合でも、心配はいりません。する必要はありません。</p>
<p>TypeScript は、型を追加することで JavaScript を拡張します（そのため、名前が付けられています）。 Vanilla JavaScript には存在しない新しい構文を追加します。ブラウザで実行する前に実際に削除されますが、バグを早期に発見するには、この手順（コンパイル）が重要です。適切なタイプのデータを関数に渡すかどうかをチェックします。大規模で複雑なプロジェクトの場合、それは非常に価値があります。これは、コードを送信する前に、多くのバグが通知されることを意味します。</p>


<p><strong>とにかく、プロジェクトでTypeScriptを使用しない場合は、それで問題ありません。</strong> それでも、Tiptap を使用できますが、Tiptap API の優れたオートコンプリートを取得できます（エディターがサポートしている場合、ほとんどの場合はサポートしています）。</p>
<p>プロジェクトで TypeScript を使用していて、Tiptap を拡張したい場合は、知っておくと便利な2つのタイプがあります。</p>
<h2>タイプ</h2>
<h3>オプションタイプ</h3>
<p>拡張機能のデフォルトオプションを拡張または作成するには、カスタムタイプを定義する必要があります。次に例を示します。</p>

<pre><code class="language-ts">
export interface CustomExtensionOptions {
  awesomeness: number,
}

const CustomExtension = Extension.create&lt;CustomExtensionOptions&gt;({
  addOptions() {
    return {
      awesomeness: 100,
    }
  },
})
</code></pre>
<h3>ストレージタイプ</h3>
<p>拡張ストレージにタイプを追加するには、それを2番目のタイプパラメータとして渡す必要があります。</p>

<pre><code class="language-ts">
export interface CustomExtensionStorage {
  awesomeness: number,
}

const CustomExtension = Extension.create&lt;{}, CustomExtensionStorage&gt;({
  name: 'customExtension',

  addStorage() {
    return {
      awesomeness: 100,
    }
  },
})
</code></pre>

<p>拡張機能の外部でストレージを使用する場合は、タイプを手動で設定する必要があります。</p>
<pre><code>
const customStorage = editor.storage.customExtension as CustomExtensionStorage
</code></pre>
<h3>コマンドタイプ</h3>
<p>コアパッケージは <code>Command</code> タイプもエクスポートします。これは、コードで指定するすべてのコマンドに追加する必要があります。次に例を示します。</p>

<pre><code class="language-ts">
declare module '@tiptap/core' {
  interface Commands&lt;ReturnType&gt; {
    customExtension: {
      /**
       * Comments will be added to the autocomplete.
       */
      yourCommand: (someProp: any) =&gt; ReturnType,
    }
  }
}

const CustomExtension = Extension.create({
  addCommands() {
    return {
      yourCommand: someProp =&gt; ({ commands }) =&gt; {
        // …
      },
    }
  },
})
</code></pre>
<p>基本的にはそれだけです。残りはすべて自動的に行います。</p>

<h1>はじめに</h1>

<p>Tiptap は、<a href="https://ProseMirror.net">ProseMirror</a> のフレンドリーなラッパーです。 Tiptap は ProseMirror の複雑さのほとんどを隠そうとしますが、API の上に構築されているため、高度な使用法については <a href="https://ProseMirror.net/docs/guide/">ProseMirror ガイド</a> を読むことをお勧めします。</p>
<h3>構造</h3>
<p>ProseMirror は、ドキュメントの許可された構造を定義する厳密な <a href="/api/schema">Schema</a> で動作します。ドキュメントは、見出し、段落、その他の要素のツリー、いわゆるノードです。マークはノードに付けることができます。 g。その一部を強調します。<a href="/api/commands">Commands</a> プログラムでそのドキュメントを変更します。</p>

<h3>コンテンツ</h3>
<p>ドキュメントは状態で保存されます。すべての変更は、トランザクションとして状態に適用されます。状態には、現在のコンテンツ、カーソル位置、および選択に関する詳細が含まれます。いくつかの異なる <a href="/api/events">events</a> にフックして、たとえば、トランザクションが適用される前にトランザクションを変更することができます。</p>

<h3>拡張機能</h3>
<p>拡張機能は、<a href="/api/nodes">nodes</a>、<a href="/api/marks">marks</a> または <a href="/api/extensions">functionalities</a> をエディターに追加します。これらの拡張機能の多くは、コマンドを一般的な<a href="/api/keyboard-shortcuts">キーボードショートカット</a> にバインドしていました。</p>

<h2>用語</h2>
<p>ProseMirror には独自の語彙があり、時々それらすべての単語に出くわします。これは、ドキュメントで使用する最も一般的な単語の概要です。</p>

<table>
<thead>
<tr>
<th>用語</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schema</td>
<td>コンテンツが持つことができる構造を構成</td>
</tr>
<tr>
<td>Document</td>
<td>ドキュメント</td>
</tr>
<tr>
<td>State</td>
<td>現在のコンテンツとエディターの選択を説明するためのすべて</td>
</tr>
<tr>
<td>Transaction</td>
<td>状態の変更（更新された選択、コンテンツなど）</td>
</tr>
<tr>
<td>Extension</td>
<td>新しい機能を登録</td>
</tr>
<tr>
<td>Node</td>
<td>見出しや段落などのコンテンツのタイプ</td>
</tr>
<tr>
<td>Mark</td>
<td>インラインフォーマットなどのノードに適用</td>
</tr>
<tr>
<td>Command</td>
<td>エディター内でアクションを実行すると、どういうわけか状態が変わる</td>
</tr>
<tr>
<td>Decoration</td>
<td>例として、間違いを強調するためにドキュメントの上にスタイリング</td>
</tr>
</tbody>
</table>
<h1>エディター</h1>
<h2>はじめに</h2>

<p>このクラスは、Tiptap の中心的な構成要素です。これは、<a href="https://ProseMirror.net/docs/ref/#view.EditorView"><code>EditorView</code></a> の作成など、機能する <a href="https://ProseMirror.net/">ProseMirror</a> エディターを作成するための手間のかかる作業のほとんどを実行します）。初期設定 <a href="https://ProseMirror.net/docs/ref/#state.Editor_State"><code>EditorState</code></a> などを設定します。</p>
<h2>メソッド</h2>
<p>エディターインスタンスは、一連のパブリックメソッドを提供します。メソッドは通常の関数であり、何でも返すことができます。編集者との共同作業に役立ちます。</p>
<p>メソッドを <a href="/api/commands">コマンド</a> と混同しないでください。コマンドは、エディターの状態（コンテンツ、選択など）を変更し、<code>true</code> または <code>false</code> のみを返すために使用されます。</p>


<h3>can()</h3>

<p>コマンドまたはコマンドチェーンを実際に実行せずに実行できるかどうかを確認します。ボタンを「有効 / 無効」または「表示 / 非表示」にするのに非常に役立ちます。</p>
<pre><code class="language-js">// Returns `true` if the undo command can be executed
editor.can().undo()
</code></pre>
<h3>chain()</h3>

<p>一度に複数のコマンドを呼び出すコマンドチェーンを作成します。</p>
<pre><code class="language-js">// Execute two commands at once
editor.chain().toggleBold().focus().run()
</code></pre>
<h3>destroy()</h3>

<p>エディタインスタンスを停止し、すべてのイベントのバインドを解除します。</p>
<pre><code class="language-js">// Hasta la vista, baby!
editor.destroy()
</code></pre>
<h3>getHTML()</h3>

<p>現在のエディタドキュメントを HTML として返します</p>
<pre><code class="language-js">editor.getHTML()
</code></pre>
<h3>getJSON()</h3>

<p>現在のエディタードキュメントを JSON として返します。</p>
<pre><code class="language-js">editor.getJSON()
</code></pre>
<h3>getText()</h3>

<p>現在のエディタドキュメントをプレーンテキストとして返します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>options</td>
<td>{ blockSeparator?: string, textSerializers?: Record&lt;string, TextSerializer&gt;}</td>
<td>シリアル化のオプション</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">// Give me plain text!
editor.getText()
// Add two line breaks between nodes
editor.getText({ blockSeparator: &quot;\n\n&quot; })
</code></pre>
<h3>getAttributes()</h3>

<p>現在選択されているノードまたはマークの属性を取得します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>typeOrName</td>
<td>string | NodeType | MarkType</td>
<td>ノード、またはマークの名前</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">editor.getAttributes('link').href
</code></pre>
<h3>isActive()</h3>

<p>現在選択されているノードまたはマークがアクティブかどうかを返します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string | null</td>
<td>Name of the node or mark</td>
</tr>
<tr>
<td>attributes</td>
<td>Record&lt;string, any&gt;</td>
<td>Attributes of the node or mark</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">// Check if it’s a heading
editor.isActive('heading')
// Check if it’s a heading with a specific attribute value
editor.isActive('heading', { level: 2 })
// Check if it has a specific attribute value, doesn’t care what node/mark it is
editor.isActive({ textAlign: 'justify' })
</code></pre>
<h3>registerPlugin()</h3>

<p>ProseMirror プラグインを登録</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>plugin</td>
<td>Plugin</td>
<td>A ProseMirror plugin</td>
</tr>
<tr>
<td>handlePlugins?</td>
<td>(newPlugin: Plugin, plugins: Plugin[]) =&gt; Plugin[]</td>
<td>Control how to merge the plugin into the existing plugins</td>
</tr>
</tbody>
</table>
<h3>setOptions()</h3>

<p>エディターオプションを更新</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>options</td>
<td>Partial&lt;EditorOptions&gt;</td>
<td>A list of options</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">// Add a class to an existing editor instance
editor.setOptions({
  editorProps: {
    attributes: {
      class: 'my-custom-class',
    },
  },
})
</code></pre>
<h3>setEditable()</h3>

<p>エディターの編集可能な状態を更新</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>editable</td>
<td>boolean</td>
<td>ユーザーがエディターに書き込める必要がある場合は <code>true</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-js">// Make the editor read-only
editor.setEditable(false)
</code></pre>
<h3>unregisterPlugin()</h3>

<p>ProseMirror プラグインの登録を解除します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>タイプ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nameOrPluginKey</td>
<td>string | PluginKey</td>
<td>The plugins name</td>
</tr>
</tbody>
</table>
<h2>ゲッター</h2>
<h3>isEditable</h3>

<p>エディターが編集可能か読み取り専用かを返します。</p>
<pre><code class="language-js">editor.isEditable
</code></pre>
<h3>isEmpty</h3>

<p>コンテンツがあるかどうかを確認します。</p>
<pre><code class="language-js">editor.isEmpty
</code></pre>
<h2>設定</h2>
<h3>element</h3>

<p><code>element</code> は、エディタがバインドされるHTML要素を指定します。 次のコードは、Tiptapを <code>.element</code> クラスの要素と統合します。</p>
<pre><code class="language-js">
new Editor({
  element: document.querySelector('.element'),
  extensions: [
    StarterKit,
  ],
})
</code></pre>

<p>エディターを要素にマウントする前に、エディターを開始することもできます。これは、DOM がまだ利用できない場合に役立ちます。 <code>element</code> を省略してください。作成します。後日、次のようにコンテナに追加します。</p>
<pre><code class="language-js">yourContainerElement.append(editor.options.element)
</code></pre>
<h3>extensions</h3>
<p>段落のみを許可する場合でも、拡張機能のリストを <code>extensions</code> プロパティに渡す必要があります。</p>

<pre><code class="language-js">
new Editor({
  // Use the default extensions
  extensions: [
    StarterKit,
  ],

  // … or use specific extensions
  extensions: [
    Document,
    Paragraph,
    Text,
  ],

  // … or both
  extensions: [
    StarterKit,
    Highlight,
  ],
})
</code></pre>
<h3>content</h3>
<p><code>content</code> プロパティを使用すると、エディタの初期コンテンツを提供できます。これは HTML または JSON にすることができます。</p>

<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
  ],
})
</code></pre>
<h3>editable</h3>
<p><code>editable</code> プロパティは、ユーザーがエディターに書き込めるかどうかを決定します。</p>

<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
  ],
  editable: false,
})
</code></pre>
<h3>autofocus</h3>
<p><code>autofocus</code> を使用すると、初期化時にカーソルをエディター内で強制的にジャンプさせることができます。</p>

<table>
<thead>
<tr>
<th>Value</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'start'</code></td>
<td>ドキュメントの先頭にフォーカスを設定</td>
</tr>
<tr>
<td><code>'end'</code></td>
<td>ドキュメントの最後にフォーカスを設定</td>
</tr>
<tr>
<td><code>'all'</code></td>
<td>ドキュメント全体を選択</td>
</tr>
<tr>
<td><code>Number</code></td>
<td>ドキュメント内の特定の位置にフォーカスを設定</td>
</tr>
<tr>
<td><code>true</code></td>
<td>オートフォーカスを有効</td>
</tr>
<tr>
<td><code>false</code></td>
<td>オートフォーカスを無効</td>
</tr>
<tr>
<td><code>null</code></td>
<td>オートフォーカスを無効</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit,
  ],
  autofocus: false,
})
</code></pre>
<h3>enableInputRules</h3>
<p>By default, Tiptap enables all <a href="/guide/custom-extensions/#input-rules">input rules</a>. With <code>enableInputRules</code> you can control that.</p>
<p>デフォルトでは、Tiptap はすべての <a href="/guide/custom-extensions/#input-rules">入力ルール</a>を有効にします。 <code>enableInputRules</code> を使用すると、それを制御できます。</p>
<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
  ],
  enableInputRules: false,
})
</code></pre>

<p>または、特定の入力ルールのみを許可することもできます。</p>
<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
    Link,
  ],
  // pass an array of extensions or extension names
  // to allow only specific input rules
  enableInputRules: [Link, 'horizontalRule'],
})
</code></pre>
<h3>enablePasteRules</h3>
<p>By default, Tiptap enables all <a href="/guide/custom-extensions/#paste-rules">paste rules</a>. With <code>enablePasteRules</code> you can control that.</p>
<p>デフォルトでは、Tiptap はすべての<a href="/guide/custom-extensions/#paste-rules">貼り付けルール</a> を有効にします。 <code>enablePasteRules</code> を使用すると、それを制御できます。</p>
<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
  ],
  enablePasteRules: false,
})
</code></pre>

<p>または、特定の貼り付けルールのみを許可することもできます。</p>
<pre><code class="language-js">
new Editor({
  content: `&lt;p&gt;Example Text&lt;/p&gt;`,
  extensions: [
    StarterKit,
    Link,
  ],
  // pass an array of extensions or extension names
  // to allow only specific paste rules
  enablePasteRules: [Link, 'horizontalRule'],
})
</code></pre>
<h3>injectCSS</h3>

<p>デフォルトでは、Tiptap は <a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core/src/style.ts">少しのCSS</a> を挿入します。<code>injectCSS</code> を使用すると、それを無効にできます。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit,
  ],
  injectCSS: false,
})
</code></pre>
<h3>injectNonce</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy</a> を <code>nonce</code> で使用する場合、動的に作成された要素に追加する <code>nonce</code> を指定できます。次に例を示します。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    StarterKit,
  ],
  injectCSS: true,
  injectNonce: &quot;your-nonce-here&quot;
})
</code></pre>
<h3>editorProps</h3>

<p>高度なユースケースでは、<a href="https://prosemirror.net/docs/ref/#view.EditorProps">ProseMirror</a> によって処理される <code>editorProps</code> を渡すことができます。これを使用して、さまざまなエディターイベントをオーバーライドしたり、エディターの DOM 要素属性を変更したりできます。たとえば、いくつかの Tailwind クラスを追加できます。次に例を示します。</p>
<pre><code class="language-js">new Editor({
  // Learn more: https://prosemirror.net/docs/ref/#view.EditorProps
  editorProps: {
    attributes: {
      class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl mx-auto focus:outline-none',
    },
    transformPastedText(text) {
      return text.toUpperCase()
    }
  }
})
</code></pre>

<p>これを使用して、イベントハンドラーにフックし、カスタムの貼り付けハンドラー（たとえば）を渡すこともできます。</p>
<h3>parseOptions</h3>

<p>渡されたコンテンツは ProseMirror によって解析されます。解析にフックするには、<code>parseOptions</code> を渡すことができます。これは、<a href="https://prosemirror.net/docs/ref/#model.ParseOptions">ProseMirror</a> によって処理されます。</p>
<pre><code class="language-js">new Editor({
  // Learn more: https://prosemirror.net/docs/ref/#model.ParseOptions
  parseOptions: {
    preserveWhitespace: 'full',
  },
})
</code></pre>
<h1>コマンド</h1>
<h2>はじめに</h2>

<p>エディターには、コンテンツをプログラムで追加または変更したり、選択を変更したりするための多数のコマンドが用意されています。独自のエディターを作成したい場合は、間違いなくそれらについてもっと知りたいと思います。</p>
<h2>コマンドの実行</h2>
<p>使用可能なすべてのコマンドには、エディターインスタンスからアクセスできます。ユーザーがボタンをクリックしたときにテキストを太字にしたい場合は次のようになります。</p>

<pre><code class="language-js">editor.commands.setBold()
</code></pre>

<p>選択したものが太字になっていると思いますが、実際にコマンドを実行する際には <strong>1回の実行で複数のコマンドを変更する</strong> ことをお勧めします。それがどのように機能するかを見てみましょう。</p>
<h3>チェーンコマンド</h3>
<p>ほとんどのコマンドは、1つの呼び出しに組み合わせることができます。ほとんどの場合、これは個別の関数呼び出しよりも短くなります。選択したテキストを太字にする例を次に示します。</p>

<pre><code class="language-js">editor
  .chain()
  .focus()
  .toggleBold()
  .run()
</code></pre>



<p>新しいチェーンを開始するには <code>.chain()</code> が必要であり、その間のすべてのコマンドを実際に実行するには <code>.run()</code> が必要です。</p>
<p>上記の例では、2つの異なるコマンドが同時に実行されます。ユーザーがコンテンツの外側のボタンをクリックすると、エディターはフォーカスされなくなります。そのため、ほとんどのコマンドに <code>.focus()</code> 呼び出しを追加することをお勧めします。これにより、フォーカスがエディターに戻されるため、ユーザーは入力を続けることができます。</p>
<p>連鎖したコマンドはすべて、一種のキューに入れられます。それらは1つの単一のトランザクションに結合されます。つまり、コンテンツは 1回だけ更新され、<code>update</code> イベントも1回だけトリガーされます。</p>
<h4>カスタムコマンド内のチェーン</h4>
<p>コマンドを連鎖させると、トランザクションは保留されます。カスタムコマンド内でコマンドをチェーンする場合は、上記のトランザクションを使用して追加する必要があります。これを行う方法は次のとおりです。</p>

<pre><code class="language-js">addCommands() {
  return {
    customCommand: attributes =&gt; ({ chain }) =&gt; {
      // Doesn’t work:
      // return editor.chain() …

      // Does work:
      return chain()
        .insertContent('foo!')
        .insertContent('bar!')
        .run()
    },
  }
}
</code></pre>
<h3>インライン コマンド</h3>

<p>場合によっては、コマンドにさらにロジックを含めると便利です。そのため、コマンドでコマンドを実行できます。クレイジーに聞こえるかもしれませんが、例を見てみましょう。</p>
<pre><code class="language-js">editor
  .chain()
  .focus()
  .command(({ tr }) =&gt; {
    // manipulate the transaction
    tr.insertText('hey, that’s cool!')

    return true
  })
  .run()
</code></pre>
<h3>コマンドのドライラン</h3>

<p>場合によっては、実際にコマンドを実行したくないが、メニューのボタンを表示または非表示にするなど、コマンドを実行できるかどうかしかわからないことがあります。そのために <code>.can()</code> を追加しました。このメソッドの後に続くものはすべて、ドキュメントに変更を適用せずに実行されます。</p>
<pre><code class="language-js">editor
  .can()
  .toggleBold()
</code></pre>

<p>また、<code>.chain()</code> と併用することもできます。すべてのコマンドを適用できるかどうかを確認する例を次に示します。</p>
<pre><code class="language-js">editor
  .can()
  .chain()
  .toggleBold()
  .toggleItalic()
  .run()
</code></pre>



<p>コマンドを適用できる場合は両方の呼び出しで <code>true</code> が返され、適用できない場合は
<code>false</code> が返されます。</p>
<p>カスタムコマンドでそれを機能させるために、<code>true</code> または <code>false</code> を返すことを忘れないでください。</p>
<p>独自のコマンドのいくつかについては、生の<a href="/api/introduction">transaction</a> を使用することをお勧めします。それらを <code>.can()</code> で機能させるには、トランザクションをディスパッチする必要があるかどうかを確認する必要があります。簡単な <code>.insertText()</code> コマンドを作成する方法は次のとおりです。</p>
<pre><code class="language-js">export default (value) =&gt; ({ tr, dispatch }) =&gt; {
  if (dispatch) {
    tr.insertText(value)
  }

  return true
}
</code></pre>

<p>別の Tiptap コマンドをラップするだけの場合は、それをチェックする必要はありません。私たちが自動的に行います。</p>
<pre><code class="language-js">addCommands() {
  return {
    bold: () =&gt; ({ commands }) =&gt; {
      return commands.toggleMark('bold')
    },
  }
}
</code></pre>

<p>プレーンな ProseMirror コマンドをラップするだけの場合は、とにかく <code>dispatch</code> を渡す必要があります。次に、それをチェックする必要もありません。</p>
<pre><code class="language-js">
export default () =&gt; ({ state, dispatch }) =&gt; {
  return exitCode(state, dispatch)
}
</code></pre>
<h3>コマンドを試す</h3>
<p>コマンドのリストを実行したいが、最初に成功したコマンドのみを適用したい場合は、<code>.first()</code> メソッドを使用してこれを行うことができます。このメソッドは次々にコマンドを実行し、最初に停止して <code>true</code> を返します。</p>
<p>たとえば、バックスペースキーは最初に入力ルールを元に戻そうとします。それが成功した場合、それはそこで止まります。入力ルールが適用されておらず、元に戻せない場合は、次のコマンドを実行し、選択範囲がある場合は削除します。簡略化した例を次に示します。</p>


<pre><code class="language-js">editor.first(({ commands }) =&gt; [
  () =&gt; commands.undoInputRule(),
  () =&gt; commands.deleteSelection(),
  // …
])
</code></pre>

<p>コマンド内では、次のような同じことを行うことができます。</p>
<pre><code class="language-js">export default () =&gt; ({ commands }) =&gt; {
  return commands.first([
    () =&gt; commands.undoInputRule(),
    () =&gt; commands.deleteSelection(),
    // …
  ])
}
</code></pre>
<h2>コマンドのリスト</h2>
<p>以下にリストされているすべてのコアコマンドを見てください。彼らはあなたに何が可能かについての良い第一印象を与えるはずです。</p>

<h3>コンテンツ</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>説明</th>
<th>リンク</th>
</tr>
</thead>
<tbody>
<tr>
<td>clearContent()</td>
<td>ドキュメント全体をクリア</td>
<td><a href="/api/commands/clear-content">詳細</a></td>
</tr>
<tr>
<td>insertContent()</td>
<td>現在の位置にHTMLのノードまたは文字列を挿入</td>
<td><a href="/api/commands/insert-content">詳細</a></td>
</tr>
<tr>
<td>insertContentAt()</td>
<td>HTMLのノードまたは文字列を特定の位置に挿入</td>
<td><a href="/api/commands/insert-content-at">詳細</a></td>
</tr>
<tr>
<td>setContent()</td>
<td>ドキュメント全体を新しいコンテンツに置き換え</td>
<td><a href="/api/commands/set-content">詳細</a></td>
</tr>
</tbody>
</table>
<h3>ノードとマーク</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>説明</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>clearNodes()</td>
<td>ノードを単純な段落に正規化</td>
<td><a href="/api/commands/clear-nodes">詳細</a></td>
</tr>
<tr>
<td>createParagraphNear()</td>
<td>近くに段落を作成</td>
<td><a href="/api/commands/create-paragraph-near">詳細</a></td>
</tr>
<tr>
<td>deleteNode()</td>
<td>ノードを削除</td>
<td><a href="/api/commands/delete-node">詳細</a></td>
</tr>
<tr>
<td>extendMarkRange()</td>
<td>テキスト選択を現在のマークまで拡張</td>
<td><a href="/api/commands/extend-mark-range">詳細</a></td>
</tr>
<tr>
<td>exitCode()</td>
<td>コードブロックを終了</td>
<td><a href="/api/commands/exit-code">詳細</a></td>
</tr>
<tr>
<td>joinBackward()</td>
<td>2つのノードを逆方向に結合</td>
<td><a href="/api/commands/join-backward">詳細</a></td>
</tr>
<tr>
<td>joinForward()</td>
<td>2つのノードを前方に結合</td>
<td><a href="/api/commands/join-forward">詳細</a></td>
</tr>
<tr>
<td>lift()</td>
<td>既存のラップを削除</td>
<td><a href="/api/commands/lift">詳細</a></td>
</tr>
<tr>
<td>liftEmptyBlock()</td>
<td>空の場合はブロックを持ち上げ</td>
<td><a href="/api/commands/lift-empty-block">詳細</a></td>
</tr>
<tr>
<td>newlineInCode()</td>
<td>コードに改行文字を追加</td>
<td><a href="/api/commands/newline-in-code">詳細</a></td>
</tr>
<tr>
<td>resetAttributes()</td>
<td>一部のノードまたはマーク属性をデフォルト値にリセット</td>
<td><a href="/api/commands/reset-attributes">詳細</a></td>
</tr>
<tr>
<td>setMark()</td>
<td>新しい属性でマークを追加</td>
<td><a href="/api/commands/set-mark">詳細</a></td>
</tr>
<tr>
<td>setNode()</td>
<td>指定された範囲をノードに置き換え</td>
<td><a href="/api/commands/set-node">詳細</a></td>
</tr>
<tr>
<td>splitBlock()</td>
<td>既存のノードから新しいノードをフォーク</td>
<td><a href="/api/commands/split-block">詳細</a></td>
</tr>
<tr>
<td>toggleMark()</td>
<td>マークのオンとオフを切り替え</td>
<td><a href="/api/commands/toggle-mark">詳細</a></td>
</tr>
<tr>
<td>toggleNode()</td>
<td>ノードを別のノードと切り替え</td>
<td><a href="/api/commands/toggle-node">詳細</a></td>
</tr>
<tr>
<td>toggleWrap()</td>
<td>ノードを別のノードでラップするか、既存のラップを削除</td>
<td><a href="/api/commands/toggle-wrap">詳細</a></td>
</tr>
<tr>
<td>undoInputRule()</td>
<td>入力ルールを元に戻す</td>
<td><a href="/api/commands/undo-input-rule">詳細</a></td>
</tr>
<tr>
<td>unsetAllMarks()</td>
<td>現在の選択のすべてのマークを削除します。</td>
<td>[詳細]（/ api / Commands / unset-all-m</td>
</tr>
<tr>
<td>unsetMark()</td>
<td>現在の選択のマークを削除</td>
<td><a href="/api/commands/unset-mark">詳細</a></td>
</tr>
<tr>
<td>updateAttributes()</td>
<td>ノードまたはマークの属性を更新</td>
<td><a href="/api/commands/update-attributes">詳細</a></td>
</tr>
</tbody>
</table>
<h3>リスト</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>説明</th>
<th>リンク</th>
</tr>
</thead>
<tbody>
<tr>
<td>liftListItem()</td>
<td>リストアイテムをラッピングリストに持ち上げ</td>
<td><a href="/api/commands/lift-list-item">詳細</a></td>
</tr>
<tr>
<td>sinkListItem()</td>
<td>リストアイテムを内側のリストに沈める</td>
<td><a href="/api/commands/sink-list-item">詳細</a></td>
</tr>
<tr>
<td>splitListItem()</td>
<td>1つのリストアイテムを2つのリストアイテムに分割</td>
<td><a href="/api/commands/split-list-item">詳細</a></td>
</tr>
<tr>
<td>toggleList()</td>
<td>異なるリストタイプを切り替え</td>
<td><a href="/api/commands/toggle-list">詳細</a></td>
</tr>
<tr>
<td>wrapInList()</td>
<td>リスト内のノードをラップ</td>
<td><a href="/api/commands/wrap-in-list">詳細</a></td>
</tr>
</tbody>
</table>
<h3>選択</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>選択</th>
<th>リンク</th>
</tr>
</thead>
<tbody>
<tr>
<td>blur()</td>
<td>エディターからフォーカスを削除</td>
<td><a href="/api/commands/blur">詳細</a></td>
</tr>
<tr>
<td>deleteRange()</td>
<td>指定された範囲を削除</td>
<td><a href="/api/commands/delete-range">詳細</a></td>
</tr>
<tr>
<td>deleteSelection()</td>
<td>Delete the selection, if there is one.</td>
<td><a href="/api/commands/delete-selection">詳細</a></td>
</tr>
<tr>
<td>enter()</td>
<td>Trigger enter.</td>
<td><a href="/api/commands/enter">詳細</a></td>
</tr>
<tr>
<td>focus()</td>
<td>Focus the editor at the given position.</td>
<td><a href="/api/commands/focus">詳細</a></td>
</tr>
<tr>
<td>keyboardShortcut()</td>
<td>Trigger a keyboard shortcut.</td>
<td><a href="/api/commands/keyboard-shortcut">詳細</a></td>
</tr>
<tr>
<td>scrollIntoView()</td>
<td>Scroll the selection into view.</td>
<td><a href="/api/commands/scroll-into-view">詳細</a></td>
</tr>
<tr>
<td>selectAll()</td>
<td>Select the whole document.</td>
<td><a href="/api/commands/select-all">詳細</a></td>
</tr>
<tr>
<td>selectNodeBackward()</td>
<td>Select a node backward.</td>
<td><a href="/api/commands/select-node-backward">詳細</a></td>
</tr>
<tr>
<td>selectNodeForward()</td>
<td>Select a node forward.</td>
<td><a href="/api/commands/select-node-forward">詳細</a></td>
</tr>
<tr>
<td>selectParentNode()</td>
<td>Select the parent node.</td>
<td><a href="/api/commands/select-parent-node">詳細</a></td>
</tr>
<tr>
<td>setNodeSelection()</td>
<td>Creates a NodeSelection.</td>
<td><a href="/api/commands/set-node-selection">詳細</a></td>
</tr>
<tr>
<td>setTextSelection()</td>
<td>Creates a TextSelection.</td>
<td><a href="/api/commands/set-text-selection">詳細</a></td>
</tr>
</tbody>
</table>

<h2>独自のコマンドを書く</h2>

<p>すべての拡張機能は、コマンドを追加でき（ほとんどの場合、追加できます）、特定の <a href="/api/nodes">提供されたノードのドキュメント</a>、[マーク]（/ api /マーク）、および  <a href="/api/marks">拡張機能</a> を確認できます。 それらについてもっと学ぶために。 もちろん、カスタムコマンドを使用して<a href="/guide/custom-extensions">カスタム拡張機能を追加</a> することもできます。</p>

<p>しかし、これらのコマンドをどのように記述しますか？ それについて学ぶことが少しあります。</p>


<blockquote>
<p>pro <strong>おっと、これは仕掛品です</strong>
適切に作成されたドキュメントには、詳細に注意を払い、プロジェクトを十分に理解し、作成する時間が必要です。</p>
</blockquote>

<p>Tiptap は世界中の何千もの開発者によって使用されていますが、それでも私たちにとっては副次的なプロジェクトです。 それを変えて、オープンソースを私たちのフルタイムの仕事にしましょう！ 300 近くのスポンサーがいるので、私たちはすでに中途半端です。</p>

<p>それらに参加してスポンサーになりましょう！ オープンソースにより多くの時間を費やせるようにしてください。このページに記入して、最新の状態に保ちます。</p>
<p><a href="https://github.com/sponsors/ueberdosis">GitHub でスポンサーになる →</a>
:::</p>
<h1>blur</h1>
<p>このコマンドは、エディターからフォーカスを削除します。</p>

<p>参照 : <a href="/api/commands/focus">focus</a></p>
<h2>使い方</h2>
<pre><code class="language-js">// Remove the focus from the editor
editor.commands.blur()
</code></pre>
<h1>clearContent</h1>
<p><code>clearContent</code> コマンドは現在のドキュメントを削除します。</p>
<p>エディターは構成されたスキーマを適用し、ドキュメントは「null」にならないことに注意してください。 デフォルトの <a href="/api/nodes/document"><code>Document</code></a> は、デフォルトで段落である少なくとも 1つのブロックノードを持つことを想定しています。 言い換えると、そのコマンドを実行した後でも、ドキュメントには少なくとも 1つの（空の）段落があります。</p>


<p>参照 : <a href="/api/commands/set-content">setContent</a>, <a href="/api/commands/insert-content">insertContent</a></p>
<h2>パラメータ</h2>
<p><code>emitUpdate: boolean (false)</code></p>

<p>デフォルトでは、更新イベントはトリガーされません。<code>true</code> を渡しても、更新イベントのトリガーは妨げられません。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Remove all content from the document
editor.commands.clearContent()

// Remove all content, and trigger the `update` event
editor.commands.clearContent(true)
</code></pre>
<h1>clearNodes</h1>
<p><code>clearNodes</code> コマンドは、ノードをデフォルトノード（デフォルトでは段落）に正規化します。 あらゆる種類のリストを正規化することもできます。 高度なユースケースでは、新しいノードタイプを適用する前に便利です。</p>
<p>デフォルトノードをどのように定義できるか疑問に思われる場合：<a href="/api/nodes/document"><code>Document</code></a> の <code>content</code> 属性の内容によって異なりますが、デフォルトでは <code>block+</code>（少なくとも1つのブロックノード）です。<a href="/api/nodes/paragraph"><code>Paragraph</code></a> ノードの優先度が最も高いため、最初に読み込まれるため、デフォルトのノードになります。</p>


<h2>使い方</h2>
<pre><code class="language-js">editor.commands.clearNodes()
</code></pre>
<h1>createParagraphNear</h1>

<p>ブロックノードが現在選択されている場合、 <code>createParagraphNear</code> コマンドは、現在選択されているブロックノードの後に空の段落を作成します。 選択したブロックノードがその親の最初の子である場合、新しい段落が現在の選択の前に挿入されます。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.createParagraphNear()
</code></pre>
<h1>deleteNode</h1>

<p><code>deleteNode</code> コマンドは、現在の選択範囲内のノードを削除します。 削除する必要のあるノードを見つけるには、文字列または <code>NodeType</code> の <code>typeOrName</code> 引数が必要です。 ノードを削除すると、ビューは自動的にカーソル位置までスクロールします。</p>
<h2>パラメータ</h2>
<p><code>typeOrName: string | NodeType</code></p>
<h2>使い方</h2>
<pre><code class="language-js">// deletes a paragraph node
editor.commands.deleteNode('paragraph')

// or

// deletes a custom node
editor.commands.deleteNode(MyCustomNode)
</code></pre>
<h1>deleteRange</h1>

<p><code>deleteRange</code> コマンドは、指定された範囲内のすべてを削除します。 タイプ <code>Range</code> の <code>range</code> 属性が必要です。</p>
<h2>パラメータ</h2>
<p><code>range: Range</code></p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.deleteRange({ from: 0, to: 12 })
</code></pre>
<h1>deleteSelection</h1>

<p><code>deleteSelection</code> コマンドは、現在選択されているノードを削除します。選択が存在しない場合、何も削除されません。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.deleteSelection()
</code></pre>
<h1>enter</h1>

<p><code>enter</code> コマンドは、プログラムで Enter をトリガーします。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.enter()
</code></pre>
<h1>exitCode</h1>

<p>選択が <code>code</code> 要素である場合、<code>exitCode</code> コマンドは現在の選択の後にデフォルトのブロックを作成し、カーソルを新しいブロックに移動します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.exitCode()
</code></pre>
<h1>extendMarkRange</h1>

<p><code>extendMarkRange</code> コマンドは、現在の選択範囲を拡張して、現在のマークを包含します。 現在の選択に指定されたマークがない場合、何も変更されません。</p>
<h2>パラメータ</h2>
<p><code>typeOrName: string | MarkType</code></p>
<p>マークの名前、またはタイプ。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>オプションで、拡張マークに含める必要のある属性を指定できます。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Expand selection to link marks
editor.commands.extendMarkRange('link')

// Expand selection to link marks with specific attributes
editor.commands.extendMarkRange('link', { href: 'https://google.com' })

// Expand selection to link mark and update attributes
editor
  .chain()
  .extendMarkRange('link')
  .updateAttributes('link', {
    href: 'https://duckduckgo.com'
  })
  .run()
</code></pre>
<h1>focus</h1>


<p>このコマンドは、フォーカスをエディターに戻します。</p>
<p>ユーザーがエディターの外側のボタンをクリックすると、ブラウザーはそのボタンにフォーカスを設定します。ほとんどのシナリオでは、エディターに再び焦点を合わせたいと思います。そのため、基本的にここのすべてのデモでそれを確認できます。</p>
<p>参照 : <a href="/api/commands/set-text-selection">setTextSelection</a>, <a href="/api/commands/blur">blur</a></p>
<h2>パラメータ</h2>
<p><code>position: 'start' | 'end' | 'all' | number | boolean | null (false)</code></p>

<p>デフォルトでは、カーソル位置（およびテキスト選択）が復元されます。カーソルを移動する位置も渡します。</p>
<p><code>options: { scrollIntoView: boolean }</code></p>

<p>フォーカス時にカーソルまでスクロールするかどうかを定義します。デフォルトは <code>true</code> です。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Set the focus to the editor
editor.commands.focus()

// Set the cursor to the first position
editor.commands.focus('start')

// Set the cursor to the last position
editor.commands.focus('end')

// Selects the whole document
editor.commands.focus('all')

// Set the cursor to position 10
editor.commands.focus(10)
</code></pre>
<h1>forEach</h1>

<p>アイテムの配列をループします。</p>
<h2>パラメータ</h2>
<p><code>items: any[]</code></p>

<p>アイテムの配列。</p>
<p><code>fn: (item: any, props: CommandProps &amp; { index: number }) =&gt; boolean</code></p>

<p>あなたのアイテムで何でもする機能。</p>
<h2>使い方</h2>
<pre><code class="language-js">const items = ['foo', 'bar', 'baz']

editor.commands.forEach(items, (item, { commands }) =&gt; {
  return commands.insertContent(item)
})
</code></pre>
<h1>insertContent</h1>

<p><code>insertContent</code>コマンドは、渡された値をドキュメントに追加します。</p>
<p>参照 : <a href="/api/commands/set-content">setContent</a>, <a href="/api/commands/clear-content">clearContent</a></p>
<h2>パラメーター</h2>
<p><code>value: Content</code></p>

<p>このコマンドは非常に柔軟性があり、プレーンテキスト、HTML、さらにはJSONを値として受け取ります。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Plain text
editor.commands.insertContent('Example Text')

// HTML
editor.commands.insertContent('&lt;h1&gt;Example Text&lt;/h1&gt;')

// HTML with trim white space
editor.commands.insertContent('&lt;h1&gt;Example Text&lt;/h1&gt;', 
{
  parseOptions: {
    preserveWhitespace: false,
  }
})

// JSON/Nodes
editor.commands.insertContent({
  type: 'heading',
  attrs: {
    level: 1,
  },
  content: [
    {
      type: 'text',
      text: 'Example Text',
    },
  ],
})

// Multiple nodes at once
editor.commands.insertContent([
  {
    type: 'paragraph',
    content: [
      {
        type: 'text',
        text: 'First paragraph',
      },
    ],
  },
  {
    type: 'paragraph',
    content: [
      {
        type: 'text',
        text: 'Second paragraph',
      },
    ],
  },
])
</code></pre>
<h1>insertContentAt</h1>

<p><code>insertContentAt</code> は、指定された位置または範囲に HTML の文字列またはノードを挿入します。 範囲が指定されている場合、新しいコンテンツは指定された範囲のコンテンツを新しいコンテンツに置き換えます。</p>
<h2>パラメータ</h2>
<p><code>position: number | Range</code></p>

<p>コンテンツが挿入される位置または範囲。</p>
<p><code>value: Content</code></p>

<p>挿入するコンテンツ。 HTMLの文字列またはノードにすることができます。</p>
<p><code>options: Record&lt;string, any&gt;</code></p>

<ul>
<li>updateSelection：選択範囲を新しく挿入されたコンテンツに移動するかどうかを制御します。</li>
<li>parseOptions：渡されたコンテンツは ProseMirror によって解析されます。 解析にフックするには、<code>parseOptions</code> を渡すことができます。これは、<a href="https://prosemirror.net/docs/ref/#model.ParseOptions">ProseMirror</a> によって処理されます。</li>
</ul>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.insertContentAt(12, '&lt;p&gt;Hello world&lt;/p&gt;', {
  updateSelection: true,
  parseOptions: {
    preserveWhitespace: 'full',
  }
})
</code></pre>
<h1>joinBackward</h1>

<p><code>joinBackward</code> コマンドは、現在の選択から2つのノードを逆方向に結合します。 選択範囲が空で、テキストブロックの先頭にある場合、 <code>joinBackward</code> は、そのブロックとその前のブロックとの間の距離を縮めようとします。</p>
<p><a href="https://prosemirror.net/docs/ref/#commands.joinBackward">参照</a></p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.joinBackward()
</code></pre>
<h1>joinForward</h1>

<p><code>joinBackward</code> コマンドは、現在の選択から2つのノードを逆方向に結合します。 選択範囲が空で、テキストブロックの先頭にある場合、 <code>joinBackward</code> は、そのブロックとその前のブロックとの間の距離を縮めようとします。</p>
<p><a href="https://prosemirror.net/docs/ref/#commands.joinForward">参照</a></p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.joinForward()
</code></pre>
<h1>keyboardShortcut</h1>

<p><code>keyboardShortcut</code> コマンドは、指定された名前で ShortcutEvent をトリガーしようとします。</p>
<h2>パラメーター</h2>
<p><code>name: String</code></p>

<p>トリガーへのショートカットの名前。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.keyboardShortcut('undo')
</code></pre>
<h1>liftEmptyBlock</h1>

<p>現在選択されているブロックが空のテキストブロックである場合は、可能であればそれを持ち上げます。 <strong>リフティング</strong> は、ブロックが現在のブロックの親に移動されることを意味します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.liftEmptyBlock()
</code></pre>
<h1>liftListItem</h1>

<p><code>liftListItem</code> は、現在の選択範囲の周りのリストアイテムをラップする親リストに持ち上げようとします。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.liftListItem()
</code></pre>
<h1>lift</h1>

<p><code>lift</code> コマンドは、特定のノードをその親ノードに持ち上げます。 <strong>リフティング</strong> は、ブロックが現在のブロックの親に移動されることを意味します。</p>
<h2>パラメータ</h2>
<p><code>typeOrName: String | NodeType</code></p>

<p>持ち上げる必要のあるノード。 現在の選択でノードが見つからない場合は、コマンドを無視してください。</p>
<p><code>attributes: Record&lt;string, any&gt;</code></p>

<p>ノードを解除する必要がある属性。 これは <strong>オプション</strong> です。</p>
<h2>使い方</h2>
<pre><code class="language-js">// lift any headline
editor.commands.lift('headline')

// lift only h2
editor.commands.lift('headline', { level: 2 })
</code></pre>
<h1>newlineInCode</h1>

<p><code>newlineInCode</code> は、現在のコードブロックに新しい行を挿入します。 選択範囲が設定されている場合、選択範囲は改行文字に置き換えられます。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.newlineInCode()
</code></pre>
<h1>resetAttributes</h1>

<p><code>resetAttributes</code> は、ノード属性の一部をデフォルトの属性にリセットします。</p>
<h2>パラメータ</h2>
<p><code>typeOrName: string | Node</code></p>

<p>リセットする必要のあるノード。 文字列またはノードにすることができます。</p>
<p><code>attributes: string | string[]</code></p>

<p>リセットする属性を定義する文字列または文字列の配列。</p>
<h2>使い方</h2>
<pre><code class="language-js">// reset the style and class attributes on the currently selected paragraph nodes
editor.commands.resetAttributes('paragraph', ['style', 'class'])
</code></pre>
<h1>scrollIntoView</h1>

<p><code>scrollIntoView</code> は、ビューを現在の選択またはカーソル位置にスクロールします。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.scrollIntoView()
</code></pre>
<h1>selectAll</h1>

<p>ドキュメント全体を一度に選択します。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Select the whole document
editor.commands.selectAll()
</code></pre>
<h1>selectNodeBackward</h1>

<p>選択範囲が空でテキストブロックの先頭にある場合、可能であれば、<code>selectNodeBackward</code> は現在のテキストブロックの前のノードを選択します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.selectNodeBackward()
</code></pre>
<h1>selectNodeForward</h1>

<p>選択範囲が空でテキストブロックの最後にある場合、可能であれば、<code>selectNodeForward</code> は現在のテキストブロックの後のノードを選択します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.selectNodeForward()
</code></pre>
<h1>selectParentNode</h1>

<p><code>selectParentNode</code> は、現在選択されているノードの親ノードを取得し、選択範囲をそのノードに移動しようとします。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.selectParentNode()
</code></pre>
<h1>selectTextblockEnd</h1>

<p>ブロックが有効なテキストブロックである場合、<code>selectTextblockEnd</code> はカーソルを現在のテキストブロックの最後に移動します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.selectTextblockEnd()
</code></pre>
<h1>selectTextblockStart</h1>

<p>ブロックが有効なテキストブロックである場合、<code>selectTextblockStart</code> はカーソルを現在のテキストブロックの先頭に移動します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.selectTextblockStart()
</code></pre>
<h1>setContent</h1>

<p><code>setContent</code> コマンドは、ドキュメントを新しいものに置き換えます。 JSON または HTML を渡すことができ、どちらも正常に機能します。基本的には、初期化時に「コンテンツ」を設定するのと同じです。</p>
<p>参照 : <a href="/api/commands/insert-content">insertContent</a>, <a href="/api/commands/clear-content">clearContent</a></p>
<h2>パラメータ</h2>
<p><code>content: string</code></p>

<p>文字列（JSONまたはHTML）を <a href="/api/schema">content</a> として渡します。エディターは、<a href="/api/schema">schema</a> に従って許可されているもののみをレンダリングします。</p>
<p><code>emitUpdate?: Boolean (false)</code></p>

<p>デフォルトでは、更新イベントはトリガーされません。<code>true</code> を渡しても、更新イベントのトリガーは妨げられません。</p>
<p><code>parseOptions?: Record&lt;string, any&gt;</code></p>

<p>解析を構成するためのオプションは、初期化中および / または setContent を使用して渡すことができます。 parseOptions の詳細については、<a href="https://prosemirror.net/docs/ref/#model.ParseOptions">ProseMirrorドキュメント</a> を参照してください。</p>
<h2>使い方</h2>
<pre><code class="language-js">// HTML
editor.commands.setContent('&lt;p&gt;Example Text&lt;/p&gt;')

// JSON
editor.commands.setContent({
  &quot;type&quot;: &quot;doc&quot;,
  &quot;content&quot;: [
    {
      &quot;type&quot;: &quot;paragraph&quot;,
      &quot;content&quot;: [
        {
          &quot;type&quot;: &quot;text&quot;,
          &quot;text&quot;: &quot;Example Text&quot;
        }
      ]
    }
  ]
})
</code></pre>
<h1>setMark</h1>

<p><code>setMark</code> コマンドは、現在の選択に新しいマークを追加します。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | MarkType</code></p>

<p>追加するマークのタイプ。 文字列または MarkType にすることができます。</p>
<p><code>attributes: Record&lt;string, any&gt;</code></p>

<p>マークに適用する必要のある属性。<strong>これはオプションです。</strong></p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.setMark(&quot;bold&quot;, { class: 'bold-tag' })
</code></pre>
<h1>setMeta</h1>

<p>現在のトランザクションにメタデータプロパティを保存します。</p>
<h2>パラメーター</h2>
<p><code>key: string</code></p>

<p>メタデータの名前。<a href="https://prosemirror.net/docs/ref/#state.Transaction.getMeta">getMeta</a> を使用すると、いつでもその値を取得できます。</p>
<p><code>value: any</code></p>

<p>メタデータ内に任意の値を保存します。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Prevent the update event from being triggered
editor.commands.setMeta('preventUpdate', true)

// Store any value in the current transaction.
// You can get this value at any time with tr.getMeta('foo').
editor.commands.setMeta('foo', 'bar')
</code></pre>
<h1>setNode</h1>

<p><code>setNode</code> コマンドは、指定された範囲を指定されたノードに置き換えます。 範囲は現在の選択によって異なります。 <strong>重要</strong>：現在、<code>setNode</code> はテキストブロックノードのみをサポートしています。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType</code></p>

<p>範囲を置き換えるノードのタイプ。 文字列または NodeType にすることができます。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>ノードに適用する必要がある属性。 <strong>これはオプションです。</strong></p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.setNode(&quot;paragraph&quot;, { id: &quot;paragraph-01&quot; })
</code></pre>
<h1>setNodeSelection</h1>

<p><code>setNodeSelection</code> は、指定された位置に新しい NodeSelection を作成します。 ノード選択は、単一のノードを指す選択です。 <a href="https://prosemirror.net/docs/ref/#state.NodeSelection">もっと見る</a></p>
<h2>パラメーター</h2>
<p><code>position: number</code></p>

<p>NodeSelection が作成される位置。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.setNodeSelection(10)
</code></pre>
<h1>setTextSelection</h1>

<p>エディターのコンテキストでの選択について考える場合、おそらくテキストの選択について考えるでしょう。<code>setTextSelection</code> を使用すると、そのテキスト選択を制御し、指定した範囲または位置に設定できます。</p>
<p>参照 : <a href="/api/commands/focus">focus</a>, <a href="/api/commands/set-node-selection">setNodeSelection</a>, <a href="/api/commands/delete-selection">deleteSelection</a>, <a href="/api/commands/select-all">selectAll</a></p>
<h2>パラメーター</h2>
<p><code>position: number | Range</code></p>

<p>数値または範囲を渡します（例：<code>{from：5 to：10}</code>）。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Set the cursor to the specified position
editor.commands.setTextSelection(10)

// Set the text selection to the specified range
editor.commands.setTextSelection({ from: 5, to: 10 })
</code></pre>
<h1>sinkListItem</h1>

<p><code>sinkListItem</code> は、現在の選択範囲の周りのリストアイテムをラッピングする子リストにシンクしようとします。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.liftListItem()
</code></pre>
<h1>splitBlock</h1>

<p><code>splitBlock</code> は、現在の <a href="https://prosemirror.net/docs/ref/#state.NodeSelection">NodeSelection</a> で現在のノードを2つのノードに分割します。 現在の選択が分割可能でない場合、コマンドは無視されます。</p>
<h2>パラメーター</h2>
<p><code>options: Record&lt;string, any&gt;</code></p>

<ul>
<li>
<code>keepMarks: boolean</code> - マークを保持するか削除するかを定義します。 デフォルトは <code>true</code> です。</li>
</ul>
<h2>使い方</h2>
<pre><code class="language-js">// split the current node and keep marks
editor.commands.splitBlock()

// split the current node and don't keep marks
editor.commands.splitBlock({ keepMarks: false })
</code></pre>
<h1>splitListItem</h1>

<p><code>splitListItem</code> は、1つのリストアイテムを2つの別々のリストアイテムに分割します。 これがネストされたリストである場合、ラッピングリストアイテムは分割する必要があります。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType</code></p>

<p>2つの別々のリスト項目に分割する必要があるノードのタイプ。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.splitListItem('bullet_list')
</code></pre>
<h1>toggleList</h1>

<p><code>toggleList</code>は、異なるタイプのリストを切り替えます。</p>
<h2>パラメーター</h2>
<p><code>listTypeOrName: string | NodeType</code></p>

<p>ラッピングリストに使用する必要があるノードのタイプ</p>
<p><code>itemTypeOrName: string | NodeType</code></p>

<p>リストアイテムに使用する必要があるノードのタイプ</p>
<h2>使い方</h2>
<pre><code class="language-js">// toggle a bullet list with list items
editor.commands.toggleList('bullet_list', 'list_item')

// toggle a numbered list with list items
editor.commands.toggleList('ordered_list', 'list_item')
</code></pre>
<h1>toggleMark</h1>

<p><code>toggleList</code> は、異なるタイプのリストを切り替えます。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | MarkType</code></p>

<p>切り替える必要のあるマークのタイプ。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>マークに適用する必要のある属性。 <strong>これはオプションです。</strong></p>
<p><code>options?: Record&lt;string, any&gt;</code></p>
<ul>
<li>
<code>extendEmptyMarkRange: boolean</code> - 現在の選択範囲全体でもマークを削除します。 デフォルトは <code>false</code> です</li>
</ul>


<h2>使い方</h2>
<pre><code class="language-js">// toggles a bold mark
editor.commands.toggleMark('bold')

// toggles bold mark with a color attribute
editor.commands.toggleMark('bold', { color: 'red' })

// toggles a bold mark with a color attribute and removes the mark across the current selection
editor.commands.toggleMark('bold', { color: 'red' }, { extendEmptyMarkRange: true })
</code></pre>
<h1>toggleNode</h1>

<p><code>toggleNode</code> は別のノードを持つノードになります。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType</code></p>

<p>切り替える必要のあるノードのタイプ。</p>
<p><code>toggleTypeOrName: string | NodeType</code></p>

<p>トグルに使用する必要があるノードのタイプ。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>ノードに適用する必要がある属性。 <strong>これはオプションです。</strong></p>
<h2>使い方</h2>
<pre><code class="language-js">// toggle a paragraph with a heading node
editor.commands.toggleNode('paragraph', 'heading', { level: 1 })

// toggle a paragraph with a image node
editor.commands.toggleNode('paragraph', 'image', { src: 'https://example.com/image.png' })
</code></pre>
<h1>toggleWrap</h1>

<p><code>toggleWrap</code>は、現在のノードを新しいノードでラップするか、ラップしているノードを削除します。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType</code></p>

<p>ラッピングノードに使用する必要があるノードのタイプ。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>ノードに適用する必要がある属性。<strong>これはオプションです。</strong></p>
<h2>使い方</h2>
<pre><code class="language-js">// toggle wrap the current selection with a heading node
editor.commands.toggleWrap('heading', { level: 1 })
</code></pre>
<h1>undoInputRule</h1>

<p><code>undoInputRule</code> は、トリガーされた最新の入力ルールを元に戻します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.undoInputRule()
</code></pre>
<h1>unsetAllMarks</h1>

<p><code>unsetAllMarks</code> は、現在の選択からすべてのマークを削除します。</p>
<h2>使い方</h2>
<pre><code class="language-js">editor.commands.unsetAllMarks()
</code></pre>
<h1>unsetMark</h1>

<p><code>unsetMark</code> は、現在の選択からマークを削除します。 現在の選択範囲全体のすべてのマークを削除することもできます。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | MarkType</code></p>

<p>削除する必要のあるマークのタイプ。</p>
<p><code>options?: Record&lt;string, any&gt;</code></p>

<ul>
<li>
<code>extendEmptyMarkRange?:boolean</code> - 現在の選択範囲全体でもマークを削除します。 デフォルトは <code>false</code> です</li>
</ul>
<h2>使い方</h2>
<pre><code class="language-js">// removes a bold mark
editor.commands.unsetMark('bold')

// removes a bold mark across the current selection
editor.commands.unsetMark('bold', { extendEmptyMarkRange: true })
</code></pre>
<h1>updateAttributes</h1>

<p><code>updateAttributes</code> コマンドは、ノードまたはマークの属性を新しい値に設定します。 渡されなかった属性は変更されません。</p>
<p>参照 : <a href="/api/commands/extend-mark-range">extendMarkRange</a></p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType | MarkType</code></p>

<p>更新するタイプを渡します（例： <code>'heading'</code>）。</p>
<p><code>attributes: Record&lt;string, any&gt;</code></p>

<p>これは、更新する必要のある属性を持つオブジェクトを想定しています。 すべての属性を持っている必要はありません。</p>
<h2>使い方</h2>
<pre><code class="language-js">// Update node attributes
editor.commands.updateAttributes('heading', { level: 1 })

// Update mark attributes
editor.commands.updateAttributes('highlight', { color: 'pink' })
</code></pre>
<h1>wrapInList</h1>

<p><code>wrapInList</code> は、リスト内の現在の選択のノードをラップします。</p>
<h2>パラメーター</h2>
<p><code>typeOrName: string | NodeType</code></p>

<p>リストにラップする必要があるノードのタイプ。</p>
<p><code>attributes?: Record&lt;string, any&gt;</code></p>

<p>リストに適用する必要のある属性。<strong>これはオプションです。</strong></p>
<h2>使い方</h2>
<pre><code class="language-js">// wrap a paragraph in a bullet list
editor.commands.wrapInList('paragraph')
</code></pre>
<h1>ノード</h1>
<h2>はじめに</h2>

<p>ドキュメントをツリーと考えると、ノードはそのツリーのコンテンツの一種にすぎません。ノードの例は、段落、見出し、またはコードブロックです。ただし、ノードはブロックである必要はありません。たとえば、<code>@mentions</code> の場合は、テキストとインラインでレンダリングすることもできます。</p>
<h2>サポートされているノードのリスト</h2>
<table>
<thead>
<tr>
<th>Title</th>
<th>StarterKit (<a href="/api/extensions/starter-kit">view</a>)</th>
<th>Source Code</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/nodes/blockquote">Blockquote</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-blockquote/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/bullet-list">BulletList</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bullet-list/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/code-block">CodeBlock</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-code-block/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/document">Document</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-document/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/emoji">Emoji</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-emoji/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/hard-break">HardBreak</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-hard-break/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/hashtag">Hashtag</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-hashtag/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/heading">Heading</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-heading/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/horizontal-rule">HorizontalRule</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-horizontal-rule/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/image">Image</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-image/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/list-item">ListItem</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-list-item/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/mention">Mention</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-mention/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/ordered-list">OrderedList</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-ordered-list/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/paragraph">Paragraph</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-paragraph/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/table">Table</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/table-row">TableRow</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table-row/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/table-cell">TableCell</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table-cell/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/task-list">TaskList</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-task-list/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/task-item">TaskItem</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-task-item/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/nodes/text">Text</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text/">GitHub</a></td>
</tr>
</tbody>
</table>
<h2>新しいノートの作成</h2>
<p>Tiptap 用に独自のノードを自由に作成できます。独自のノードを作成して登録するために必要な定型コードは次のとおりです。</p>

<pre><code class="language-js">
const CustomNode = Node.create({
  // Your code here
})

const editor = new Editor({
  extensions: [
    // Register your custom node with the editor.
    CustomNode,
    // … and don’t forget all other extensions.
    Document,
    Paragraph,
    Text,
    // …
  ],
})
</code></pre>
<p>参考 <a href="/guide/custom-extensions">more about custom extensions in our guide</a>.</p>
<h1>Blockquote</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-blockquote"><img src="https://img.shields.io/npm/v/@tiptap/extension-blockquote.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-blockquote?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-blockquote.svg" alt="Downloads" /></a></p>


<p>Blockquote 拡張機能を使用すると、エディターで <code>&lt;blockquote&gt;</code> HTML タグを使用できます。エディタで引用符を表示するのに最適です。</p>
<p>新しい行の先頭に <code>&gt;</code> と入力するとブロック引用符に変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-blockquote
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Blockquote.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setBlockquote()</h3>

<p>コンテンツをブロッククォートでラップします。</p>
<pre><code class="language-js">editor.commands.setBlockquote()
</code></pre>
<h3>toggleBlockquote()</h3>

<p>ブロッククォートをラップまたはアンラップします。</p>
<pre><code class="language-js">editor.commands.toggleBlockquote()
</code></pre>
<h3>unsetBlockquote()</h3>

<p>ブロッククォートをアンラップします。</p>
<pre><code class="language-js">editor.commands.unsetBlockquote()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Toggle Blockquote</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>B</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>B</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-blockquote/">packages/extension-blockquote/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Blockquote">https://embed.tiptap.dev/preview/Nodes/Blockquote</a></p>
<h1>BulletList</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-bullet-list"><img src="https://img.shields.io/npm/v/@tiptap/extension-bullet-list.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-bullet-list?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-bullet-list.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用すると、エディターで箇条書きを使用できます。それらは <code>&lt;ul&gt;</code> HTML タグとしてレンダリングされます。</p>
<p>新しい行の先頭に <code>*</code>、<code>-</code>、または <code>+</code> と入力すると、魔法のように箇条書きに変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-bullet-list @tiptap/extension-list-item
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/list-item"><code>ListItem</code></a> ノードが必要で</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">BulletList.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>itemTypeName</h3>

<p>リスト項目名を指定します。</p>
<p>Default: <code>'listItem'</code></p>
<pre><code class="language-js">BulletList.configure({
  itemTypeName: 'listItem',
})
</code></pre>
<h2>コマンド</h2>
<h3>toggleBulletList()</h3>

<p>箇条書きを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleBulletList()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleBulletList</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>8</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>8</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bullet-list/">packages/extension-bullet-list/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/BulletList">https://embed.tiptap.dev/preview/Nodes/BulletList</a></p>
<h1>CodeBlock</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-code-block"><img src="https://img.shields.io/npm/v/@tiptap/extension-code-block.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-code-block?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-code-block.svg" alt="Downloads" /></a></p>





<p>CodeBlock 拡張機能を使用すると、フェンスで囲まれたコードブロックをドキュメントに追加できます。コードを <code>&lt;pre&gt;</code> および <code>&lt;code&gt;</code> HTML タグでラップします。</p>
<p>``` （3つのチルダとスペース）または ∼∼∼ （3つのチルダとスペース）とコードブロックを入力しますすぐに追加されます。言語を指定することもできます。```css  を書いてみてください。これにより、<code>language-css</code>クラスが <code>&lt;code&gt;</code> タグに追加されます。</p>
<blockquote>
<p>警告：<strong>構文の強調表示なし</strong>
CodeBlock 拡張機能にはスタイリングが付属しておらず、構文の強調表示も組み込まれていません。構文が強調表示されたコードブロックを探している場合は、<a href="/api/nodes/code-block-lowlight">CodeBlockLowlight</a> 拡張機能を試してください。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-code-block
</code></pre>
<h2>設定</h2>
<h3>languageClassPrefix</h3>

<p>コードタグに適用される言語クラスにプレフィックスを追加します。</p>
<p>Default: <code>'language-'</code></p>
<pre><code class="language-js">CodeBlock.configure({
  languageClassPrefix: 'language-',
})
</code></pre>
<h3>exitOnTripleEnter</h3>

<p>トリプルエンターでノードを終了するかどうかを定義します。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">CodeBlock.configure({
  exitOnTripleEnter: false,
})
</code></pre>
<h3>exitOnArrowDown</h3>

<p>後にノードがない場合に、下向き矢印でノードを終了するかどうかを定義します。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">CodeBlock.configure({
  exitOnArrowDown: false,
})
</code></pre>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">CodeBlock.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setCodeBlock()</h3>

<p>コンテンツをコードブロックでラップします。</p>
<pre><code class="language-js">editor.commands.setCodeBlock()
</code></pre>
<h3>toggleCodeBlock()</h3>

<p>コードブロックを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleCodeBlock()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleCodeBlock</td>
<td><code>Control</code> <code>Alt</code> <code>C</code></td>
<td><code>Cmd</code> <code>Alt</code> <code>C</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-code-block/">packages/extension-code-block/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/CodeBlock">https://embed.tiptap.dev/preview/Nodes/CodeBlock</a></p>
<h1>CodeBlockLowlight</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-code-block-lowlight"><img src="https://img.shields.io/npm/v/@tiptap/extension-code-block-lowlight.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-code-block-lowlight?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-code-block-lowlight.svg" alt="Downloads" /></a></p>



<p>CodeBlockLowlight 拡張機能を使用すると、フェンスで囲まれたコードブロックをドキュメントに追加できます。コードを <code>&lt;pre&gt;</code> および <code>&lt;code&gt;</code> HTML タグでラップします。</p>
<blockquote>
<p>警告：<strong>構文ハイライト依存関係</strong>
この拡張機能は、<a href="https://github.com/wooorm/lowlight">lowlight</a> ライブラリに依存して、コードブロックのコンテンツに構文の強調表示を適用します。</p>
</blockquote>
<p>``` （3つのチルダとスペース）または ∼∼∼ （3つのチルダとスペース）とコードブロックを入力しますすぐに追加されます。言語を指定することもできます。```css  を書いてみてください。これにより、<code>language-css</code> クラスが <code>&lt;code&gt;</code> タグに追加されます。</p>
<h2>インスト―ル</h2>
<pre><code class="language-bash">npm install lowlight @tiptap/extension-code-block-lowlight
</code></pre>
<h2>設定</h2>
<h3>lowlight</h3>

<p>この拡張機能に <code>lowlight</code> モジュールを提供する必要があります。 <code>lowlight</code> パッケージを拡張機能から切り離すことで、クライアントアプリケーションは、使用する lowlight のバージョンと、ロードする必要のあるプログラミング言語パッケージを制御できます。</p>
<pre><code class="language-js">
CodeBlockLowlight.configure({
  lowlight,
})
</code></pre>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">CodeBlockLowlight.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>languageClassPrefix</h3>

<p>コードタグに適用される言語クラスにプレフィックスを追加します。</p>
<p>Default: <code>'language-'</code></p>
<pre><code class="language-js">CodeBlockLowlight.configure({
  languageClassPrefix: 'language-',
})
</code></pre>
<h3>defaultLanguage</h3>

<p>ローライトの自動検出ではなく、デフォルトの言語を定義します。</p>
<p>Default: <code>null</code></p>
<pre><code class="language-js">CodeBlockLowlight.configure({
  defaultLanguage: 'plaintext',
})
</code></pre>
<h2>コマンド</h2>
<h3>setCodeBlock()</h3>

<p>コンテンツをコードブロックでラップします。</p>
<pre><code class="language-js">editor.commands.setCodeBlock()
</code></pre>
<h3>toggleCodeBlock()</h3>

<p>コードブロックを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleCodeBlock()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleCodeBlock</td>
<td><code>Control</code> + <code>Alt</code> + <code>C</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>C</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-code-block-lowlight/">packages/extension-code-block-lowlight/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/CodeBlockLowlight">https://embed.tiptap.dev/preview/Nodes/CodeBlockLowlight</a></p>
<h1>Document</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-document"><img src="https://img.shields.io/npm/v/@tiptap/extension-document.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-document?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-document.svg" alt="Downloads" /></a></p>



<p><strong>Tiptap で何をビルドするかに関係なく、Document 拡張機能が必要です</strong>。これはいわゆる &quot;topNode&quot; であり、他のすべてのノードのホームとなるノードです。ドキュメントの <code>&lt;body&gt;</code> タグのように考えてください。</p>
<p>ただし、ノードは非常に小さいです。ノードの名前 (<code>doc</code>) を定義し、最上位ノード (<code>topNode: true</code>) として構成され、他の複数のノード (<code>block+</code>) を含めることができます。</p>
<blockquote>
<p>警告：<strong>1.x→2.xからの重大な変更</strong>
Tiptap 1はそのノードをあなたから隠そうとしましたが、それは常にそこにありました。今後は明示的にインポートする必要があります（または <code>StarterKit</code> を使用します）。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-document
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-document/">packages/extension-document/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Document">https://embed.tiptap.dev/preview/Nodes/Document</a></p>
<h1>HardBreak</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-hard-break"><img src="https://img.shields.io/npm/v/@tiptap/extension-hard-break.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-hard-break?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-hard-break.svg" alt="Downloads" /></a></p>

<p>HardBreak 拡張機能は、改行を強制する <code>&lt;br&gt;</code> HTML タグのサポートを追加します。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-hard-break
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">HardBreak.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>keepMarks</h3>

<p>改行後にマークを保持するかどうかを決定します。マークの <code>keepOnSplit</code> オプションに基づいています。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">HardBreak.configure({
  keepMarks: false,
})
</code></pre>
<h2>コマンド</h2>
<h3>setHardBreak()</h3>

<p>改行を追加します</p>
<pre><code class="language-js">editor.commands.setHardBreak()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>setHardBreak</td>
<td><code>Shift</code> + <code>Enter</code><code>Control</code> + <code>Enter</code></td>
<td><code>Shift</code> + <code>Enter</code><code>Cmd</code> + <code>Enter</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-hard-break/">packages/extension-hard-break/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/HardBreak">https://embed.tiptap.dev/preview/Nodes/HardBreak</a></p>
<h1>Hashtag</h1>

<blockquote>
<p>pro 開発資金♥
Tiptapを維持、更新、サポート、開発するには、あなたのサポートが必要です。 この延長を待っている場合は、<a href="/sponsor">スポンサーになり、私たちの仕事に資金を提供してください</a>。</p>
</blockquote>
<p>TODO</p>
<h1>Heading</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-heading"><img src="https://img.shields.io/npm/v/@tiptap/extension-heading.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-heading?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-heading.svg" alt="Downloads" /></a></p>


<p>見出し拡張機能は、さまざまなレベルの見出しのサポートを追加します。見出しは、<code>&lt;h1&gt;</code>、<code>&lt;h2&gt;</code>、<code>&lt;h3&gt;</code>、<code>&lt;h4&gt;</code>、<code>&lt;h5&gt;</code>、または <code>&lt;h6&gt;</code> HTML タグでレンダリングされます。デフォルトでは、6つの見出しレベル（またはスタイル）すべてが有効になっていますが、配列を渡して、いくつかのレベルのみを許可することができます。使用例をチェックして、これがどのように行われるかを確認してください。</p>
<p>新しい行の先頭に <strong><code>#</code> に続けてスペースを入力する</strong> と魔法のように見出しに変換されます。同じように ## , ### , #### , ##### , ######  も同様となります。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-heading
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">Heading.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>levels</h3>

<p>サポートされる見出しレベルを指定します。</p>
<p>Default: <code>[1, 2, 3, 4, 5, 6]</code></p>
<pre><code class="language-js">Heading.configure({
  levels: [1, 2],
})
</code></pre>
<h2>コマンド</h2>
<h3>setHeading()</h3>

<p>指定されたレベルで見出しノードを作成します。</p>
<pre><code class="language-js">editor.commands.setHeading({ level: 1 })
</code></pre>
<h3>toggleHeading()</h3>

<p>指定されたレベルで見出しノードを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleHeading({ level: 1 })
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleHeading({ level: 1 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>1</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>1</code></td>
</tr>
<tr>
<td>toggleHeading({ level: 2 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>2</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>2</code></td>
</tr>
<tr>
<td>toggleHeading({ level: 3 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>3</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>3</code></td>
</tr>
<tr>
<td>toggleHeading({ level: 4 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>4</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>4</code></td>
</tr>
<tr>
<td>toggleHeading({ level: 5 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>5</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>5</code></td>
</tr>
<tr>
<td>toggleHeading({ level: 6 })</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>6</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>6</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-heading/">packages/extension-heading/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Heading">https://embed.tiptap.dev/preview/Nodes/Heading</a></p>
<h1>HorizontalRule</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-horizontal-rule"><img src="https://img.shields.io/npm/v/@tiptap/extension-horizontal-rule.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-horizontal-rule?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-horizontal-rule.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用して、<code>&lt;hr&gt;</code> HTML タグをレンダリングします。エディタの最初のコンテンツで <code>&lt;hr&gt;</code> を渡すと、それに応じてレンダリングされます。</p>
<p>新しい行の先頭に3つのダッシュ (---) または3つのアンダースコアとスペース (___ ) を入力すると、魔法のように水平方向のルールに変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-horizontal-rule
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">HorizontalRule.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setHorizontalRule()</h3>

<p>水平ルールを作成します。</p>
<pre><code class="language-js">editor.commands.setHorizontalRule()
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-horizontal-rule/">packages/extension-horizontal-rule/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/HorizontalRule">https://embed.tiptap.dev/preview/Nodes/HorizontalRule</a></p>
<h1>Image</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-image"><img src="https://img.shields.io/npm/v/@tiptap/extension-image.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-image?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-image.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用して、<code>&lt;img&gt;</code> HTML タグをレンダリングします。デフォルトでは、これらの画像はブロックです。テキストに沿って画像をレンダリングする場合は、<code>inline</code> オプションを <code>true</code> に設定します。</p>
<blockquote>
<p>警告：<strong>制限</strong>
この拡張機能は、画像のレンダリングのみを行います。サーバーに画像をアップロードしません。これはまったく別の話です。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-image
</code></pre>
<h2>設定</h2>
<h3>inline</h3>


<p>画像ノードをインラインでレンダリングします。たとえば、段落タグ <code>&lt;p&gt;&lt;img src=&quot;spacer.gif&quot;&gt;&lt;/p&gt;</code> を使用します。デフォルトでは、画像は段落と同じレベルにあります。</p>
<p>必要な編集エクスペリエンスの種類によって異なりますが、たとえば、Quill から Tiptap に移行する場合に役立ちます。</p>
<p>Default: <code>false</code></p>
<pre><code class="language-js">Image.configure({
  inline: true,
})
</code></pre>
<h3>allowBase64</h3>
<p>Allow images to be parsed as base64 strings <code>&lt;img src=&quot;data:image/jpg;base64...&quot;&gt;</code>.</p>
<p>画像を base64 文字列 <code>&lt;img src=&quot;data:image/jpg;base64...&quot;&gt;</code> として解析できるようにします。</p>
<p>Default: <code>false</code></p>
<pre><code class="language-js">Image.configure({
  allowBase64: true,
})
</code></pre>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Image.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>Commands</h2>
<h3>setImage()</h3>

<p>現在のノードをイメージにします。</p>
<pre><code class="language-js">editor.commands.setImage({ src: 'https://example.com/foobar.png' })
editor.commands.setImage({ src: 'https://example.com/foobar.png', alt: 'A boring example image', title: 'An example' })
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-image/">packages/extension-image/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Image">https://embed.tiptap.dev/preview/Nodes/Image</a></p>
<h1>ListItem</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-list-item"><img src="https://img.shields.io/npm/v/@tiptap/extension-list-item.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-list-item?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-list-item.svg" alt="Downloads" /></a></p>

<p>ListItem 拡張機能は、<code>&lt;li&gt;</code> HTML タグのサポートを追加します。箇条書きと順序付きリストに使用され、それらなしでは実際には使用できません。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-list-item
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/bullet-list"><code>BulletList</code></a> または <a href="/api/nodes/ordered-list"><code>OrderedList</code></a> ノードが必要です。</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">ListItem.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>splitListItem()</td>
<td><code>Enter</code></td>
<td><code>Enter</code></td>
</tr>
<tr>
<td>sinkListItem()</td>
<td><code>Tab</code></td>
<td><code>Tab</code></td>
</tr>
<tr>
<td>liftListItem()</td>
<td><code>Shift</code> + <code>Tab</code></td>
<td><code>Shift</code> + <code>Tab</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-list-item/">packages/extension-list-item/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/ListItem">https://embed.tiptap.dev/preview/Nodes/ListItem</a></p>
<h1>Mention</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-mention"><img src="https://img.shields.io/npm/v/@tiptap/extension-mention.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-mention?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-mention.svg" alt="Downloads" /></a></p>
<p>Honestly, the mention node is amazing. It adds support for <code>@mentions</code>, for example to ping users, <em>and</em> provides full control over the rendering.</p>
<p>Literally everything can be customized. You can pass a custom component for the rendering.  All examples use <code>.filter()</code> to search through items, but feel free to send async queries to an API or add a more advanced library like <a href="https://fusejs.io/">fuse.js</a> to your project.</p>
<p>正直なところ、<code>Mention</code> ノードは素晴らしいです。たとえば、 ping ユーザーに <code>@mentions</code> のサポートを追加するなど、レンダリングを完全に制御します。</p>
<p>文字通りすべてをカスタマイズすることができます。レンダリング用のカスタムコンポーネントを渡すことができます。すべての例で <code>.filter()</code> を使用してアイテムを検索しますが、非同期クエリをAPIに送信するか、<a href="https://fusejs.io/">fuse.js</a> などのより高度なライブラリをプロジェクトに追加してください。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-mention
</code></pre>
<h2>依存関係</h2>

<p>ポップアップを正しく配置するために、すべての例で <a href="https://atomiks.github.io/tippyjs/">tippy.js</a> を使用しています。自分のライブラリを自由に持参できますが、問題がなければ、使用しているものをインストールするだけです。</p>
<pre><code class="language-bash">npm install tippy.js
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Mention.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>renderLabel</h3>

<p>メンションラベルのレンダリング方法を定義します。</p>
<pre><code class="language-js">Mention.configure({
  renderLabel({ options, node }) {
    return `${options.suggestion.char}${node.attrs.label ?? node.attrs.id}`
  }
})
</code></pre>
<h3>提案</h3>
<p><a href="/api/utilities/suggestion">参照</a></p>
<pre><code class="language-js">Mention.configure({
  suggestion: {
    // …
  },
})
</code></pre>
<h2>Source code</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-mention/">packages/extension-mention/</a></p>
<h2>Usage</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Mention">https://embed.tiptap.dev/preview/Nodes/Mention</a></p>
<h1>OrderedList</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-ordered-list"><img src="https://img.shields.io/npm/v/@tiptap/extension-ordered-list.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-ordered-list?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-ordered-list.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用すると、エディターで順序付きリストを使用できます。それらは <code>&lt;ol&gt;</code> HTMLタグとしてレンダリングされます。</p>
<p>新しい行の先頭に 1. （または他の数字の後にドットが続く）と入力すると、魔法のように順序付きリストに変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-ordered-list @tiptap/extension-list-item
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/list-item"><code>ListItem</code></a> ノードが必要です。</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">OrderedList.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>itemTypeName</h3>

<p>リスト項目名を指定します。</p>
<p>Default: <code>'listItem'</code></p>
<pre><code class="language-js">OrderedList.configure({
  itemTypeName: 'listItem',
})
</code></pre>
<h2>コマンド</h2>
<h3>toggleOrderedList()</h3>

<p>順序付きリストを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleOrderedList()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleOrderedList</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>7</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>7</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-ordered-list/">packages/extension-ordered-list/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/OrderedList">https://embed.tiptap.dev/preview/Nodes/OrderedList</a></p>
<h1>Paragraph</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-paragraph"><img src="https://img.shields.io/npm/v/@tiptap/extension-paragraph.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-paragraph?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-paragraph.svg" alt="Downloads" /></a></p>


<p>スキーマは非常に厳密です。この拡張機能がないと、エディターで段落を使用することもできません。</p>
<blockquote>
<p>警告：<strong>1.x→2.xからの重大な変更</strong>
Tiptap 1 はそのノードをあなたから隠そうとしましたが、それは常にそこにありました。今後は明示的にインポートする必要があります（または <code>StarterKit</code> を使用します）。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-paragraph
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Paragraph.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setParagraph()</h3>

<p>選択したすべてのノードを段落に変換します。</p>
<pre><code class="language-js">editor.commands.setParagraph()
</code></pre>
<h2>ショートカットキー</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>setParagraph()</td>
<td><code>Control</code> <code>Alt</code> <code>0</code></td>
<td><code>Cmd</code> <code>Alt</code> <code>0</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-paragraph/">packages/extension-paragraph/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Paragraph">https://embed.tiptap.dev/preview/Nodes/Paragraph</a></p>
<h1>Table</h1>
<h2>Introduction</h2>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-table"><img src="https://img.shields.io/npm/v/@tiptap/extension-table.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-table?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-table.svg" alt="Downloads" /></a></p>


<p>古き良き HTML テーブルほど楽しいものはありません。<code>Table</code> 拡張機能を使用すると、この WYSIWYG 編集の聖杯をエディターに追加できます。</p>
<p><code>spacer.gif</code> を追加することを忘れないでください。（冗談です。それが何であるかわからない場合は、聞いてはいけません。）</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-table @tiptap/extension-table-row @tiptap/extension-table-header @tiptap/extension-table-cell
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/table-row"><code>TableRow</code></a>, <a href="/api/nodes/table-header"><code>TableHeader</code></a> and <a href="/api/nodes/table-cell"><code>TableCell</code></a> の各種ノードが必要です。</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Table.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>resizable</h3>
<p>Default: <code>false</code></p>
<h3>handleWidth</h3>
<p>Default: <code>5</code></p>
<h3>cellMinWidth</h3>
<p>Default: <code>25</code></p>
<h3>View</h3>
<p>Default: <code>TableView</code></p>
<h3>lastColumnResizable</h3>
<p>Default: <code>true</code></p>
<h3>allowTableNodeSelection</h3>
<p>Default: <code>false</code></p>
<h2>コマンド</h2>
<h3>insertTable()</h3>

<p>指定された行数と列数、およびヘッダー行（指示された場合）を使用して、新しいテーブルを作成します。</p>
<pre><code class="language-js">editor.commands.insertTable()
editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })
</code></pre>
<h3>addColumnBefore()</h3>

<p>現在の列の前に列を追加します。</p>
<pre><code class="language-js">editor.commands.addColumnBefore()
</code></pre>
<h3>addColumnAfter()</h3>

<p>現在の列の後に列を追加します。</p>
<pre><code class="language-js">editor.commands.addColumnAfter()
</code></pre>
<h3>deleteColumn()</h3>

<p>現在の列を削除します。</p>
<pre><code class="language-js">editor.commands.deleteColumn()
</code></pre>
<h3>addRowBefore()</h3>

<p>現在の行の上に行を追加します。</p>
<pre><code class="language-js">editor.commands.addRowBefore()
</code></pre>
<h3>addRowAfter()</h3>

<p>現在の行の下に行を追加します。</p>
<pre><code class="language-js">editor.commands.addRowAfter()
</code></pre>
<h3>deleteRow()</h3>

<p>現在の行を削除します。</p>
<pre><code class="language-js">editor.commands.deleteRow()
</code></pre>
<h3>deleteTable()</h3>

<p>テーブル全体を削除します。</p>
<pre><code class="language-js">editor.commands.deleteTable()
</code></pre>
<h3>mergeCells()</h3>

<p>選択したすべてのセルを1つのセルに結合します。</p>
<pre><code class="language-js">editor.commands.mergeCells()
</code></pre>
<h3>splitCell()</h3>

<p>現在のセルを分割します。</p>
<pre><code class="language-js">editor.commands.splitCell()
</code></pre>
<h3>toggleHeaderColumn()</h3>

<p>現在の列をヘッダー列にします。</p>
<pre><code class="language-js">editor.commands.toggleHeaderColumn()
</code></pre>
<h3>toggleHeaderRow()</h3>

<p>現在の行をヘッダー行にします。</p>
<pre><code class="language-js">editor.commands.toggleHeaderRow()
</code></pre>
<h3>toggleHeaderCell()</h3>

<p>現在のセルをヘッダーセルにします。</p>
<pre><code class="language-js">editor.commands.toggleHeaderCell()
</code></pre>
<h3>mergeOrSplit()</h3>

<p>複数のセルが選択されている場合、それらはマージされます。単一のセルが選択されている場合、セルは2つのセルに分割されます。</p>
<pre><code class="language-js">editor.commands.mergeOrSplit()
</code></pre>
<h3>setCellAttribute()</h3>

<p>現在のセルに指定された属性を設定します。<a href="/api/nodes/table-cell"><code>TableCell</code></a> 拡張機能で定義するものなら何でもかまいません。たとえば、背景色などです。必ず最初に <a href="/guide/custom-extensions#attributes">カスタム属性</a> を登録してください。</p>
<pre><code class="language-js">editor.commands.setCellAttribute('customAttribute', 'value')
editor.commands.setCellAttribute('backgroundColor', '#000')
</code></pre>
<h3>goToNextCell()</h3>

<p>次のセルに移動します。</p>
<pre><code class="language-js">editor.commands.goToNextCell()
</code></pre>
<h3>goToPreviousCell()</h3>

<p>前のセルに移動します。</p>
<pre><code class="language-js">editor.commands.goToPreviousCell()
</code></pre>
<h3>fixTables()</h3>

<p>ドキュメント内のすべてのテーブルを検査し、必要に応じて修正します。</p>
<pre><code class="language-js">editor.commands.fixTables()
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table/">packages/extension-table/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Table">https://embed.tiptap.dev/preview/Nodes/Table</a></p>
<h1>TableRow</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-table-row"><img src="https://img.shields.io/npm/v/@tiptap/extension-table-row.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-table-row?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-table-row.svg" alt="Downloads" /></a></p>

<p>行のないテーブルとは何ですか？ この拡張機能を追加して、テーブルを使用できるようにします。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-table @tiptap/extension-table-row @tiptap/extension-table-header @tiptap/extension-table-cell
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/table"><code>Table</code></a>, <a href="/api/nodes/table-header"><code>TableHeader</code></a> 及び <a href="/api/nodes/table-cell"><code>TableCell</code></a> ノードが必要です 。</p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table-row/">packages/extension-table-row/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Table">https://embed.tiptap.dev/preview/Nodes/Table</a></p>
<h1>TableCell</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-table-cell"><img src="https://img.shields.io/npm/v/@tiptap/extension-table-cell.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-table-cell?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-table-cell.svg" alt="Downloads" /></a></p>

<p>テーブルセルのないテーブルを使用しようとしないでください。 面白くないでしょう。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-table @tiptap/extension-table-row @tiptap/extension-table-header @tiptap/extension-table-cell
</code></pre>
<p>This extension requires the <a href="/api/nodes/table"><code>Table</code></a>, <a href="/api/nodes/table-row"><code>TableRow</code></a> and <a href="/api/nodes/table-header"><code>TableHeader</code></a> nodes.</p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table-cell/">packages/extension-table-cell/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Table">https://embed.tiptap.dev/preview/Nodes/Table</a></p>
<h1>TableHeader</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-table-header"><img src="https://img.shields.io/npm/v/@tiptap/extension-table-header.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-table-header?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-table-header.svg" alt="Downloads" /></a></p>

<p>テーブルヘッダーはオプションです。でもさあ、あなたはそれらが欲しいですよね？それらが不要な場合は、<a href="/api/nodes/table-row"><code>TableRow</code></a> 拡張機能の <code>content</code> 属性を次のように更新します。</p>
<pre><code class="language-js">// Table rows without table headers
TableRow.extend({
  content: 'tableCell*',
})
</code></pre>

<p>これはデフォルトであり、テーブルヘッダーを許可します。</p>
<pre><code class="language-js">// Table rows with table headers (default)
TableRow.extend({
  content: '(tableCell | tableHeader)*',
})
</code></pre>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-table @tiptap/extension-table-row @tiptap/extension-table-header @tiptap/extension-table-cell
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/table"><code>Table</code></a>, <a href="/api/nodes/table-row"><code>TableRow</code></a> 及び <a href="/api/nodes/table-cell"><code>TableCell</code></a> ノードが必要です。</p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-table-header/">packages/extension-table-header/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Table">https://embed.tiptap.dev/preview/Nodes/Table</a></p>
<h1>TaskList</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-task-list"><img src="https://img.shields.io/npm/v/@tiptap/extension-task-list.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-task-list?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-task-list.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用すると、エディターでタスクリストを使用できます。それらは <code>&lt;ul data-type=&quot;taskList&quot;&gt;</code> としてレンダリングされます。この実装にはフレームワークは必要ありません。Vanilla JavaScript のみを使用しています。</p>
<p>新しい行の先頭に [ ]  or [x]  と入力すると、魔法のようにタスクリストに変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-task-list @tiptap/extension-task-item
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/task-item"><code>TaskItem</code></a> 拡張機能が必要です。</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">TaskList.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>itemTypeName</h3>

<p>リスト項目名を指定します。</p>
<p>Default: <code>'taskItem'</code></p>
<pre><code class="language-js">TaskList.configure({
  itemTypeName: 'taskItem',
})
</code></pre>
<h2>コマンド</h2>
<h1>toggleTaskList()</h1>

<p>タスクリストを切り替えます。.</p>
<pre><code class="language-js">editor.commands.toggleTaskList()
</code></pre>
<h2>ショートカットキー</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleTaskList()</td>
<td><code>Control</code> <code>Shift</code> <code>9</code></td>
<td><code>Cmd</code> <code>Shift</code> <code>9</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-task-list/">packages/extension-task-list/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/TaskList">https://embed.tiptap.dev/preview/Nodes/TaskList</a></p>
<h1>TaskItem</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-task-item"><img src="https://img.shields.io/npm/v/@tiptap/extension-task-item.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-task-item?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-task-item.svg" alt="Downloads" /></a></p>


<p>この拡張機能は、タスクアイテムリスト要素をレンダリングします。これは、<code>data-type</code> 属性が <code>taskItem</code> に設定された <code>&lt;li&gt;</code> タグです。また、list要素内にチェックボックスをレンダリングし、<code>checked</code> 属性を更新します。</p>
<p>この拡張機能は JavaScript フレームワークを必要とせず、Vanilla JavaScript に基づいています。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-task-list @tiptap/extension-task-item
</code></pre>

<p>この拡張機能には、<a href="/api/nodes/task-list"><code>TaskList</code></a> ノードが必要です。</p>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">TaskItem.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>nested</h3>

<p>タスクアイテムを相互にネストできるかどうか。</p>
<pre><code class="language-js">TaskItem.configure({
  nested: true,
})
</code></pre>
<h3>onReadOnlyChecked</h3>



<p>エディターが <code>readOnly</code> に設定されているときに、タスク項目がオンまたはオフになっている場合のハンドラー。</p>
<p>これが指定されていない場合、エディターが <code>readOnly</code> である間、タスク項目は不変です。</p>
<p>この関数が false を返す場合、チェック状態は保持されます（ <code>readOnly</code>）。</p>
<pre><code class="language-js">TaskItem.configure({
  onReadOnlyChecked: (node, checked) =&gt; {
    // do something
  },
})
</code></pre>
<h2>ショートカットキー</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>splitListItem()</td>
<td><code>Enter</code></td>
<td><code>Enter</code></td>
</tr>
<tr>
<td>sinkListItem()</td>
<td><code>Tab</code></td>
<td><code>Tab</code></td>
</tr>
<tr>
<td>liftListItem()</td>
<td><code>Shift</code> + <code>Tab</code></td>
<td><code>Shift</code> + <code>Tab</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-task-item/">packages/extension-task-item/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/TaskItem">https://embed.tiptap.dev/preview/Nodes/TaskItem</a></p>
<h1>Text</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-text"><img src="https://img.shields.io/npm/v/@tiptap/extension-text.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-text?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-text.svg" alt="Downloads" /></a></p>


<p><strong>Text 拡張子が必要です</strong>。少なくとも、あらゆる種類のテキストを処理する場合は、その可能性が非常に高くなります。この拡張機能は少し異なり、 HTML もレンダリングしません。プレーンテキストです、それだけです。</p>
<blockquote>
<p>警告：<strong>1.x→2.xからの重大な変更</strong>
tiptap 1はそのノードをあなたから隠そうとしましたが、それは常にそこにありました。今後は明示的にインポートする必要があります 。(または <code>StarterKit</code> を使用します)</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-text
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text/">packages/extension-text/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Nodes/Text">https://embed.tiptap.dev/preview/Nodes/Text</a></p>
<h1>マーク</h1>
<h2>はじめに</h2>

<p><a href="/api/nodes">ノード</a> に 1つまたは複数のマークを適用して、たとえば、太字や斜体などのインラインフォーマットやその他の追加情報を追加できます。</p>
<h2>サポートされているマークのリスト</h2>
<table>
<thead>
<tr>
<th>Title</th>
<th>StarterKit (<a href="/api/extensions/starter-kit">view</a>)</th>
<th>Source Code</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/marks/bold">Bold</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bold/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/code">Code</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-code/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/highlight">Highlight</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-highlight/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/italic">Italic</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-italic/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/link">Link</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-link/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/strike">Strike</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-strike/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/subscript">Subscript</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-subscript/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/superscript">Superscript</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-superscript/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/text-style">TextStyle</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text-style/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/marks/underline">Underline</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-underline/">GitHub</a></td>
</tr>
</tbody>
</table>
<h1>Bold</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-bold"><img src="https://img.shields.io/npm/v/@tiptap/extension-bold.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-bold?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-bold.svg" alt="Downloads" /></a></p>

<p>この拡張機能は、テキストを <strong>太字</strong> でレンダリングします。 <code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code> タグ、またはインラインの  <code>style</code> 属性を持つテキストを渡して、エディターの初期コンテンツで <code>font-weight</code> CSS ルールを設定すると、それらはすべてそれに応じてレンダリングされます。</p>

<p><code>** twoasterisks**</code> または <code>__twounderlines__</code> と入力すると、入力中に魔法のように <strong>太字</strong> のテキストに変換されます。</p>
<p>::: warning Restrictions
The extension will generate the corresponding <code>&lt;strong&gt;</code> HTML tags when reading contents of the <code>Editor</code> instance. All text marked bold, regardless of the method will be normalized to <code>&lt;strong&gt;</code> HTML tags.
:::</p>
<blockquote>
<p><strong>警告</strong> ： 制限
拡張機能は、<code>Editor</code> インスタンスのコンテンツを読み取るときに対応する <code>&lt;strong&gt;</code> HTMLタグを生成します。メソッドに関係なく、太字でマークされたすべてのテキストは、<code>&lt;strong&gt;</code>HTML タグに正規化されます。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-bold
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">Bold.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setBold()</h3>

<p>テキストを太字でマークします。</p>
<pre><code class="language-js">editor.commands.setBold()
</code></pre>
<h3>toggleBold()</h3>

<p>太字のマークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleBold()
</code></pre>
<h3>unsetBold()</h3>

<p>太字のマークを削除します。</p>
<pre><code class="language-js">editor.commands.unsetBold()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleBold()</td>
<td><code>Ctrl</code> + <code>B</code></td>
<td><code>Cmd</code> + <code>B</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bold/">packages/extension-bold/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Bold">https://embed.tiptap.dev/preview/Marks/Bold</a></p>
<h1>Code</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-code"><img src="https://img.shields.io/npm/v/@tiptap/extension-code.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-code?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-code.svg" alt="Downloads" /></a></p>


<p>コード拡張機能を使用すると、エディターで <code>&lt;code&gt;</code> HTML タグを使用できます。<code>&lt;code&gt;</code> タグを付けてテキストを貼り付けると、それに応じてレンダリングされます。</p>
<p>`back-ticks around` を使用して何かを入力すると、入力中に魔法のように <code>inline code</code> に変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-code
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">Code.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>Commands</h2>
<h3>setCode()</h3>

<p>テキストをインラインコードとしてマークします。</p>
<pre><code class="language-js">editor.commands.setCode()
</code></pre>
<h3>toggleCode()</h3>

<p>インラインコードマークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleCode()
</code></pre>
<h3>unsetCode()</h3>

<p>インラインコードマークを削除します。</p>
<pre><code class="language-js">editor.commands.unsetCode()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleCode()</td>
<td><code>Ctrl</code> + <code>E</code></td>
<td><code>Cmd</code> + <code>E</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-code/">packages/extension-code/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Code">https://embed.tiptap.dev/preview/Marks/Code</a></p>
<h1>Highlight</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-highlight"><img src="https://img.shields.io/npm/v/@tiptap/extension-highlight.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-highlight?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-highlight.svg" alt="Downloads" /></a></p>


<p>この拡張機能は、強調表示されたテキストを <code>&lt;mark&gt;</code> でレンダリングします。デフォルトで黄色の背景色を持つデフォルトの <code>&lt;mark&gt;</code> HTML タグのみを使用するか、異なる色を適用できます。</p>
<p><code>==two equal sign==</code>と入力すると、入力中に ハイライトされた テキストに魔法のように変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-highlight
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">Highlight.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>multicolor</h3>

<p>複数の色のサポートを追加します。</p>
<p>Default: <code>false</code></p>
<pre><code class="language-js">Highlight.configure({
  multicolor: true,
})
</code></pre>
<h2>コマンド</h2>
<h3>setHighlight()</h3>

<p>テキストを強調表示としてマークします。</p>
<pre><code class="language-js">editor.commands.setHighlight()
editor.commands.setHighlight({ color: '#ffcc00' })
</code></pre>
<h3>toggleHighlight()</h3>

<p>テキストのハイライトを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleHighlight()
editor.commands.toggleHighlight({ color: '#ffcc00' })
</code></pre>
<h3>unsetHighlight()</h3>

<p>ハイライトを削除します。</p>
<pre><code class="language-js">editor.commands. unsetHighlight()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleHighlight()</td>
<td><code>Control</code> + <code>Shift</code> + <code>H</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>H</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-highlight/">packages/extension-highlight/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Highlight">https://embed.tiptap.dev/preview/Marks/Highlight</a></p>
<h1>Italic</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-italic"><img src="https://img.shields.io/npm/v/@tiptap/extension-italic.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-italic?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-italic.svg" alt="Downloads" /></a></p>


<p>この拡張機能は、テキストを <em>斜体</em> でレンダリングします。エディターの初期コンテンツで <code>&lt;em&gt;</code>、<code>&lt;i&gt;</code> タグ、またはインラインの <code>style</code> 属性が <code>font-style: italic</code> を設定しているテキストを渡すと、それらはすべてそれに応じてレンダリングされます。</p>
<p><code>*oneasterisk*</code> または <code>_oneunderline_</code> と入力すると、入力中に魔法のように <em>斜体</em> のテキストに変換されます。</p>


<blockquote>
<p>警告：制限
拡張機能は、<code>Editor</code> インスタンスのコンテンツを読み取るときに対応する <code>&lt;em&gt;</code> HTML タグを生成します。メソッドに関係なく、イタリックでマークされたすべてのテキストは、<code>&lt;em&gt;</code> HTML タグに正規化されます。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-italic
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Italic.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setItalic()</h3>

<p>テキストを斜体でマークします。</p>
<pre><code class="language-js">editor.commands.setItalic()
</code></pre>
<h3>toggleItalic()</h3>

<p>斜体のマークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleItalic()
</code></pre>
<h3>unsetItalic()</h3>

<p>イタリックマークを削除します。</p>
<pre><code class="language-js">editor.commands.unsetItalic()
</code></pre>
<h2>キーボードショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleItalic()</td>
<td><code>Control</code> + <code>I</code></td>
<td><code>Cmd</code> + <code>I</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-italic/">packages/extension-italic/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Italic">https://embed.tiptap.dev/preview/Marks/Italic</a></p>
<h1>Link</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-link"><img src="https://img.shields.io/npm/v/@tiptap/extension-link.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-link?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-link.svg" alt="Downloads" /></a></p>



<p>Link 拡張機能は、エディターに <code>&lt;a&gt;</code> タグのサポートを追加します。拡張機能もヘッドレスであり、リンクを追加、変更、または削除するための実際のUIはありません。以下の使用例では、ネイティブ JavaScript プロンプトを使用して、それがどのように機能するかを示しています。</p>
<p>実際のアプリケーションでは、おそらくより洗練されたユーザーインターフェイスを追加します。</p>
<p>貼り付けられた URL は自動的にリンクに変換されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-link
</code></pre>
<h2>設定</h2>
<h3>protocols</h3>

<p>リンクとして認識したい追加のカスタムプロトコル。</p>
<p>Default: <code>[]</code></p>
<pre><code class="language-js">Link.configure({
  protocols: ['ftp', 'mailto'],
})
</code></pre>
<h3>autolink</h3>

<p>有効にすると、入力時にリンクが追加されます。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">Link.configure({
  autolink: false,
})
</code></pre>
<h3>openOnClick</h3>

<p>有効にすると、クリックするとリンクが開きます。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">Link.configure({
  openOnClick: false,
})
</code></pre>
<h3>linkOnPaste</h3>

<p>貼り付けたコンテンツに URL のみが含まれている場合は、現在の選択へのリンクを追加します。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">Link.configure({
  linkOnPaste: false,
})
</code></pre>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Link.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h3>validate</h3>


<p>自動リンクされたすべてのリンクを検証する関数。存在する場合は、リンク <code>href</code> を引数として呼び出されます。 <code>false</code> を返す場合、リンクは削除されます。</p>
<p>たとえば、特定のドメイン、TLD などを除外または含めるルールを設定するために使用できます。</p>
<pre><code class="language-js">// only autolink urls with a protocol
Link.configure({
  validate: href =&gt; /^https?:\/\//.test(href),
})
</code></pre>
<h2>コマンド</h2>
<h3>setLink()</h3>

<p>選択したテキストをリンクします。</p>
<pre><code class="language-js">editor.commands.setLink({ href: 'https://example.com' })
editor.commands.setLink({ href: 'https://example.com', target: '_blank' })
</code></pre>
<h3>toggleLink()</h3>

<p>選択したテキストにリンクを追加または削除します。</p>
<pre><code class="language-js">editor.commands.toggleLink({ href: 'https://example.com' })
editor.commands.toggleLink({ href: 'https://example.com', target: '_blank' })
</code></pre>
<h3>unsetLink()</h3>

<p>リンクを削除します。</p>
<pre><code class="language-js">editor.commands.unsetLink()
</code></pre>
<h2>キーボードショートカット</h2>
<blockquote>
<p>警告：キーボードショートカットはありません
この拡張機能は、特定のキーボードショートカットをバインドしません。ただし、おそらく <code>Mod-k</code> でカスタム UI を開くでしょう。</p>
</blockquote>

<h2>現在の値の取得</h2>
<p><a href="/api/editor#get-attributes"><code>getAttributes</code></a> を使用して、現在設定されている属性（たとえば、どの href なのか）を見つけることができることをご存知ですか？ <a href="/api/commands">コマンド</a>（状態を変更する）と混同しないでください。これは単なるメソッドです。これがどのように見えるかです：</p>

<pre><code class="language-js">this.editor.getAttributes('link').href
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-link/">packages/extension-link/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Link">https://embed.tiptap.dev/preview/Marks/Link</a></p>
<h1>Strike</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-strike"><img src="https://img.shields.io/npm/v/@tiptap/extension-strike.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-strike?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-strike.svg" alt="Downloads" /></a></p>



<p>この拡張機能を使用して、<del>打たれたテキスト</del> をレンダリングします。<code>&lt;s&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;strike&gt;</code> タグ、またはインラインの  <code>style</code> 属性で <code>text-decoration: line-through</code> を設定するテキストをエディターの初期コンテンツに渡すと、それらはすべて次のようになります。それに応じてレンダリングされます。</p>
<p>∼∼text between tildes∼∼ と入力すると、入力中に魔法のように<del>打たれます</del>。</p>
<blockquote>
<p>警告：制限
拡張機能は、<code>Editor</code> インスタンスのコンテンツを読み取るときに対応する <code>&lt;s&gt;</code> HTML タグを生成します。メソッドに関係なく、すべてのテキストは <code>&lt;s&gt;</code> HTML タグに正規化されます。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-strike
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Strike.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setStrike()</h3>

<p>テキストをストライクとしてマークします。</p>
<pre><code class="language-js">editor.commands.setStrike()
</code></pre>
<h3>toggleStrike()</h3>

<p>ストライクマークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleStrike()
</code></pre>
<h3>unsetStrike()</h3>

<p>ストライクマークを削除します。</p>
<pre><code class="language-js">editor.commands.unsetStrike()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleStrike()</td>
<td><code>Control</code> + <code>Shift</code> + <code>X</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>X</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-strike/">packages/extension-strike/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Strike">https://embed.tiptap.dev/preview/Marks/Strike</a></p>
<h1>Subscript</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-subscript"><img src="https://img.shields.io/npm/v/@tiptap/extension-subscript.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-subscript?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-subscript.svg" alt="Downloads" /></a></p>

<p>この拡張機能を使用して、subscript のテキストをレンダリングします。エディターの初期コンテンツでインラインスタイルとして <code>&lt;sub&gt;</code> または <code>vertical-align: sub</code> を含むテキストを渡すと、両方とも <code>&lt;sub&gt;</code> HTML タグに正規化されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-subscript
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされたHTMLタグに追加する必要があるカスタムHTML属性。</p>
<pre><code class="language-js">Subscript.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setSubscript()</h3>

<p>テキストを下付き文字としてマークします。</p>
<pre><code class="language-js">editor.commands.setSubscript()
</code></pre>
<h3>toggleSubscript()</h3>

<p>下付き文字マークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleSubscript()
</code></pre>
<h3>unsetSubscript()</h3>

<p>下付き文字を削除します。</p>
<pre><code class="language-js">editor.commands.unsetSubscript()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleSubscript()</td>
<td><code>Ctrl</code> + <code>,</code></td>
<td><code>Cmd</code> + <code>,</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-subscript/">packages/extension-subscript/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Subscript">https://embed.tiptap.dev/preview/Marks/Subscript</a></p>
<h1>Superscript</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-superscript"><img src="https://img.shields.io/npm/v/@tiptap/extension-superscript.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-superscript?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-superscript.svg" alt="Downloads" /></a></p>

<p>この拡張機能を使用して、上付き文字 でテキストをレンダリングします。エディターの初期コンテンツでインラインスタイルとして <code>&lt;sup&gt;</code> または <code>vertical-align: super</code> を含むテキストを渡すと、両方とも <code>&lt;sup&gt;</code> HTML タグに正規化されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-superscript
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Superscript.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setSuperscript()</h3>

<p>テキストを上付き文字としてマークします。</p>
<pre><code class="language-js">editor.commands.setSuperscript()
</code></pre>
<h3>toggleSuperscript()</h3>

<p>上付き文字マークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleSuperscript()
</code></pre>
<h3>unsetSuperscript()</h3>

<p>上付き文字を削除します。</p>
<pre><code class="language-js">editor.commands.unsetSuperscript()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleSuperscript()</td>
<td><code>Ctrl</code> + <code>.</code></td>
<td><code>Cmd</code> + <code>.</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-superscript/">packages/extension-superscript/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Superscript">https://embed.tiptap.dev/preview/Marks/Superscript</a></p>
<h1>TextStyle</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-text-style"><img src="https://img.shields.io/npm/v/@tiptap/extension-text-style.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-text-style?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-text-style.svg" alt="Downloads" /></a></p>

<p>このマークは <code>&lt;span&gt;</code> HTML タグをレンダリングし、フォントファミリ、フォントサイズ、色などのスタイル関連の属性のリストを追加できるようにします。拡張機能はデフォルトでスタイリング属性を追加しませんが、他の拡張機能はそれを基盤として使用します。たとえば、<a href="/api/extensions/font-family"><code>FontFamily</code></a> や <a href="/api/extensions/color"><code>Color</code></a> 。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-text-style
</code></pre>
<h2>コマンド</h2>
<h3>removeEmptyTextStyle()</h3>

<p>インラインスタイルなしで <code>&lt;span&gt;</code> タグを削除します。</p>
<pre><code class="language-js">editor.command.removeEmptyTextStyle()
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text-style/">packages/extension-text-style/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/TextStyle">https://embed.tiptap.dev/preview/Marks/TextStyle</a></p>
<h1>Underline</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-underline"><img src="https://img.shields.io/npm/v/@tiptap/extension-underline.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-underline?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-underline.svg" alt="Downloads" /></a></p>


<p>この拡張機能を使用して、テキストを 下線付き でレンダリングします。 <code>&lt;u&gt;</code> タグを渡すか、エディターの初期コンテンツで <code>text-decoration: underline</code> を設定するインライン <code> style</code> 属性を持つテキストを渡すと、それらはすべてそれに応じてレンダリングされます。</p>
<p>インターネットで下線が引かれたテキストは、通常、クリック可能なリンクであることを示していることに注意してください。ユーザーを下線付きのテキストと混同しないでください。</p>

<blockquote>
<p>警告：制限
拡張機能は、<code>Editor</code> インスタンスのコンテンツを読み取るときに対応する <code>&lt;u&gt;</code> HTML タグを生成します。メソッドに関係なく、下線付きでマークされたすべてのテキストは、<code>&lt;u&gt;</code> HTML タグに正規化されます。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-underline
</code></pre>
<h2>設定</h2>
<h3>HTMLAttributes</h3>

<p>レンダリングされた HTML タグに追加する必要があるカスタム HTML 属性。</p>
<pre><code class="language-js">Underline.configure({
  HTMLAttributes: {
    class: 'my-custom-class',
  },
})
</code></pre>
<h2>コマンド</h2>
<h3>setUnderline()</h3>

<p>テキストに下線付きのマークを付けます。</p>
<pre><code class="language-js">editor.commands.setUnderline()
</code></pre>
<h3>toggleUnderline()</h3>

<p>下線マークを切り替えます。</p>
<pre><code class="language-js">editor.commands.toggleUnderline()
</code></pre>
<h3>unsetUnderline()</h3>

<p>下線マークを削除します。</p>
<pre><code class="language-js">editor.commands.unsetUnderline()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>toggleUnderline()</td>
<td><code>Ctrl</code> + <code>U</code></td>
<td><code>Cmd</code> + <code>U</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-underline/">packages/extension-underline/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Marks/Underline">https://embed.tiptap.dev/preview/Marks/Underline</a></p>
<h1>拡張機能</h1>
<h2>はじめに</h2>


<p>拡張機能は Tiptap に新しい機能を追加し、ここで拡張機能という言葉を頻繁に読みます。 実際には、文字通りの拡張機能があります。 これらはスキーマに追加できませんが、機能を追加したり、エディターの動作を変更したりすることはできます。</p>
<p>より多くの機能を備えたいくつかの拡張機能もあります。 これらを <a href="/api/nodes">nodes</a> と <a href="/api/marks">marks</a> と呼び、エディターでコンテンツをレンダリングできます。</p>
<h2>提供されている拡張機能のリスト</h2>
<table>
<thead>
<tr>
<th>タイトル</th>
<th>StarterKit (<a href="/api/extensions/starter-kit">view</a>)</th>
<th>ソースコード</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/extensions/bubble-menu">BubbleMenu</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bubble-menu/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/character-count">CharacterCount</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-character-count/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/collaboration">Collaboration</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-collaboration/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/collaboration-cursor">CollaborationCursor</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-collaboration-cursor/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/color">Color</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-color/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/dropcursor">Dropcursor</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-dropcursor/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/floating-menu">FloatingMenu</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-floating-menu/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/focus">Focus</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-focus/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/font-family">FontFamily</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-font-family/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/gapcursor">Gapcursor</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-gapcursor/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/history">History</a></td>
<td>Included</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-history/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/placeholder">Placeholder</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-placeholder/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/starter-kit">StarterKit</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/starter-kit/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/text-align">TextAlign</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text-align/">GitHub</a></td>
</tr>
<tr>
<td><a href="/api/extensions/unique-id">UniqueID</a></td>
<td>–</td>
<td>Requires a Tiptap Pro subscription</td>
</tr>
<tr>
<td><a href="/api/extensions/typography">Typography</a></td>
<td>–</td>
<td><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-typography/">GitHub</a></td>
</tr>
</tbody>
</table>

<p>使用する必要はありませんが、最も一般的な拡張機能を含む <code>@tiptap/starter-kit</code> を用意しました。 <a href="/guide/configuration#default-extensions"><code>StarterKit</code></a> の詳細をご覧ください。</p>
<h2>拡張機能の仕組み</h2>
<p>Tiptap は ProseMirror の複雑さのほとんどを隠そうとしますが、API の上に構築されているため、高度な使用法については <a href="https://ProseMirror.net/docs/guide/">ProseMirrorガイド</a> を読むことをお勧めします。すべてが内部でどのように機能するかをよりよく理解し、Tiptap で使用される多くの用語や専門用語に慣れることができます。</p>
<p>既存の <a href="/api/nodes">nodes</a>, <a href="/api/marks">marks</a> と <a href="/api/extensions">extensions</a> は、独自の拡張機能にアプローチする方法について良い印象を与えることができます。ドキュメントとソースコードを簡単に切り替えることができるように、すべての拡張ドキュメントページから GitHub 上のファイルにリンクしました。</p>
<p>最初に既存の拡張機能をカスタマイズすることから始め、後で得た知識を使用して独自の拡張機能を作成することをお勧めします。そのため、以下の例はすべて既存の拡張機能を拡張していますが、すべての例は新しく作成された拡張機能でも機能します。</p>



<h2>新しい拡張機能を作成します</h2>
<p>Tiptap 用の独自の拡張機能を自由に作成できます。独自の拡張機能を作成して登録するために必要な定型コードは次のとおりです。</p>

<pre><code class="language-js">
const CustomExtension = Extension.create({
  // Your code here
})

const editor = new Editor({
  extensions: [
    // Register your custom extension with the editor.
    CustomExtension,
    // … and don’t forget all other extensions.
    Document,
    Paragraph,
    Text,
    // …
  ],
})
</code></pre>
<p>Learn <a href="/guide/custom-extensions">more about custom extensions in our guide</a>.</p>
<h1>Bubble Menu</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-bubble-menu"><img src="https://img.shields.io/npm/v/@tiptap/extension-bubble-menu.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-bubble-menu?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-bubble-menu.svg" alt="Downloads" /></a></p>
<p>This extension will make a contextual menu appear near a selection of text. Use it to let users apply <a href="/api/marks">marks</a> to their text selection.</p>
<p>As always, the markup and styling is totally up to you.</p>
<h2>Installation</h2>
<pre><code class="language-bash">npm install @tiptap/extension-bubble-menu
</code></pre>
<h2>Settings</h2>
<h3>element</h3>
<p>The DOM element that contains your menu.</p>
<p>Type: <code>HTMLElement</code></p>
<p>Default: <code>null</code></p>
<h3>tippyOptions</h3>
<p>Under the hood, the <code>BubbleMenu</code> uses <a href="https://atomiks.github.io/tippyjs/v6/all-props/">tippy.js</a>. You can directly pass options to it.</p>
<p>Type: <code>Object</code></p>
<p>Default: <code>{}</code></p>
<h3>pluginKey</h3>
<p>The key for the underlying ProseMirror plugin. Make sure to use different keys if you add more than one instance.</p>
<p>Type: <code>string | PluginKey</code></p>
<p>Default: <code>'bubbleMenu'</code></p>
<h3>shouldShow</h3>
<p>A callback to control whether the menu should be shown or not.</p>
<p>Type: <code>(props) =&gt; boolean</code></p>
<h2>Source code</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-bubble-menu/">packages/extension-bubble-menu/</a></p>
<h2>Usage</h2>
<h3>JavaScript</h3>
<pre><code class="language-js">
new Editor({
  extensions: [
    BubbleMenu.configure({
      element: document.querySelector('.menu'),
    }),
  ],
})
</code></pre>
<h3>Frameworks</h3>
<p><a href="https://embed.tiptap.dev/preview/Extensions/BubbleMenu">https://embed.tiptap.dev/preview/Extensions/BubbleMenu</a></p>
<h3>Custom logic</h3>
<p>Customize the logic for showing the menu with the <code>shouldShow</code> option. For components, <code>shouldShow</code> can be passed as a prop.</p>
<pre><code class="language-js">BubbleMenu.configure({
  shouldShow: ({ editor, view, state, oldState, from, to }) =&gt; {
    // only show the bubble menu for images and links
    return editor.isActive('image') || editor.isActive('link')
  },
})
</code></pre>
<h3>Multiple menus</h3>
<p>Use multiple menus by setting an unique <code>pluginKey</code>.</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    BubbleMenu.configure({
      pluginKey: 'bubbleMenuOne',
      element: document.querySelector('.menu-one'),
    }),
    BubbleMenu.configure({
      pluginKey: 'bubbleMenuTwo',
      element: document.querySelector('.menu-two'),
    }),
  ],
})
</code></pre>
<p>Alternatively you can pass a ProseMirror <code>PluginKey</code>.</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    BubbleMenu.configure({
      pluginKey: new PluginKey('bubbleMenuOne'),
      element: document.querySelector('.menu-one'),
    }),
    BubbleMenu.configure({
      pluginKey: new PluginKey('bubbleMenuTwo'),
      element: document.querySelector('.menu-two'),
    }),
  ],
})
</code></pre>
<h1>文字カウント</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-character-count"><img src="https://img.shields.io/npm/v/@tiptap/extension-character-count.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-character-count?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-character-count.svg" alt="Downloads" /></a></p>

<p><code>CharacterCount</code>拡張機能は、許可される文字数を特定の長さに制限します。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-character-count
</code></pre>
<h2>設定</h2>
<h3>制限</h3>

<p>許可する必要のある最大文字数。</p>
<p>Default: <code>null</code></p>
<pre><code class="language-js">CharacterCount.configure({
  limit: 240,
})
</code></pre>
<h3>モード</h3>

<p>サイズが計算されるモード。</p>
<p>Default: <code>'textSize'</code></p>
<pre><code class="language-js">CharacterCount.configure({
  mode: 'nodeSize',
})
</code></pre>
<h2>ストレージ</h2>
<h3>characters()</h3>

<p>現在のドキュメントの文字数を取得します。</p>
<pre><code class="language-js">editor.storage.characterCount.characters()

// Get the size of a specific node.
editor.storage.characterCount.characters({ node: someCustomNode })

// Overwrite the default `mode`.
editor.storage.characterCount.characters({ mode: 'nodeSize' })
</code></pre>
<h3>words()</h3>

<p>現在のドキュメントの単語数を取得します。</p>
<pre><code class="language-js">editor.storage.characterCount.words()

// Get the number of words for a specific node.
editor.storage.characterCount.words({ node: someCustomNode })
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-character-count/">packages/extension-character-count/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/CharacterCount">https://embed.tiptap.dev/preview/Extensions/CharacterCount</a></p>
<h1>コラボレーション</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-collaboration"><img src="https://img.shields.io/npm/v/@tiptap/extension-collaboration.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-collaboration?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-collaboration.svg" alt="Downloads" /></a></p>


<p>コラボレーション拡張機能を使用すると、1つのドキュメントで他のユーザーとコラボレーションできます。実装は <a href="https://github.com/yjs/yjs">Y.jsbyKevin Jahns</a> に基づいています。これは、プロジェクトで <a href="/guide/collaborative-editing">コラボ編集の統合</a> の最も優れた機能です。</p>
<p>協調編集の設定では、履歴はまったく異なります。変更を元に戻す場合、他のユーザーの変更を元に戻す必要はありません。この動作を処理するために、この拡張機能は独自の <code>undo</code> および <code>redo</code> コマンドを提供します。競合を避けるために、デフォルトの <a href="/api/extensions/history"><code>History</code></a> 拡張機能をCollaboration拡張機能と一緒にロードしないでください。</p>

<blockquote>
<p><strong>proPro拡張機能</strong>
この拡張機能を本番環境で使用する場合は、<a href="/sponsor">私たちの仕事のスポンサー</a> にお願いします。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-collaboration yjs y-websocket
</code></pre>
<h2>設定</h2>
<h3>ドキュメント</h3>

<p>初期化された Y.js ドキュメント。</p>
<p>Default: <code>null</code></p>
<pre><code class="language-js">Collaboration.configure({
  document: new Y.Doc(),
})
</code></pre>
<h3>フィールド</h3>

<p>Y.js フラグメントの名前は、複数のフィールドを 1つの Y.js ドキュメントと同期するように変更できます。</p>
<p>Default: <code>'default'</code></p>
<pre><code class="language-js">Collaboration.configure({
  document: new Y.Doc(),
  field: 'title',
})
</code></pre>
<h3>フラグメント</h3>
<p>生の Y.js フラグメントは、<code>document</code> と <code>field</code> の代わりに使用できます。</p>

<p>Default: <code>null</code></p>
<pre><code class="language-js">Collaboration.configure({
  fragment: new Y.Doc().getXmlFragment('body'),
})
</code></pre>
<h2>コマンド</h2>
<p><code>Collboration</code> 拡張機能には、独自の履歴拡張機能が付属しています。<code>StarterKit</code> を使用している場合は、必ずデフォルトの拡張機能を無効にしてください。</p>

<h3>undo()</h3>

<p>最後の変更を元に戻します。</p>
<pre><code class="language-js">editor.commands.undo()
</code></pre>
<h3>redo()</h3>

<p>最後の変更をやり直します。</p>
<pre><code class="language-js">editor.commands.redo()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows / Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>undo()</td>
<td><code>Ctrl</code> + <code>Z</code></td>
<td><code>Cmd</code> + <code>Z</code></td>
</tr>
<tr>
<td>redo()</td>
<td><code>Shift</code> + <code>Ctrl</code> + <code>Z</code><code>Ctrl</code> + <code>Y</code></td>
<td><code>Shift</code> + <code>Cmd</code> + <code>Z</code><code>Cmd</code> + <code>Y</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-collaboration/">packages/extension-collaboration/</a></p>
<h2>使い方</h2>

<blockquote>
<p><strong>警告</strong>
このエディタの内容は他のユーザーと共有されます。</p>
</blockquote>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Collaboration?hideSource">https://embed.tiptap.dev/preview/Extensions/Collaboration?hideSource</a>
<a href="https://embed.tiptap.dev/preview/Extensions/Collaboration">https://embed.tiptap.dev/preview/Extensions/Collaboration</a></p>
<h1>コラボ編集のカーソル</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-collaboration-cursor"><img src="https://img.shields.io/npm/v/@tiptap/extension-collaboration-cursor.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-collaboration-cursor?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-collaboration-cursor.svg" alt="Downloads" /></a></p>


<p>この拡張機能は、接続されているすべてのユーザー（名前や指定された色など）、現在のカーソル位置、およびテキスト選択（存在する場合）に関する情報を追加します。</p>
<p>このページを複数のブラウザウィンドウで開いてテストします。</p>

<blockquote>
<p>pro Pro 拡張機能</p>
</blockquote>
<blockquote>
<p>この拡張機能を本番環境で使用する場合は、<a href="/sponsor">私たちの仕事のスポンサー</a> にお願いします。</p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-collaboration-cursor
</code></pre>

<p>この拡張機能には、<a href="/api/extensions/collaboration"><code>Collaboration</code></a> 拡張機能が必要です。</p>
<h2>設定</h2>
<h3>プロバイダー</h3>
<p>A Y.js network provider, for example a <a href="https://github.com/yjs/y-websocket">y-websocket</a> instance.</p>
<p>Y.js ネットワークプロバイダー。たとえば、<a href="https://github.com/yjs/y-websocket">y-websocket</a> インスタンス。</p>
<p>Default: <code>null</code></p>
<h3>ユーザー</h3>

<p>現在のユーザーの属性は、名前と色を想定していますが、任意の属性で使用できます。値は、接続されている他のすべてのクライアントと同期されます。</p>
<p>Default: <code>{ user: null, color: null }</code></p>
<h3>レンダー</h3>

<p>カーソルのレンダリング関数。例については、<a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-collaboration-cursor/">拡張ソースコード</a> を参照してください。</p>
<h2>コマンド</h2>
<h3>updateUser()</h3>

<p>現在のユーザーの属性が更新されたオブジェクトを渡します。<code>name</code> と <code>color</code> を想定していますが、フィールドを追加することもできます。</p>
<pre><code class="language-js">editor.commands.updateUser({
  name: 'John Doe',
  color: '#000000',
  avatar: 'https://unavatar.io/github/ueberdosis',
})
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-collaboration-cursor/">packages/extension-collaboration-cursor/</a></p>
<h2>使い方</h2>

<blockquote>
<p>このエディタの内容は他のユーザーと共有されます。</p>
</blockquote>
<p><a href="https://embed.tiptap.dev/preview/Extensions/CollaborationCursor?hideSource">https://embed.tiptap.dev/preview/Extensions/CollaborationCursor?hideSource</a>
<a href="https://embed.tiptap.dev/preview/Extensions/CollaborationCursor">https://embed.tiptap.dev/preview/Extensions/CollaborationCursor</a></p>
<h1>Color</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-color"><img src="https://img.shields.io/npm/v/@tiptap/extension-color.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-color?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-color.svg" alt="Downloads" /></a></p>

<p>この拡張機能を使用すると、エディターでフォントの色を設定できます。 <a href="/api/marks/text-style"><code>TextStyle</code></a> マークを使用して、<code>&lt;span&gt;</code>タグ（およびそれのみ）をレンダリングします。次に、フォントの色がインラインスタイルとして適用されます（例：<code>&lt;span style=&quot;color: #958DF1&quot;&gt;</code>）。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-text-style @tiptap/extension-color
</code></pre>
<p>This extension requires the <a href="/api/marks/text-style"><code>TextStyle</code></a> mark.</p>
<p>この拡張機能には、<a href="/api/marks/text-style"><code>TextStyle</code></a> マークが必要です。</p>
<h2>設定</h2>
<h3>types</h3>

<p>color 属性を適用する必要があるマークのリスト。</p>
<p>Default: <code>['textStyle']</code></p>
<pre><code class="language-js">Color.configure({
  types: ['textStyle'],
})
</code></pre>
<h2>コマンド</h2>
<h3>setColor()</h3>

<p>指定されたフォントの色をインラインスタイルとして適用します。</p>
<pre><code class="language-js">editor.commands.setColor('#ff0000')
</code></pre>
<h3>unsetColor()</h3>

<p>フォントの色を削除します。</p>
<pre><code class="language-js">editor.commands.unsetColor()
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-color/">packages/extension-color/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Color">https://embed.tiptap.dev/preview/Extensions/Color</a></p>
<h1>ドロップカーソル</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-dropcursor"><img src="https://img.shields.io/npm/v/@tiptap/extension-dropcursor.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-dropcursor?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-dropcursor.svg" alt="Downloads" /></a></p>
<p>This extension loads the <a href="https://github.com/ProseMirror/prosemirror-dropcursor">ProseMirror Dropcursor plugin</a> by Marijn Haverbeke, which shows a cursor at the drop position when something is dragged into the editor.</p>
<p>Note that Tiptap is headless, but the dropcursor needs CSS for its appearance. There are settings for the color and width, and you’re free to add a custom CSS class.</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-dropcursor
</code></pre>
<h2>設定</h2>
<h3>color</h3>

<p>ドロップカーソルの色。</p>
<p>Default: <code>'currentcolor'</code></p>
<pre><code class="language-js">Dropcursor.configure({
  color: '#ff0000'
})
</code></pre>
<h3>width</h3>

<p>ドロップカーソルの幅。</p>
<p>Default: <code>1</code></p>
<pre><code class="language-js">Dropcursor.configure({
  width: 2,
})
</code></pre>
<h3>class</h3>

<p>ドロップカーソルに適用する必要がある1つまたは複数のCSSクラス。</p>
<pre><code class="language-js">Dropcursor.configure({
  class: 'my-custom-class',
})
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-dropcursor/">packages/extension-dropcursor/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Dropcursor">https://embed.tiptap.dev/preview/Extensions/Dropcursor</a></p>
<h1>フローティングメニュー</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-floating-menu"><img src="https://img.shields.io/npm/v/@tiptap/extension-floating-menu.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-floating-menu?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-floating-menu.svg" alt="Downloads" /></a></p>

<p>この拡張機能により、選択したテキストの近くにコンテキストメニューが表示されます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-floating-menu
</code></pre>
<h2>設定</h2>
<h3>element</h3>

<p>メニューを含むDOM要素。</p>
<p>Type: <code>HTMLElement</code></p>
<p>Default: <code>null</code></p>
<h3>tippyOptions</h3>

<p>内部的には、<code>FloatingMenu</code> は <a href="https://atomiks.github.io/tippyjs/v6/all-props/">tippy.js</a> を使用します。オプションを直接渡すことができます。</p>
<p>Type: <code>Object</code></p>
<p>Default: <code>{}</code></p>
<h3>pluginKey</h3>

<p>基盤となる ProseMirror プラグインのキー。複数のインスタンスを追加する場合は、必ず異なるキーを使用してください。</p>
<p>Type: <code>string | PluginKey</code></p>
<p>Default: <code>'floatingMenu'</code></p>
<h3>shouldShow</h3>

<p>メニューを表示するかどうかを制御するためのコールバック。</p>
<p>Type: <code>(props) =&gt; boolean</code></p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-floating-menu/">packages/extension-floating-menu/</a></p>
<h2>Vanilla JavaScript の使用</h2>
<pre><code class="language-js">
new Editor({
  extensions: [
    FloatingMenu.configure({
      element: document.querySelector('.menu'),
    }),
  ],
})
</code></pre>
<h2>フレームワークの使用</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/FloatingMenu">https://embed.tiptap.dev/preview/Extensions/FloatingMenu</a></p>
<h3>カスタムロジック</h3>
<p><code>shouldShow</code> オプションを使用してメニューを表示するためのロジックをカスタマイズします。コンポーネントの場合、<code>shouldShow</code> を小道具として渡すことができます。</p>

<pre><code class="language-js">FloatingMenu.configure({
  shouldShow: ({ editor, view, state, oldState }) =&gt; {
    // show the floating within any paragraph
    return editor.isActive('paragraph')
  },
})
</code></pre>
<h3>複数のメニュー</h3>

<p>一意の <code>pluginKey</code> を設定して、複数のメニューを使用します。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    FloatingMenu.configure({
      pluginKey: 'floatingMenuOne',
      element: document.querySelector('.menu-one'),
    }),
    FloatingMenu.configure({
      pluginKey: 'floatingMenuTwo',
      element: document.querySelector('.menu-two'),
    }),
  ],
})
</code></pre>

<p>または、ProseMirror <code>PluginKey</code> を渡すこともできます。</p>
<pre><code class="language-js">
new Editor({
  extensions: [
    FloatingMenu.configure({
      pluginKey: new PluginKey('floatingMenuOne'),
      element: document.querySelector('.menu-one'),
    }),
    FloatingMenu.configure({
      pluginKey: new PluginKey('floatingMenuOne'),
      element: document.querySelector('.menu-two'),
    }),
  ],
})
</code></pre>
<h1>フォーカス</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-focus"><img src="https://img.shields.io/npm/v/@tiptap/extension-focus.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-focus?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-focus.svg" alt="Downloads" /></a></p>


<p>Focus 拡張機能は、フォーカスされたノードに CSS クラスを追加します。デフォルトでは <code>.has-focus</code> が追加されますが、これは変更できます。</p>
<p>これはクラスにすぎないことに注意してください。スタイリングは完全にあなた次第です。以下の使用例には、そのクラスの CSS がいくつかあります。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-focus
</code></pre>
<h2>設定</h2>
<h3>className</h3>

<p>フォーカスされた要素に適用されるクラス。</p>
<p>Default: <code>'has-focus'</code></p>
<pre><code class="language-js">Focus.configure({
  className: 'focus',
})
</code></pre>
<h3>mode</h3>

<p>クラスを <code>'all'</code>、<code>'shallowest'</code>、または <code>'deepest'</code> ノードに適用します。</p>
<p>Default: <code>'all'</code></p>
<pre><code class="language-js">Focus.configure({
  mode: 'deepest',
})
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-focus/">packages/extension-focus/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Focus">https://embed.tiptap.dev/preview/Extensions/Focus</a></p>
<h1>フォントファミリー</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-font-family"><img src="https://img.shields.io/npm/v/@tiptap/extension-font-family.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-font-family?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-font-family.svg" alt="Downloads" /></a></p>

<p>この拡張機能を使用すると、エディターでフォントファミリーを設定できます。<a href="/api/marks/text-style"><code>TextStyle</code></a> マークを使用して、<code>&lt;span&gt;</code> タグをレンダリングします。フォントファミリーはインラインスタイルとして適用されます（例：<code>&lt;span style=&quot;font-family: Arial&quot;&gt;</code>）。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-text-style @tiptap/extension-font-family
</code></pre>

<p>この拡張機能には、<a href="/api/marks/text-style"><code>TextStyle</code></a> マークが必要です。</p>
<h2>設定</h2>
<h3>types</h3>

<p>フォントファミリー属性を適用するマークのリスト。</p>
<p>Default: <code>['textStyle']</code></p>
<pre><code class="language-js">FontFamily.configure({
  types: ['textStyle'],
})
</code></pre>
<h2>コマンド</h2>
<h3>setFontFamily()</h3>

<p>指定されたフォントファミリをインラインスタイルとして適用します。</p>
<pre><code class="language-js">editor.commands.setFontFamily('Inter')
</code></pre>
<h3>unsetFontFamily()</h3>

<p>フォントファミリーを削除します。</p>
<pre><code class="language-js">editor.commands.unsetFontFamily()
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-font-family/">packages/extension-font-family/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/FontFamily">https://embed.tiptap.dev/preview/Extensions/FontFamily</a></p>
<h1>Gapcursor</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-gapcursor"><img src="https://img.shields.io/npm/v/@tiptap/extension-gapcursor.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-gapcursor?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-gapcursor.svg" alt="Downloads" /></a></p>

<p>Note that Tiptap is headless, but the gapcursor needs CSS for its appearance. The <a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core/src/style.ts">default CSS</a> is loaded through the Editor class.</p>
<p>この拡張機能は、Marijn Haverbeke による<a href="https://github.com/ProseMirror/prosemirror-gapcursor">ProseMirrorGapcursor プラグイン</a> をロードします。これにより、通常の選択ができない場所にカーソルのギャップが追加されます。たとえば、ドキュメントの最後にあるテーブルの後などです。</p>
<p>Tiptap はヘッドレスですが、gapcursor の外観には CSS が必要です。 <a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core/src/style.ts">デフォルトのCSS</a> は、Editor クラスを介して読み込まれます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-gapcursor
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-gapcursor/">packages/extension-gapcursor/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Gapcursor">https://embed.tiptap.dev/preview/Extensions/Gapcursor</a></p>
<h1>History</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-history"><img src="https://img.shields.io/npm/v/@tiptap/extension-history.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-history?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-history.svg" alt="Downloads" /></a></p>

<p>この拡張機能は、履歴サポートを提供します。ドキュメントへのすべての変更は追跡され、<code>undo</code> で削除できます。取り消された変更は、<code>redo</code> で再度適用できます。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-history
</code></pre>
<h2>設定</h2>
<h3>depth</h3>

<p>最も古いイベントが破棄される前に収集された履歴イベントの量。デフォルトは「100」となります。</p>
<p>Default: <code>100</code></p>
<pre><code class="language-js">History.configure({
  depth: 10,
})
</code></pre>
<h3>newGroupDelay</h3>

<p>新しいグループを開始する必要がある変更間の遅延（ミリ秒単位）。変更が隣接していない場合、新しいグループが常に開始されます。</p>
<p>Default: <code>500</code></p>
<pre><code class="language-js">History.configure({
  newGroupDelay: 1000,
})
</code></pre>
<h2>Commands</h2>
<h3>undo()</h3>

<p>最後の変更を元に戻します。</p>
<pre><code class="language-js">editor.commands.undo()
</code></pre>
<h3>redo()</h3>

<p>最後の変更をやり直します。</p>
<pre><code class="language-js">editor.commands.redo()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>Command</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>undo()</td>
<td><code>Control</code> + <code>Z</code><code>Control</code> + <code>R</code></td>
<td><code>Cmd</code> + <code>Z</code><code>Cmd</code> + <code>R</code></td>
</tr>
<tr>
<td>redo()</td>
<td><code>Shift</code> + <code>Control</code> + <code>Z</code><code>Control</code> + <code>Y</code><code>Shift</code> + <code>Control</code> + <code>R</code></td>
<td><code>Shift</code> + <code>Cmd</code> + <code>Z</code><code>Cmd</code> + <code>Y</code><code>Shift</code> + <code>Cmd</code> + <code>R</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-history/">packages/extension-history/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/History">https://embed.tiptap.dev/preview/Extensions/History</a></p>
<h1>プレースホルダー</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-placeholder"><img src="https://img.shields.io/npm/v/@tiptap/extension-placeholder.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-placeholder?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-placeholder.svg" alt="Downloads" /></a></p>

<p>この拡張機能は、プレースホルダーのサポートを提供します。小さなヒントを使って、ユーザーに何を書くべきかを考えさせます。必要に応じて、カスタマイズできるものがいくつかあります。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-placeholder
</code></pre>
<h2>設定</h2>
<h3>emptyEditorClass</h3>

<p>エディターが空の場合に追加された CSS クラス。</p>
<p>Default: <code>'is-editor-empty'</code></p>
<pre><code class="language-js">Placeholder.configure({
  emptyEditorClass: 'is-editor-empty',
})
</code></pre>
<h3>emptyNodeClass</h3>

<p>ノードが空の場合に追加された CSS クラス。</p>
<p>Default: <code>'is-empty'</code></p>
<pre><code class="language-js">Placeholder.configure({
  emptyNodeClass: 'my-custom-is-empty-class',
})
</code></pre>
<h3>placeholder</h3>

<p><code>data-placeholder</code> 属性として追加されたプレースホルダーテキスト。</p>
<p>Default: <code>'Write something …'</code></p>
<pre><code class="language-js">Placeholder.configure({
  placeholder: 'My Custom Placeholder',
})
</code></pre>

<p>ノードに応じて、関数を使用してプレースホルダーを追加することもできます。</p>
<pre><code class="language-js">Placeholder.configure({
  placeholder: ({ node }) =&gt; {
    if (node.type.name === 'heading') {
      return 'What’s the title?'
    }

    return 'Can you add some further context?'
  },
})
</code></pre>
<h3>showOnlyWhenEditable</h3>

<p>エディターが編集可能な場合にのみ装飾を表示します。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">Placeholder.configure({
  showOnlyWhenEditable: false,
})
</code></pre>
<h3>showOnlyCurrent</h3>

<p>現在選択されているノードにのみ装飾を表示します。</p>
<p>Default: <code>true</code></p>
<pre><code class="language-js">Placeholder.configure({
  showOnlyCurrent: false
})
</code></pre>
<h3>includeChildren</h3>

<p>ネストされたノードの装飾も表示します。</p>
<p>Default: <code>false</code></p>
<pre><code class="language-js">Placeholder.configure({
  includeChildren: true
})
</code></pre>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-placeholder/">packages/extension-placeholder/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Placeholder">https://embed.tiptap.dev/preview/Extensions/Placeholder</a></p>
<h1>StarterKit</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/starter-kit"><img src="https://img.shields.io/npm/v/@tiptap/starter-kit.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/starter-kit?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/starter-kit.svg" alt="Downloads" /></a></p>

<p><code>StarterKit</code> は、最も人気のある Tiptap 拡張機能のコレクションです。始めたばかりの場合は、この拡張機能が最適です。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/starter-kit
</code></pre>
<h2>含まれている拡張機能</h2>
<h3>Nodes</h3>
<ul>
<li>
<a href="/api/nodes/blockquote"><code>Blockquote</code></a>
</li>
<li>
<a href="/api/nodes/bullet-list"><code>BulletList</code></a>
</li>
<li>
<a href="/api/nodes/code-block"><code>CodeBlock</code></a>
</li>
<li>
<a href="/api/nodes/document"><code>Document</code></a>
</li>
<li>
<a href="/api/nodes/hard-break"><code>HardBreak</code></a>
</li>
<li>
<a href="/api/nodes/heading"><code>Heading</code></a>
</li>
<li>
<a href="/api/nodes/horizontal-rule"><code>HorizontalRule</code></a>
</li>
<li>
<a href="/api/nodes/list-item"><code>ListItem</code></a>
</li>
<li>
<a href="/api/nodes/ordered-list"><code>OrderedList</code></a>
</li>
<li>
<a href="/api/nodes/paragraph"><code>Paragraph</code></a>
</li>
<li>
<a href="/api/nodes/text"><code>Text</code></a>
</li>
</ul>
<h3>Marks</h3>
<ul>
<li>
<a href="/api/marks/bold"><code>Bold</code></a>
</li>
<li>
<a href="/api/marks/code"><code>Code</code></a>
</li>
<li>
<a href="/api/marks/italic"><code>Italic</code></a>
</li>
<li>
<a href="/api/marks/strike"><code>Strike</code></a>
</li>
</ul>
<h3>Extensions</h3>
<ul>
<li>
<a href="/api/extensions/dropcursor"><code>Dropcursor</code></a>
</li>
<li>
<a href="/api/extensions/gapcursor"><code>Gapcursor</code></a>
</li>
<li>
<a href="/api/extensions/history"><code>History</code></a>
</li>
</ul>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/starter-kit/">packages/starter-kit/</a></p>
<h2>使い方</h2>

<p><code>StarterKit</code> をエディタに渡して、含まれているすべての拡張機能を一度にロードします。</p>
<pre><code class="language-js">
const editor = new Editor({
  content: '&lt;p&gt;Example Text&lt;/p&gt;',
  extensions: [
    StarterKit,
  ],
})
</code></pre>

<p>以下に示すように、含まれている拡張機能を構成したり、いくつかの拡張機能を無効にしたりすることもできます。</p>
<pre><code class="language-js">
const editor = new Editor({
  content: '&lt;p&gt;Example Text&lt;/p&gt;',
  extensions: [
    StarterKit.configure({
      // Disable an included extension
      history: false,

      // Configure an included extension
      heading: {
        levels: [1, 2],
      },
    }),
  ],
})
</code></pre>
<h1>TextAlign</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-text-align"><img src="https://img.shields.io/npm/v/@tiptap/extension-text-align.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-text-align?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-text-align.svg" alt="Downloads" /></a></p>

<p>この拡張機能は、指定されたノードのリストにテキスト整列属性を追加します。この属性は、テキストを揃えるために使用されます。</p>

<blockquote>
<p><strong>Firefoxのバグを警告する</strong>
<code>text-align: justify</code> は Firefox の<code> white-space: pre-wrap</code> と一緒に機能しません。<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1253840">これは既知の問題です</a></p>
</blockquote>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-text-align
</code></pre>
<h2>設定</h2>
<h3>types</h3>

<p>テキスト整列属性を適用する必要があるノードのリスト。通常、<code>['heading', 'paragraph']</code> のようなものです。</p>
<p>Default: <code>[]</code></p>
<pre><code class="language-js">TextAlign.configure({
  types: ['heading', 'paragraph'],
})
</code></pre>
<h3>alignments</h3>

<p>テキスト整列属性で使用可能なオプションのリスト。</p>
<p>Default: <code>['left', 'center', 'right', 'justify']</code></p>
<pre><code class="language-js">TextAlign.configure({
  alignments: ['left', 'right'],
})
</code></pre>
<h3>defaultAlignment</h3>

<p>デフォルトのテキスト整列。</p>
<p>Default: <code>'left'</code></p>
<pre><code class="language-js">TextAlign.configure({
  defaultAlignment: 'right',
})
</code></pre>
<h2>コマンド</h2>
<h3>setTextAlign()</h3>

<p>テキストを指定された値に揃えます。</p>
<pre><code class="language-js">editor.commands.setTextAlign('right')
</code></pre>
<h3>unsetTextAlign()</h3>

<p>テキスト整列値を削除します。</p>
<pre><code class="language-js">editor.commands.unsetTextAlign()
</code></pre>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTextAlign('left')</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>L</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>L</code></td>
</tr>
<tr>
<td>setTextAlign('center')</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>E</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>E</code></td>
</tr>
<tr>
<td>setTextAlign('right')</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>R</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>R</code></td>
</tr>
<tr>
<td>setTextAlign('justify')</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>J</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>J</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-text-align/">packages/extension-text-align/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/TextAlign">https://embed.tiptap.dev/preview/Extensions/TextAlign</a></p>
<h1>タイポグラフィ</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/extension-typography"><img src="https://img.shields.io/npm/v/@tiptap/extension-typography.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/extension-typography?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/extension-typography.svg" alt="Downloads" /></a></p>

<p>この拡張機能は、正しい活版印刷文字を使用した一般的なテキストパターンを支援しようとします。内部的には、すべてのルールは入力ルールです。</p>
<h2>インストール</h2>
<pre><code class="language-bash">npm install @tiptap/extension-typography
</code></pre>
<h2>ルール</h2>
<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>emDash</td>
<td>二重ダッシュ <code>--</code> を emdash <code>—</code> に変換</td>
</tr>
<tr>
<td>ellipsis</td>
<td>3つのドット <code>...</code> を省略記号 <code>…</code> に変換</td>
</tr>
<tr>
<td>openDoubleQuote</td>
<td>二重引用符で始める</td>
</tr>
<tr>
<td>closeDoubleQuote</td>
<td>二重引用符で閉じる</td>
</tr>
<tr>
<td>openSingleQuote</td>
<td>一重引用符で始める</td>
</tr>
<tr>
<td>closeSingleQuote</td>
<td>一重引用符で閉じる</td>
</tr>
<tr>
<td>leftArrow</td>
<td><code>&lt;-</code> を矢印<code>←</code>に変換</td>
</tr>
<tr>
<td>rightArrow</td>
<td><code>-&gt;</code> 矢印<code>→</code>に変換</td>
</tr>
<tr>
<td>copyright</td>
<td><code>(c)</code> を著作権記号 <code>©</code> に変換</td>
</tr>
<tr>
<td>registeredTrademark</td>
<td><code>(r)</code> を登録商標記号 <code>®</code> に変換</td>
</tr>
<tr>
<td>trademark</td>
<td><code>(tm)</code> を登録商標記号 <code>™</code> に変換</td>
</tr>
<tr>
<td>oneHalf</td>
<td><code>1/2</code> を <code>½</code> に変換</td>
</tr>
<tr>
<td>oneQuarter</td>
<td><code>1/4</code> を <code>¼</code> に変換</td>
</tr>
<tr>
<td>threeQuarters</td>
<td><code>3/4</code> を<code>¾</code> に変換</td>
</tr>
<tr>
<td>plusMinus</td>
<td><code>+/-</code> を <code>±</code> に変換</td>
</tr>
<tr>
<td>notEqual</td>
<td><code>!=</code> を <code>≠</code> に変換</td>
</tr>
<tr>
<td>laquo</td>
<td><code>&lt;&lt;</code> を <code>«</code> に変換</td>
</tr>
<tr>
<td>raquo</td>
<td><code>&gt;&gt;</code> を <code>»</code> に変換</td>
</tr>
<tr>
<td>multiplication</td>
<td><code>2 * 3</code> または <code>2x3</code> を <code>2×3</code> に変換</td>
</tr>
<tr>
<td>superscriptTwo</td>
<td><code>^2</code> を <code>²</code> に変換</td>
</tr>
<tr>
<td>superscriptThree</td>
<td><code>^3</code> を <code>³</code> に変換</td>
</tr>
</tbody>
</table>
<h2>キーボード ショートカット</h2>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>undoInputRule()</td>
<td><code>Backspace</code></td>
<td><code>Backspace</code></td>
</tr>
</tbody>
</table>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/extension-typography/">packages/extension-typography/</a></p>
<h2>使い方</h2>
<p><a href="https://embed.tiptap.dev/preview/Extensions/Typography">https://embed.tiptap.dev/preview/Extensions/Typography</a></p>
<h3>ルールの無効化</h3>

<p>以下に示すように、含まれているルールを構成したり、いくつかのルールを無効にしたりすることもできます。</p>
<pre><code class="language-js">
const editor = new Editor({
  extensions: [
    // Disable some included rules
    Typography.configure({
      oneHalf: false,
      oneQuarter: false,
      threeQuarters: false,
    }),
  ],
})
</code></pre>
<h1>HTML</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/html"><img src="https://img.shields.io/npm/v/@tiptap/html.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/html?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/html.svg" alt="Downloads" /></a></p>


<p>このユーティリティは、JSON コンテンツを HTML としてレンダリングします。サーバー側でエディターインスタンスを使用せずに HTML から JSON を生成するのに役立ちます。</p>
<p>必要なのは、JSON または HTML 文字列と、拡張機能のリストだけです。</p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/html/">packages/html/</a></p>
<h2>JSONからHTMLを生成する</h2>
<p><a href="https://embed.tiptap.dev/preview/GuideContent/GenerateHTML">https://embed.tiptap.dev/preview/GuideContent/GenerateHTML</a></p>
<h2>HTMLからJSONを生成する</h2>
<p><a href="https://embed.tiptap.dev/preview/GuideContent/GenerateJSON">https://embed.tiptap.dev/preview/GuideContent/GenerateJSON</a></p>
<h1>Suggestion</h1>
<p><a href="https://www.npmjs.com/package/@tiptap/suggestion"><img src="https://img.shields.io/npm/v/@tiptap/suggestion.svg?label=version" alt="Version" /></a>
<a href="https://npmcharts.com/compare/@tiptap/suggestion?minimal=true"><img src="https://img.shields.io/npm/dm/@tiptap/suggestion.svg" alt="Downloads" /></a></p>

<p>このユーティリティは、エディタでのあらゆる種類の提案に役立ちます。 <a href="/api/nodes/mention"><code>Mention</code></a>、 <a href="/api/nodes/hashtag"><code>Hashtag</code></a> または <a href="/api/nodes/emoji"><code>Emoji</code></a> ノードを見てください動作中。</p>
<h2>設定</h2>
<h3>char</h3>

<p>オートコンプリートポップアップをトリガーする文字。</p>
<p>Default: <code>'@'</code></p>
<h3>pluginKey</h3>

<p>ProseMirror の プラグインキー。</p>
<p>Default: <code>SuggestionPluginKey</code></p>
<h3>allowSpaces</h3>

<p>提案されたアイテムのスペースを許可または禁止します。</p>
<p>Default: <code>false</code></p>
<h3>allowedPrefixes</h3>

<p>提案をトリガーできるプレフィックス文字。 <code>null</code> に設定すると、任意のプレフィックス文字が許可されます。</p>
<p>Default: <code>[' ']</code></p>
<h3>startOfLine</h3>

<p>行の先頭でのみオートコンプリートポップアップをトリガーします。</p>
<p>Default: <code>false</code></p>
<h3>decorationTag</h3>

<p>提案のためにレンダリングする必要のある HTML タグ。</p>
<p>Default: <code>'span'</code></p>
<h3>decorationClass</h3>

<p>提案に追加する必要がある CSS クラス。</p>
<p>Default: <code>'suggestion'</code></p>
<h3>command</h3>

<p>提案が選択されたときに実行されます。</p>
<p>Default: <code>() =&gt; {}'</code></p>
<h3>items</h3>

<p>フィルタリングされた提案の配列を渡します。非同期にすることができます。</p>
<p>Default: <code>({ editor, query }) =&gt; []</code></p>
<h3>render</h3>

<p>オートコンプリートポップアップのレンダリング機能。</p>
<p>Default: <code>() =&gt; ({})</code></p>
<h2>ソースコード</h2>
<p><a href="https://github.com/ueberdosis/tiptap/blob/main/packages/suggestion/">packages/suggestion/</a></p>
<h1>Tiptap for PHP</h1>
<p><a href="https://packagist.org/packages/ueberdosis/tiptap-php"><img src="https://img.shields.io/packagist/v/ueberdosis/tiptap-php.svg" alt="Latest Version on Packagist" /></a>
<a href="https://packagist.org/packages/ueberdosis/tiptap-php"><img src="https://img.shields.io/packagist/dt/ueberdosis/tiptap-php.svg" alt="Total Downloads" /></a></p>
<h2>はじめに</h2>
<p>A PHP package to work with <a href="https://tiptap.dev/">Tiptap</a> content. You can transform Tiptap-compatible JSON to HTML, and the other way around, sanitize your content, or just modify it.</p>
<p>[Tiptap]（https://tiptap.dev/）コンテンツを処理するためのPHPパッケージ。 Tiptap互換のJSONをHTMLに変換したり、その逆を行ったり、コンテンツをサニタイズしたり、単に変更したりすることができます。</p>
<h2>インストール</h2>
<p>You can install the package via composer:</p>
<p>パッケージはcomposerを介してインストールできます。</p>
<pre><code class="language-bash">composer require ueberdosis/tiptap-php
</code></pre>
<h2>使い方</h2>
<p>The PHP package mimics large parts of the JavaScript package. If you know your way around Tiptap, the PHP syntax will feel familiar to you. Here is an easy example:</p>
<p>PHPパッケージは、JavaScriptパッケージの大部分を模倣しています。 Tiptapの使い方を知っているなら、PHP構文はあなたに馴染みがあると感じるでしょう。簡単な例を次に示します。</p>
<pre><code class="language-php">(new Tiptap\Editor)
    -&gt;setContent('&lt;p&gt;Example Text&lt;/p&gt;')
    -&gt;getDocument();

// Returns:
// ['type' =&gt; 'doc', 'content' =&gt; …]
</code></pre>
<h2>ドキュメンテーション</h2>
<p>There’s a lot more the PHP package can do. Check out the <a href="https://github.com/ueberdosis/tiptap-php">repository on GitHub</a>.</p>
<p>PHPパッケージでできることは他にもたくさんあります。 [GitHubのリポジトリ]（https://github.com/ueberdosis/tiptap-php）を確認してください。</p>
<h1>キーボード ショートカット</h1>
<h2>はじめに</h2>


<p>Tiptap には、実用的なキーボードショートカットのデフォルトが付属しています。 用途に応じて、これらのキーボードショートカットを好みに合わせて変更することをお勧めします。 私たちがあなたのために定義したものを見て、それを変更する方法を示しましょう！</p>
<p><a href="https://mouseless.app">キーボードショートカット学習アプリ</a> を作成しました。これに、多数のツールの何千ものキーボードショートカットの演習を手動で追加しました。</p>
<h2>事前に定義されたキーボードショートカット</h2>
<p>ほとんどのコア拡張機能は、独自のキーボードショートカットを登録します。 使用する拡張機能のセットによっては、以下にリストされているキーボードショートカットのすべてがエディターで機能するわけではありません。</p>

<h3>よく使うショートカット</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Copy</td>
<td><code>Ctrl</code> + <code>C</code></td>
<td><code>Cmd</code> + <code>C</code></td>
</tr>
<tr>
<td>Cut</td>
<td><code>Ctrl</code> + <code>X</code></td>
<td><code>Cmd</code> + <code>X</code></td>
</tr>
<tr>
<td>Paste</td>
<td><code>Ctrl</code> + <code>V</code></td>
<td><code>Cmd</code> + <code>V</code></td>
</tr>
<tr>
<td>Paste without formatting</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>V</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>V</code></td>
</tr>
<tr>
<td>Undo</td>
<td><code>Ctrl</code> + <code>Z</code></td>
<td><code>Cmd</code> + <code>Z</code></td>
</tr>
<tr>
<td>Redo</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Z</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>Z</code></td>
</tr>
<tr>
<td>Add a line break</td>
<td><code>Shift</code> + <code>Enter</code></td>
<td><code>Shift</code> + <code>Enter</code></td>
</tr>
</tbody>
</table>
<h3>テキスト フォーマット</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bold</td>
<td><code>Ctrl</code> + <code>B</code></td>
<td><code>Cmd</code> + <code>B</code></td>
</tr>
<tr>
<td>Italicize</td>
<td><code>Ctrl</code> + <code>I</code></td>
<td><code>Cmd</code> + <code>I</code></td>
</tr>
<tr>
<td>Underline</td>
<td><code>Ctrl</code> + <code>U</code></td>
<td><code>Cmd</code> + <code>U</code></td>
</tr>
<tr>
<td>Strikethrough</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>X</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>X</code></td>
</tr>
<tr>
<td>Highlight</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>H</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>H</code></td>
</tr>
<tr>
<td>Code</td>
<td><code>Ctrl</code> + <code>E</code></td>
<td><code>Cmd</code> + <code>E</code></td>
</tr>
</tbody>
</table>
<h3>パラグラフ フォーマット</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apply normal text style</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>0</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>0</code></td>
</tr>
<tr>
<td>Apply heading style 1</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>1</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>1</code></td>
</tr>
<tr>
<td>Apply heading style 2</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>2</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>2</code></td>
</tr>
<tr>
<td>Apply heading style 3</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>3</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>3</code></td>
</tr>
<tr>
<td>Apply heading style 4</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>4</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>4</code></td>
</tr>
<tr>
<td>Apply heading style 5</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>5</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>5</code></td>
</tr>
<tr>
<td>Apply heading style 6</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>6</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>6</code></td>
</tr>
<tr>
<td>Ordered list</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>7</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>7</code></td>
</tr>
<tr>
<td>Bullet list</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>8</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>8</code></td>
</tr>
<tr>
<td>Task list</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>9</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>9</code></td>
</tr>
<tr>
<td>Blockquote</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>B</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>B</code></td>
</tr>
<tr>
<td>Left align</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>L</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>L</code></td>
</tr>
<tr>
<td>Center align</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>E</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>E</code></td>
</tr>
<tr>
<td>Right align</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>R</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>R</code></td>
</tr>
<tr>
<td>Justify</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>J</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>J</code></td>
</tr>
<tr>
<td>Code block</td>
<td><code>Ctrl</code> + <code>Alt</code> + <code>C</code></td>
<td><code>Cmd</code> + <code>Alt</code> + <code>C</code></td>
</tr>
<tr>
<td>Subscript</td>
<td><code>Ctrl</code> + <code>,</code></td>
<td><code>Cmd</code> + <code>,</code></td>
</tr>
<tr>
<td>Superscript</td>
<td><code>Ctrl</code> + <code>.</code></td>
<td><code>Cmd</code> + <code>.</code></td>
</tr>
</tbody>
</table>

<h3>テキストの選択</h3>
<table>
<thead>
<tr>
<th>コマンド</th>
<th>Windows/Linux</th>
<th>macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>すべてを選択</td>
<td><code>Ctrl</code> + <code>A</code></td>
<td><code>Cmd</code> + <code>A</code></td>
</tr>
<tr>
<td>選択範囲を1文字左に拡張</td>
<td><code>Shift</code> + <code>←</code></td>
<td><code>Shift</code> + <code>←</code></td>
</tr>
<tr>
<td>選択範囲を1文字右に拡張</td>
<td><code>Shift</code> + <code>→</code></td>
<td><code>Shift</code> + <code>→</code></td>
</tr>
<tr>
<td>選択範囲を1列に拡張</td>
<td><code>Shift</code> + <code>↑</code></td>
<td><code>Shift</code> + <code>↑</code></td>
</tr>
<tr>
<td>選択範囲を1行下に拡張</td>
<td><code>Shift</code> + <code>↓</code></td>
<td><code>Shift</code> + <code>↓</code></td>
</tr>
<tr>
<td>選択範囲をドキュメントの先頭まで拡張</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>↑</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>↑</code></td>
</tr>
<tr>
<td>選択範囲をドキュメントの最後まで拡張</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>↓</code></td>
<td><code>Cmd</code> + <code>Shift</code> + <code>↓</code></td>
</tr>
</tbody>
</table>
<h2>ショートカットの上書き</h2>





<p>キーボードショートカットは、<code>'Shift-Control-Enter'</code> のような文字列にすることができます。 キーは、<code>-</code> と連結された <code>event.key</code> に表示できる文字列に基づいています。<a href="https://keycode.info/">keycode.info</a> と呼ばれる小さなツールがあり、<code>event.key</code> をインタラクティブに表示します。</p>
<p>文字キー（または Shift キーを押したままにする場合は大文字）を参照するには、小文字を使用します。  のエイリアスとして <code>Space</code> を使用できます。</p>
<p>修飾子は任意の順序で指定できます。<code>Shift</code>、<code>Alt</code>、<code>Control</code>、<code>Cmd</code> が認識されます。 Shift キーを押しながら作成された文字の場合、<code>Shift</code> プレフィックスが暗黙指定されているため、明示的に追加しないでください。</p>
<p>Mac では <code>Cmd</code>、その他のプラットフォームでは <code>Control</code> の省略形として <code>Mod</code> を使用できます。</p>
<p>既存の拡張機能のキーボードショートカットを上書きする方法の例を次に示します。</p>
<pre><code class="language-js">// 1. Import the extension

// 2. Overwrite the keyboard shortcuts
const CustomBulletList = BulletList.extend({
  addKeyboardShortcuts() {
    return {
      // ↓ your new keyboard shortcut
      'Mod-l': () =&gt; this.editor.commands.toggleBulletList(),
    }
  },
})

// 3. Add the custom extension to your editor
new Editor({
  extensions: [
    CustomBulletList(),
    // …
  ],
})
</code></pre>
<h1>スキーマ</h1>
<h2>はじめに</h2>



<p>他の多くのエディターとは異なり、Tiptap はコンテンツの構造を定義する <a href="https://prosemirror.net/docs/guide/#schema">スキーマ</a> に基づいています。これにより、ドキュメントで発生する可能性のあるノードの種類、その属性、およびそれらをネストする方法を定義できます。</p>
<p>このスキーマは <em>非常に</em> 厳密です。スキーマで定義されていない HTML 要素または属性を使用することはできません。</p>
<p>一例を挙げましょう。「これは 重要  」のようなものを Tiptap に貼り付けても、「strong」タグを処理する拡張子がない場合は、「これは 重要」と表示されるだけです。strong タグはありません。</p>
<h2>スキーマはどのように見えるか</h2>
<p>提供されている拡張機能のみを使用する場合は、スキーマについてそれほど気にする必要はありません。独自の拡張機能を構築している場合は、スキーマがどのように機能するかを理解しておくと役立つでしょう。典型的な ProseMirror エディターの最も単純なスキーマを見てみましょう。</p>

<pre><code class="language-js">// the underlying ProseMirror schema
{
  nodes: {
    document: {
      content: 'block+',
    },
    paragraph: {
      content: 'inline*',
      group: 'block',
      parseDOM: [{ tag: 'p' }],
      toDOM: () =&gt; ['p', 0],
    },
    text: {
      group: 'inline',
    },
  },
}
</code></pre>


<p>ここで3つのノードを登録します。<code>doc</code>、<code>paragraph</code> および <code>text</code>。<code>doc</code> は、1つ以上のブロックノードを子として許可するルートノードです（<code>content: 'block+'</code>）。<code>paragraph</code> はブロックノードのグループ（<code>group: 'block'</code>）にあるため、ドキュメントには段落のみを含めることができます。私たちの段落では、0個以上のインラインノードを子として許可しているため（<code>content: 'inline*'</code>）、その中には <code>text</code> しか含めることができません。<code>parseDOM</code> は、貼り付けられた HTML からノードを解析する方法を定義します。<code>toDOM</code> は、DOM でのレンダリング方法を定義します。</p>
<p>Tiptapでは、すべてのノード、マーク、および拡張子が独自のファイルに存在します。これにより、ロジックを分割できます。内部的には、スキーマ全体がマージされます。</p>
<pre><code class="language-js">// the Tiptap schema API

const Document = Node.create({
  name: 'doc',
  topNode: true,
  content: 'block+',
})

const Paragraph = Node.create({
  name: 'paragraph',
  group: 'block',
  content: 'inline*',
  parseHTML() {
    return [
      { tag: 'p' },
    ]
  },
  renderHTML({ HTMLAttributes }) {
    return ['p', HTMLAttributes, 0]
  },
})

const Text = Node.create({
  name: 'text',
  group: 'inline',
})
</code></pre>
<h2>ノードとマーク</h2>
<h3>違い</h3>


<p>ノードは、段落、見出し、コードブロック、ブロッククォートなどのコンテンツのブロックのようなものです。</p>
<p>マークは、ノードの特定の部分に適用できます。これは、<strong>太字</strong>、<em>斜体</em>、または<del>打たれた</del>テキストの場合です。<a href="#">Links</a> もマークです。</p>
<h3>ノードスキーマ</h3>
<h4>Content</h4>
<p>content 属性は、ノードが持つことができるコンテンツの種類を正確に定義します。 ProseMirror はそれに対して本当に厳格です。つまり、スキーマに適合しないコンテンツは破棄されます。名前またはグループを文字列として想定しています。次にいくつかの例を示します。</p>

<pre><code class="language-js">Node.create({
  // must have one or more blocks
  content: 'block+',

  // must have zero or more blocks
  content: 'block*',

  // allows all kinds of 'inline' content (text or hard breaks)
  content: 'inline*',

  // must not have anything else than 'text'
  content: 'text*',

  // can have one or more paragraphs, or lists (if lists are used)
  content: '(paragraph|list?)+',

  // must have exact one heading at the top, and one or more blocks below
  content: 'heading block+'
})
</code></pre>
<h4>Marks</h4>
<p>スキーマの <code>marks</code> 設定を使用して、ノード内で許可されるマークを定義できます。 1つ以上の名前またはマークのグループを追加し、次のようにすべてのマークを許可または禁止します。</p>

<pre><code class="language-js">Node.create({
  // allows only the 'bold' mark
  marks: 'bold',

  // allows only the 'bold' and 'italic' marks
  marks: 'bold italic',

  // allows all marks
  marks: '_',

  // disallows all marks
  marks: '',
})
</code></pre>
<h4>Group</h4>

<p>このノードを拡張機能のグループに追加します。拡張機能は、スキーマの<a href="#content">content</a> 属性で参照できます。</p>
<pre><code class="language-js">Node.create({
  // add to 'block' group
  group: 'block',

  // add to 'inline' group
  group: 'inline',

  // add to 'block' and 'list' group
  group: 'block list',
})
</code></pre>
<h4>Inline</h4>

<p>ノードはインラインでレンダリングすることもできます。<code>inline: true</code> を設定すると、ノードはテキストに沿ってレンダリングされます。それは言及の場合です。結果はマークに似ていますが、ノードの機能を備えています。 1つの違いは、結果の JSON ドキュメントです。複数のマークが一度に適用されると、インラインノードはネストされた構造になります。</p>
<pre><code class="language-js">Node.create({
  // renders nodes in line with the text, for example
  inline: true,
})
</code></pre>

<p>ノードビューなど、マークで使用できない機能が必要な場合は、インラインノードが機能するかどうかを試してください。</p>
<pre><code class="language-js">Node.create({
  name: 'customInlineNode',
  group: 'inline',
  inline: true,
  content: 'text*',
})
</code></pre>
<h4>Atom</h4>

<p><code>atom: true</code> のノードは直接編集できないため、単一のユニットとして扱う必要があります。これをエディターのコンテキストで使用する可能性はそれほど高くありませんが、次のようになります。</p>
<pre><code class="language-js">Node.create({
  atom: true,
})
</code></pre>

<p>1つの例は、<a href="/api/nodes/mention"><code>Mention</code></a> 拡張機能です。これは、どういうわけかテキストのように見えますが、単一のユニットのように動作します。これには編集可能なテキストコンテンツがないため、そのようなノードをコピーすると空になります。良いニュースですが、あなたはそれをコントロールすることができます。 <a href="/api/nodes/mention"><code>Mention</code></a> 拡張機能の例を次に示します。</p>
<pre><code class="language-js">// Used to convert an atom node to plain text
renderText({ node }) {
  return `@${node.attrs.id}`
},
</code></pre>
<h4>Selectable</h4>

<p>すでに表示されているテキストの選択に加えて、非表示のノードの選択があります。ノードを選択可能にする場合は、次のように構成できます。</p>
<pre><code class="language-js">Node.create({
  selectable: true,
})
</code></pre>
<h4>Draggable</h4>

<p>この設定を使用すると、すべてのノードをドラッグ可能に構成できます（デフォルトではドラッグ可能ではありません）。</p>
<pre><code class="language-js">Node.create({
  draggable: true,
})
</code></pre>
<h4>Code</h4>

<p>ユーザーは、コードの動作が大きく異なることを期待しています。コードを含むすべての種類のノードについて、これを考慮に入れるために  <code>code: true</code> を設定できます。</p>
<pre><code class="language-js">Node.create({
  code: true,
})
</code></pre>
<h4>Whitespace</h4>

<p>このノードの空白を解析する方法を制御します。</p>
<pre><code class="language-js">Node.create({
  whitespace: 'pre',
})
</code></pre>
<h4>Defining</h4>

<p>デフォルトでは、コンテンツ全体が置き換えられると（たとえば、新しいコンテンツを貼り付けるときに）、ノードはドロップされます。このような置換操作のためにノードを保持する必要がある場合は、それらを「defining (定義)」として構成します。</p>
<p>通常、これは <a href="/api/nodes/blockquote"><code>Blockquote</code></a>, <a href="/api/nodes/code-block"><code>CodeBlock</code></a>, <a href="/api/nodes/heading"><code>Heading</code></a>, <a href="/api/nodes/list-item"><code>ListItem</code></a> に適用されます。</p>

<pre><code class="language-js">Node.create({
  defining: true,
})
</code></pre>
<h4>Isolating</h4>

<p>TableCell など、バックスペースなどの通常の編集操作のためにカーソルをフェンスする必要があるノードの場合は <code>isolating: true</code> を設定します。</p>
<pre><code class="language-js">Node.create({
  isolating: true,
})
</code></pre>
<h4>ギャップカーソルを許可する</h4>
<p><a href="/api/extensions/gapcursor"><code>Gapcursor</code></a> 拡張機能は、新しいスキーマ属性を登録して、そのノードのすべての場所でギャップカーソルを許可するかどうかを制御します。</p>

<pre><code class="language-js">Node.create({
  allowGapCursor: false,
})
</code></pre>
<h4>テーブルの役割</h4>
<p><a href="/api/nodes/table"><code>Table</code></a> 拡張機能は、ノードが持つ役割を構成するための新しいスキーマ属性を登録します。許可される値は <code>table</code>、<code>row</code>、<code>cell</code>、および <code>header_cell</code> です。</p>

<pre><code class="language-js">Node.create({
  tableRole: 'cell',
})
</code></pre>
<h3>マークスキーマ</h3>
<h4>Inclusive</h4>
<p>カーソルが最後にあるときにマークをアクティブにしたくない場合は、包括的を <code>false</code> に設定します。たとえば、<a href="/api/marks/link"><code>Link</code></a> マークの設定方法は次のとおりです。</p>

<pre><code class="language-js">Mark.create({
  inclusive: false,
})
</code></pre>
<h4>Excludes</h4>
<p>デフォルトでは、すべてのノードを同時に適用できます。除外属性を使用すると、マークと共存してはならないマークを定義できます。たとえば、インラインコードマークは他のマーク（太字、斜体、その他すべて）を除外します。</p>

<pre><code class="language-js">Mark.create({
  // must not coexist with the bold mark
  excludes: 'bold'
  // exclude any other mark
  excludes: '_',
})
</code></pre>
<h4>Group</h4>

<p>このマークを拡張機能のグループに追加します。これは、スキーマのコンテンツ属性で参照できます。</p>
<pre><code class="language-js">Mark.create({
  // add this mark to the 'basic' group
  group: 'basic',
  // add this mark to the 'basic' and the 'foobar' group
  group: 'basic foobar',
})
</code></pre>
<h4>Code</h4>

<p>ユーザーは、コードの動作が大きく異なることを期待しています。コードを含むすべての種類のマークについて、これを考慮に入れるために <code>code: true</code> を設定できます。</p>
<pre><code class="language-js">Mark.create({
  code: true,
})
</code></pre>
<h4>Spanning</h4>

<p>デフォルトでは、マークは HTML としてレンダリングされるときに、複数のノードにまたがることができます。マークが複数のノードにまたがってはならないことを示すには、<code>spanning: false</code> を設定します。</p>
<pre><code class="language-js">Mark.create({
  spanning: false,
})
</code></pre>
<h2>基礎となる ProseMirror スキーマを取得します</h2>
<p>基盤となるスキーマを操作する必要があるユースケースがいくつかあります。 Tiptap の共同テキスト編集機能を使用している場合、またはコンテンツを HTML として手動でレンダリングする場合は、これが必要になります。</p>

<h3>オプション1：エディターを使用</h3>
<p>クライアント側でこれが必要で、とにかくエディタインスタンスが必要な場合は、エディタから利用できます。</p>

<pre><code class="language-js">
const editor = new Editor({
  extensions: [
    Document,
    Paragraph,
    Text,
    // add more extensions here
  ])
})

const schema = editor.schema
</code></pre>
<h3>オプション2：エディターなし</h3>
<p>実際のエディターを初期化せずにスキーマを作成したいだけの場合は、<code>getSchema</code> ヘルパー関数を使用できます。利用可能な拡張機能の配列が必要であり、ProseMirror スキーマを便利に生成します。</p>

<pre><code class="language-js">
const schema = getSchema([
  Document,
  Paragraph,
  Text,
  // add more extensions here
])
</code></pre>
<h1>イベント</h1>
<h2>はじめに</h2>

<p>エディターは、フックできるいくつかの異なるイベントを発生させます。まず、利用可能なすべてのイベントを見てみましょう。</p>
<h2>利用可能なイベントのリスト</h2>
<h3>beforeCreate</h3>

<p>ビューが作成される前</p>
<h3>create</h3>

<p>エディターの準備が完了したとき</p>
<h3>update</h3>

<p>内容が変更したとき</p>
<h3>selectionUpdate</h3>

<p>選択が変更されたとき</p>
<h3>transaction</h3>

<p>エディターの状態が変更されたとき</p>
<h3>focus</h3>

<p>エディターに焦点を当てたとき</p>
<h3>blur</h3>

<p>エディターがフォーカスを合わせていないとき</p>
<h3>destroy</h3>

<p>エディターが破棄されたとき</p>
<h2>Register event listeners</h2>

<p>イベントリスナーを登録する方法は3つあります。</p>
<h3>オプション 1: コンフィギュレーション</h3>

<p>新しいエディターインスタンスでイベントリスナーをすぐに定義できます。</p>
<pre><code class="language-js">const editor = new Editor({
  onBeforeCreate({ editor }) {
    // Before the view is created.
  },
  onCreate({ editor }) {
    // The editor is ready.
  },
  onUpdate({ editor }) {
    // The content has changed.
  },
  onSelectionUpdate({ editor }) {
    // The selection has changed.
  },
  onTransaction({ editor, transaction }) {
    // The editor state has changed.
  },
  onFocus({ editor, event }) {
    // The editor is focused.
  },
  onBlur({ editor, event }) {
    // The editor isn’t focused anymore.
  },
  onDestroy() {
    // The editor is being destroyed.
  },
})
</code></pre>
<h3>Option 2: バインディング</h3>

<p>または、実行中のエディターインスタンスにイベントリスナーを登録できます。</p>
<h4>バインドイベントリスナー</h4>
<pre><code class="language-js">editor.on('beforeCreate', ({ editor }) =&gt; {
  // Before the view is created.
})

editor.on('create', ({ editor }) =&gt; {
  // The editor is ready.
})

editor.on('update', ({ editor }) =&gt; {
  // The content has changed.
})

editor.on('selectionUpdate', ({ editor }) =&gt; {
  // The selection has changed.
})

editor.on('transaction', ({ editor, transaction }) =&gt; {
  // The editor state has changed.
})

editor.on('focus', ({ editor, event }) =&gt; {
  // The editor is focused.
})

editor.on('blur', ({ editor, event }) =&gt; {
  // The editor isn’t focused anymore.
})

editor.on('destroy', () =&gt; {
  // The editor is being destroyed.
})
</code></pre>
<h4>イベントリスナーのバインドを解除</h4>

<p>ある時点でこれらのイベントリスナーのバインドを解除する必要がある場合は、イベントリスナーを <code>.on()</code> で登録し、 <code>.off()</code> でバインドを解除する必要があります。</p>
<pre><code class="language-js">const onUpdate = () =&gt; {
  // The content has changed.
}

// Bind …
editor.on('update', onUpdate)

// … and unbind.
editor.off('update', onUpdate)
</code></pre>
<h3>Option 3: 拡張機能</h3>

<p>イベントリスナーをカスタム拡張機能（またはノード、またはマーク）に移動することも可能です。これは次のようになります。</p>
<pre><code class="language-js">
const CustomExtension = Extension.create({
  onBeforeCreate({ editor }) {
    // Before the view is created.
  },
  onCreate({ editor }) {
    // The editor is ready.
  },
  onUpdate({ editor }) {
    // The content has changed.
  },
  onSelectionUpdate({ editor }) {
    // The selection has changed.
  },
  onTransaction({ editor, transaction }) {
    // The editor state has changed.
  },
  onFocus({ editor, event }) {
    // The editor is focused.
  },
  onBlur({ editor, event }) {
    // The editor isn’t focused anymore.
  },
  onDestroy() {
    // The editor is being destroyed.
  },
})
</code></pre>
